##What is virtual machine?
- Software simulation of a machine, which can perform operation like a physical machine.
- Type of Virtual Machine 
	- H/W Based or System Based VM 
	- Application Based or Process based  VM   
- Main advantage of H/W Based or System Based VM is,
    - H/W resources sharing - taken care by admin 
    - Improves utilization of H/W resources
        - KVM (Kernel Based VM for Linux systems)
        - VM Ware 
        - Cloud computing  
- Our focus is Application Based or Process based  VM
    - Has Runtime engines(RE) to run particular language programs applications   
        - JVM (Java Virtual Machine) acts as RE to run Java based app
        - PVM (Parrot Based VM) acts as RE to run Perl based applications  
        - CLR (Common Language Runtime) acts as RE to run .Net based applications
    - JDK -has-> JRE  -has-> JVM 
    - JVM is responsible to load and run Java class files    
- Classloader subsystem is responsible for following 3 activities 
    - Loading
        - Loading means reading class files and store corresponding binary data in **Method Area**. 
        - For each class file loaded, JVM will store corresponding information into Method Area 
            - Fully Qualified name of class
            - Fully Qualified name of super class   
            - Methods information 
            - Variables info
            - Constructors info 
            - Modifiers info 
            - Constant pool info etc.
        - After loading .class file immediately JVM creates an object for that loaded class on the heap memory of type java.lang.Class
            - for every loaded type only Class object is created, even though we are using that class multiple times in our program  
        - Hard-disk, Method Area, Heap Area are involved.
        - Class class object can be used by programmer to get class level information like methods info, variables info, constructor info etc.
        - How to use Class class object 
            - Class.forName("Student")   
    - Linking 
        - Verify / Verification
            - Verification (§4.10) ensures that the binary representation of a class or interface is structurally correct (§4.9). Verification may cause additional classes and interfaces to be loaded (§5.3) but need not cause them to be verified or prepared.
            - If the binary representation of a class or interface does not satisfy the static or structural constraints listed in §4.9, then a VerifyError must be thrown at the point in the program that caused the class or interface to be verified.
            - If an attempt by the Java Virtual Machine to verify a class or interface fails because an error is thrown that is an instance of LinkageError (or a subclass), then subsequent attempts to verify the class or interface always fail with the same error that was thrown as a result of the initial verification attempt.        
            - Background  
                - Java is secure 
                - Byte Code Verifier - verifies that .class bytecode is generated by verified source, not something created by humans to spread virus
                - We can run .class file on any machine and it can't cause any harm, system won't show any warning that file is harmful.
            - Verification is the process of ensuring that Binary representation of a class is structurally correct or not, 
                - i.e. JVM will check whether .class is generated by valid compiler or not
                - i.e. whether .class file is properly formatted or not
                - internally Byte Code Verifier is responsible for this activity 
                - Byte Code Verifier is a part of Classloader subsystem
                - If verification fails - we would get exception saying java.lang.VerifyError     
        - Prepare / Preparation 
            - In this phase JVM will allocate memory for class level static variables 
            - Assign default values     
            - In initialization phase original values will be assigned to the static variables
            - Under here Only default value will be assigned   
            
        - Resolve / Resolution 
            - It is the process of replacing symbolic names in our program with original memory references from method area
            - class loader loads Test.class, String.class, Student.class and Object.class 
            - The names of these classes are stored in constant pool of Test class 
            - In resolution phase these names are replaced with original memory level references from Method Area              
            - Notes from Spec   
                - The Java Virtual Machine instructions anewarray, checkcast, getfield, getstatic, instanceof, invokedynamic, invokeinterface, invokespecial, invokestatic, invokevirtual, ldc, ldc_w, multianewarray, new, putfield, and putstatic make symbolic references to the run-time constant pool. Execution of any of these instructions requires resolution of its symbolic reference.
                - Resolution is the process of dynamically determining concrete values from symbolic references in the run-time constant pool.
                - Resolution of the symbolic reference of one occurrence of an invokedynamic instruction does not imply that the same symbolic reference is considered resolved for any other invokedynamic instruction.
                - For all other instructions above, resolution of the symbolic reference of one occurrence of an instruction does imply that the same symbolic reference is considered resolved for any other non-invokedynamic instruction.
                - (The above text implies that the concrete value determined by resolution for a specific invokedynamic instruction is a call site object bound to that specific invokedynamic instruction.)
                - Resolution can be attempted on a symbolic reference that has already been resolved. An attempt to resolve a symbolic reference that has already successfully been resolved always succeeds trivially and always results in the same entity produced by the initial resolution of that reference.
                - If an error occurs during resolution of a symbolic reference, then an instance of IncompatibleClassChangeError (or a subclass) must be thrown at a point in the program that (directly or indirectly) uses the symbolic reference.
                - If an attempt by the Java Virtual Machine to resolve a symbolic reference fails because an error is thrown that is an instance of LinkageError (or a subclass), then subsequent attempts to resolve the reference always fail with the same error that was thrown as a result of the initial resolution attempt.
                - A symbolic reference to a call site specifier by a specific invokedynamic instruction must not be resolved prior to execution of that instruction.
                - In the case of failed resolution of an invokedynamic instruction, the bootstrap method is not re-executed on subsequent resolution attempts.
                - Certain of the instructions above require additional linking checks when resolving symbolic references. For instance, in order for a getfield instruction to successfully resolve the symbolic reference to the field on which it operates, it must not only complete the field resolution steps given in §5.4.3.2 but also check that the field is not static. If it is a static field, a linking exception must be thrown.
                - Notably, in order for an invokedynamic instruction to successfully resolve the symbolic reference to a call site specifier, the bootstrap method specified therein must complete normally and return a suitable call site object. If the bootstrap method completes abruptly or returns an unsuitable call site object, a linking exception must be thrown.
                - Linking exceptions generated by checks that are specific to the execution of a particular Java Virtual Machine instruction are given in the description of that instruction and are not covered in this general discussion of resolution. Note that such exceptions, although described as part of the execution of Java Virtual Machine instructions rather than resolution, are still properly considered failures of resolution.
                - The following sections describe the process of resolving a symbolic reference in the run-time constant pool (§5.1) of a class or interface D. Details of resolution differ with the kind of symbolic reference to be resolved.         
    - Initialization
        - In this phase all Static variables are assigned with original values and  
        - Static block will be executed 
            - from Parent to Child and 
            - from Top to Bottom         
    - While loading, linking and initialization if any error occurs, then we will get runtime exception saying java.lang.LinkageError
- Types of Class loaders 
    - Bootstrap Class Loader | Primordial Class Loader   
        - responsible to load core java api classes i.e. classes present in rt.jar 
        - bootstrap classpath --> JRE/lib/rt.jar
        - bootstrap classloader is responsible to load classes from bootstrap classpath
        - bootstrap classloader is by-default available with every JVM
        - bootstrap classloader is implemented in native lang like c/c++ and not implemented in Java   
    - Extension Class Loader
        - extension classpath --> JRE/lib/ext
        - extension classloader is responsible to load classes from extension classpath
        - extension classloader is child class of bootstrap classloader  
        - extension classloader is implemented in Java
            - sun.misc.Launcher$ExtClassLoader.class          
    - Application Class Loader | System Class Loader 
        - application classloader is child class of extension classloader
        - application classloader is responsible to load classes from application classpath (CLASSPATH, our env variable)
        - application classloader is implemented in Java
            - sun.misc.Launcher$AppClassLoader.class  
- How class loader works 
    - Class loader follows Delegation Hierarchy principle/algorithm 
    - Whenever JVM comes across a particular class 
        - first it will check whether that corresponding .class file is already loaded or now
            - if it already loaded in method area then JVM will consider that loaded class                             
            - if it is not loaded then JVM will request class loader subsystem to load that particular class 
                - then class loader subsystem handover the request to Application Class Loader
                - Application Class Loader delegates the request to Extension Class Loader
                - Extension Class Loader delegates the request to Bootstrap Class Loader
                - Bootstrap Class Loader would search in Bootstrap Class path
                    - if it is available then corresponding class file would be loaded by Bootstrap Class Loader
                    - if it is not available then Bootstrap Class Loader would delegate the request to Extension Class Loader
                - Extension Class Loader would search in Extension Class path
                    - if it is available then corresponding class file would be loaded by Extension Class Loader
                    - if it is not available then Extension Class Loader would delegate the request to Application Class Loader                
                - Application Class Loader would search in Application Class path    
                    - if it is available then corresponding class file would be loaded by Application Class Loader
                    - if it is not available we will get Runtime exception - ClassNotFoundException | NoClassDefFoundException 
    - Assume Customer classfile is present in bot extension and application classpath and test class file is present in only application classpath
        - String.class : 
            - Bootstrap classloader from bootstrap classpath : 
            - Native object that's why : null
        - Customer.class : 
            - Extension classloader from Extension classpath : 
            - jdk.internal.loader.ClassLoaders$ExtClassLoader --> Java Objects
        - Test.class : 
            - Application classloader from Application classpath : 
            - jdk.internal.loader.ClassLoaders$AppClassLoader  --> Java Objects    
    - Class loader subsystem would give highest priority for Bootstrap classpath, then extension classpath, followed by application classpath           
- Defining our own of Customized Class Loader 
    - Need of Customized Class Loader 
    - [server [ app 1 ]]      
- Default classloader loads class only 1 time even though we are using that class file multiple times 
    - after loading class file if it is modified outside then default class loader won't load updated version of class file 
    - because .class file is already available in method area
- we can resolve this problem by defining our own customized classloader
- the main advantage of customized classloader is we can control classloading mechanism based on our requirement 
- e.g. we can load .class file separately every time so that updated version is available to our program           
### References 
- https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html
- https://www.baeldung.com/java-classloaders
- https://www.geeksforgeeks.org/classloader-in-java/
   