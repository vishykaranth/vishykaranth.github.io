### Challenges of 2 Phase commit
- The fundamental difficulty with 2PC is that, 
    - once the decision to commit has been made by the co-ordinator and communicated to some replicas, 
    - the replicas go right ahead and act upon the commit statement **without checking** to see if every other replica got the message. 
    - Then, if a replica that committed crashes along with the co-ordinator, 
    - the system has no way of telling what the result of the transaction was (since only the co-ordinator and the replica that got the message know for sure). 
    - Since the transaction might already have been committed at the crashed replica, 
    - the protocol cannot pessimistically abort - as the transaction might have had side-effects that are impossible to undo. 
    - Similarly, the protocol cannot optimistically force the transaction to commit, as the original vote might have been to abort.
- Two Phase Commit (2PC) is one of the failure recovery protocols commonly used in distributed database management system. 
    - It has a disadvantage of getting blocked under certain circumstances. 
    - For example, assume a case where the coordinator of a particular transaction is failed, 
    - and the participating sites have all sent <READY T> message to the coordinator. 
    - Now, participating sites do not have either <ABORT T> or <COMMIT T>. 
    - At this stage, no site can take a final decision on its own. 
    - Only solution is to wait for the recovery of the coordinator site. 
    - Hence, **2PC is a blocking protocol**.    
    
- 3PC is a protocol that eliminates this blocking problem on certain basic requirements;
    - No network partitioning
    - At least one site must be available
    - At most K simultaneous site failures are accepted
    - 2PC has two phases namely 
        - voting phase and 
        - decision phase. 
    - 3PC introduces 
        - pre-commit phase 
            - (serves as a buffer phase) as the third phase. 
    - 3PC works as follows;    
        - Phase 1 (WAIT/VOTING):
            - Transaction Coordinator (TC) of the transaction writes BEGIN_COMMIT message in its log file and sends PREPARE message to all the participating sites and waits.
            - Upon receiving this message, if a site is ready to commit, then the site’s transaction manager (TM) writes READY in its log and send VOTE_COMMIT to TC.
            - If any site is not ready to commit, it writes ABORT in its log and responds with VOTE_ABORT to the TC.
        - Phase 2 (PRE-COMMIT):
            - If TC received VOTE_COMMIT from all the participating sites, 
                - then it writes PREPARE_TO_COMMIT in its log and sends PREPARE_TO_COMMIT message to all the participating sites.
            - On the other hand, if TC receives any one VOTE_ABORT message, 
                - it writes ABORT in its log and sends GLOBAL_ABORT to all the participating sites and also writes END_OF_TRANSACTION message in its log.
            - On receiving the message PREPARE_TO_COMMIT, 
                - the TM of participating sites write PREPARE_TO_COMMIT in their log and respond with READY_TO_COMMIT message to the TC.
            - If they receive GLOBAL_ABORT message, 
                - then TM of the sites write ABORT in their logs and acknowledge the abort. 
                - Also, they abort that particular transaction locally.
        - Phase 3 (COMMIT/DECIDING):
            - If all responses are READY_TO_COMMIT, 
            - then TC writes COMMIT in its log and send GLOBAL_COMMIT message to all the participating sites’ TMs. 
            - The TM of those sites then writes COMMIT in their log and sends an acknowledgement to the TC. 
            - Then, TC writes END_OF_TRANSACTION in its log.     

### Solution is 3 PC    
- This problem is - mostly - circumvented by the addition of an extra phase to 2PC, 
    - unsurprisingly giving us a three-phase commit protocol. 
    - We break the second phase of 2PC - ‘commit’ - into two sub-phases. 
        - The first is the ‘prepare to commit’ phase. 
            - The co-ordinator sends this message to all replicas when it has received unanimous ‘yes’ votes in the first phase. 
        - On receipt of this messages, replicas get into a state where they are able to commit the transaction 
            - by taking necessary locks and so forth 
            - but crucially do not do any work that they cannot later undo. 
            - They then reply to the co-ordinator telling it that the ‘prepare to commit’ message was received.
- The purpose of this phase is to communicate the result of the vote to every replica so that the state of the protocol can be recovered no matter which replica dies.
- The last phase of the protocol does almost exactly the same thing as the original ‘commit or abort’ phase in 2PC. 
    - If the co-ordinator receives confirmation of the delivery of the ‘prepare to commit’ message from all replicas, 
    - it is then safe to go ahead with committing the transaction. 
    - However, if delivery is not confirmed, 
    - the co-ordinator cannot guarantee that the protocol state will be recovered should it crash 
    - (if you are tolerating a fixed number ff of failures, the co-ordinator can go ahead once it has received f+1f+1 confirmations). 
    - In this case, the co-ordinator will abort the transaction.
- If the co-ordinator should crash at any point, 
    - a recovery node can take over the transaction and query the state from any remaining replicas. 
    - If a replica that has committed the transaction has crashed, 
    - we know that every other replica has received a ‘prepare to commit’ message (otherwise the co-ordinator wouldn’t have moved to the commit phase), 
    - and therefore the recovery node will be able to determine that the transaction was able to be committed, 
    - and safely shepherd the protocol to its conclusion. 
    - If any replica reports to the recovery node that it has not received ‘prepare to commit’, 
    - the recovery node will know that the transaction has not been committed at any replica, 
    - and will therefore be able either to pessimistically abort or re-run the protocol from the beginning.
- So does 3PC fix all our problems? 
    - Not quite, but it comes close. 
    - In the case of a network partition, the wheels rather come off - imagine that all the replicas that received ‘prepare to commit’ are on one side of the partition, 
    - and those that did not are on the other. 
    - Then both partitions will continue with recovery nodes that respectively commit or abort the transaction, 
    - and when the network merges the system will have an inconsistent state. 
    - So 3PC has potentially unsafe runs, as does 2PC, 
    - but will always make progress and therefore satisfies its liveness properties. 
    - The fact that 3PC will not block on single node failures makes it much more appealing for services where high availability is more important than low latencies.        

### 3 Phase Commit 
- Advantages of 3PC Protocol
    - The Blocking problem found in 2PC can be avoided 
    - (in certain occasions, especially when at least not more than k sites failed)
- Disadvantages of 3PC Protocol
    - Network partitions (network segments) would cause Blocking Problem, 
        - especially if more than k sites are part of any partitions.  
    - Long latency due to the number of messages to be transferred between sites on taking decision. 
        - That is, it involves 3 phases and all the 3 phases involve communication between sites.
        
### References 
- http://www.exploredatabase.com/2018/03/three-phase-commit-3pc-protocol-in-distributed-database-transactions.html
        