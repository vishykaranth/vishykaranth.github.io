# Optimistic Locking: In-Depth Explanation

## Table of Contents
1. [Introduction](#introduction)
2. [What is Optimistic Locking?](#what-is-optimistic-locking)
3. [How Optimistic Locking Works](#how-optimistic-locking-works)
4. [Optimistic vs Pessimistic Locking](#optimistic-vs-pessimistic-locking)
5. [Implementation Strategies](#implementation-strategies)
6. [Version-Based Optimistic Locking](#version-based-optimistic-locking)
7. [Timestamp-Based Optimistic Locking](#timestamp-based-optimistic-locking)
8. [Optimistic Locking in JPA/Hibernate](#optimistic-locking-in-jpahibernate)
9. [Handling Optimistic Lock Exceptions](#handling-optimistic-lock-exceptions)
10. [Use Cases and When to Use](#use-cases-and-when-to-use)
11. [Advantages and Disadvantages](#advantages-and-disadvantages)
12. [Real-World Examples](#real-world-examples)
13. [Best Practices](#best-practices)

---

## Introduction

### The Concurrency Problem

In multi-user applications, multiple users might try to modify the same data simultaneously. This can lead to:

- **Lost Updates**: One user's changes overwrite another user's changes
- **Dirty Reads**: Reading uncommitted data
- **Inconsistent Data**: Partial updates from concurrent transactions

### Solution: Locking Mechanisms

Locking mechanisms prevent concurrent access issues. There are two main approaches:

1. **Pessimistic Locking**: Assume conflicts will happen, lock data upfront
2. **Optimistic Locking**: Assume conflicts are rare, check at commit time

---

## What is Optimistic Locking?

### Definition

**Optimistic Locking** is a concurrency control strategy that assumes conflicts between concurrent transactions are rare. Instead of locking data during read operations, it allows multiple transactions to read and modify data simultaneously, but checks for conflicts only when committing changes.

### Key Concept

**"Trust but Verify"** - Allow concurrent access, but verify no conflicts occurred before committing.

### How It Works (High-Level)

1. **Read Phase**: Transaction reads data (no locks)
2. **Modify Phase**: Transaction modifies data in memory
3. **Commit Phase**: Before committing, check if data was modified by another transaction
   - If **no conflict**: Commit successfully
   - If **conflict detected**: Rollback and retry or throw exception

### Visual Flow

```
Transaction A                    Transaction B
     |                                |
     |-- Read Record (v1)             |
     |                                |-- Read Record (v1)
     |                                |
     |-- Modify Data                  |-- Modify Data
     |                                |
     |-- Commit: Check Version        |
     |   Version = v1? ✓              |
     |   Update to v2                 |
     |   ✓ Success                    |
     |                                |
     |                                |-- Commit: Check Version
     |                                |   Version = v1? ✗ (now v2!)
     |                                |   ✗ OptimisticLockException
```

---

## How Optimistic Locking Works

### Step-by-Step Process

#### 1. Initial Read (No Lock)

```java
// Transaction A reads record
User user = userRepository.findById(1L);
// Version = 1, Name = "Alice", Balance = 1000

// Transaction B also reads the same record
User user = userRepository.findById(1L);
// Version = 1, Name = "Alice", Balance = 1000
```

**Key Point**: Both transactions read the same version. No locks are acquired.

#### 2. Modify Data

```java
// Transaction A modifies
user.setBalance(1500); // In memory only

// Transaction B modifies
user.setBalance(2000); // In memory only
```

**Key Point**: Both transactions modify data independently in memory.

#### 3. Commit and Verify

```java
// Transaction A commits first
userRepository.save(user);
// SQL: UPDATE users SET balance = 1500, version = 2 
//      WHERE id = 1 AND version = 1
// Result: 1 row updated ✓
// Version incremented to 2

// Transaction B tries to commit
userRepository.save(user);
// SQL: UPDATE users SET balance = 2000, version = 2 
//      WHERE id = 1 AND version = 1
// Result: 0 rows updated ✗
// Version check failed! (Current version is 2, not 1)
// Throws OptimisticLockException
```

**Key Point**: The version check in the WHERE clause ensures only one transaction succeeds.

### The Version Field

The version field is crucial for optimistic locking:

```java
@Entity
public class User {
    @Id
    private Long id;
    
    private String name;
    private BigDecimal balance;
    
    @Version  // Optimistic locking version field
    private Long version; // Automatically incremented on update
}
```

**How Version Works:**
- Initial value: `0` or `1`
- Incremented automatically on each update
- Used in WHERE clause to detect conflicts
- If version doesn't match → conflict detected

---

## Optimistic vs Pessimistic Locking

### Comparison Table

| Aspect | Optimistic Locking | Pessimistic Locking |
|--------|-------------------|---------------------|
| **Philosophy** | Conflicts are rare | Conflicts are common |
| **Lock Timing** | At commit time | At read time |
| **Lock Duration** | Very short (commit only) | Long (entire transaction) |
| **Performance** | Better (no locks during read) | Worse (locks block others) |
| **Scalability** | High (allows concurrent reads) | Low (blocks concurrent access) |
| **Conflict Detection** | At commit (may need retry) | Prevents conflicts upfront |
| **Use Case** | Low conflict scenarios | High conflict scenarios |
| **Database Load** | Lower | Higher |
| **User Experience** | May need retry on conflict | Immediate feedback |

### Detailed Comparison

#### Optimistic Locking

```java
// Transaction A
User user = userRepository.findById(1L); // No lock, just read
user.setBalance(1500);
userRepository.save(user); // Lock only during commit
// If conflict: OptimisticLockException

// Transaction B (concurrent)
User user = userRepository.findById(1L); // No lock, can read
user.setBalance(2000);
userRepository.save(user); // May fail if A committed first
```

**Characteristics:**
- ✅ No blocking during read
- ✅ High concurrency
- ✅ Better performance
- ❌ May fail at commit time
- ❌ Requires retry logic

#### Pessimistic Locking

```java
// Transaction A
User user = userRepository.findById(1L, LockModeType.PESSIMISTIC_WRITE);
// SELECT ... FOR UPDATE - Locks the row
user.setBalance(1500);
userRepository.save(user); // Commit releases lock
// Transaction B waits until A completes

// Transaction B (concurrent)
User user = userRepository.findById(1L, LockModeType.PESSIMISTIC_WRITE);
// BLOCKED - waits for Transaction A to release lock
user.setBalance(2000);
userRepository.save(user);
```

**Characteristics:**
- ✅ Prevents conflicts upfront
- ✅ Guaranteed success (no retries)
- ❌ Blocks concurrent access
- ❌ Lower performance
- ❌ Can cause deadlocks

### When to Use Which?

**Use Optimistic Locking when:**
- Conflicts are rare
- High read-to-write ratio
- Need high concurrency
- Can handle retries
- Web applications with short transactions

**Use Pessimistic Locking when:**
- Conflicts are frequent
- Critical operations (money transfers)
- Cannot tolerate retries
- Long-running transactions
- Need guaranteed success

---

## Implementation Strategies

### Strategy 1: Version Number

Most common approach - use an integer version field.

```java
@Entity
public class Product {
    @Id
    private Long id;
    
    private String name;
    private Integer quantity;
    
    @Version
    private Long version; // Automatically managed
}
```

**How it works:**
- Version starts at 0 or 1
- Incremented on each update
- Checked in WHERE clause

### Strategy 2: Timestamp

Use a timestamp to track last modification time.

```java
@Entity
public class Product {
    @Id
    private Long id;
    
    private String name;
    private Integer quantity;
    
    @Version
    private Timestamp lastModified; // Timestamp-based
}
```

**How it works:**
- Timestamp updated on each modification
- Compared during update
- Less reliable (clock skew issues)

### Strategy 3: Hash/Checksum

Compute hash of all fields and compare.

```java
@Entity
public class Product {
    @Id
    private Long id;
    
    private String name;
    private Integer quantity;
    
    private String checksum; // Hash of all fields
}
```

**How it works:**
- Compute hash of all fields
- Store hash with record
- Recompute and compare on update

---

## Version-Based Optimistic Locking

### JPA/Hibernate Implementation

```java
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private BigDecimal balance;
    
    @Version
    private Long version; // Optimistic lock version
    
    // Getters and setters
}
```

### How Version Works

#### Initial State

```sql
-- Database state
id | name  | balance | version
1  | Alice | 1000.00 | 1
```

#### Transaction A

```java
// Read
User user = userRepository.findById(1L);
// user.version = 1

// Modify
user.setBalance(1500.00);

// Save
userRepository.save(user);
```

**Generated SQL:**
```sql
UPDATE users 
SET balance = 1500.00, version = 2 
WHERE id = 1 AND version = 1
```

**Result:**
- If version matches (1 = 1) → Update succeeds, version becomes 2
- If version doesn't match → 0 rows updated → Conflict!

#### Transaction B (Concurrent)

```java
// Read (before A commits)
User user = userRepository.findById(1L);
// user.version = 1 (still sees old version)

// Modify
user.setBalance(2000.00);

// Save (after A already committed)
userRepository.save(user);
```

**Generated SQL:**
```sql
UPDATE users 
SET balance = 2000.00, version = 2 
WHERE id = 1 AND version = 1
```

**Result:**
- Version check fails (current version is 2, not 1)
- 0 rows updated
- `OptimisticLockException` thrown

### Complete Example

```java
@Service
@Transactional
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public void updateBalance(Long userId, BigDecimal newBalance) {
        // Read with version
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new UserNotFoundException(userId));
        
        // Modify
        user.setBalance(newBalance);
        
        // Save - version check happens here
        try {
            userRepository.save(user);
        } catch (OptimisticLockException e) {
            // Handle conflict
            throw new ConcurrentModificationException(
                "User was modified by another transaction. Please retry.");
        }
    }
}
```

---

## Timestamp-Based Optimistic Locking

### Implementation

```java
@Entity
@Table(name = "users")
public class User {
    @Id
    private Long id;
    
    private String name;
    private BigDecimal balance;
    
    @Version
    @Column(name = "last_modified")
    private Timestamp lastModified; // Timestamp-based version
}
```

### How It Works

```java
// Transaction A
User user = userRepository.findById(1L);
// lastModified = 2024-01-01 10:00:00

user.setBalance(1500.00);
userRepository.save(user);
// lastModified = 2024-01-01 10:00:01 (updated)

// Transaction B (concurrent)
User user = userRepository.findById(1L);
// lastModified = 2024-01-01 10:00:00 (old timestamp)

user.setBalance(2000.00);
userRepository.save(user);
// SQL: UPDATE ... WHERE id = 1 AND last_modified = '2024-01-01 10:00:00'
// Fails because last_modified is now '2024-01-01 10:00:01'
```

### Issues with Timestamp-Based

1. **Clock Skew**: Different servers may have different times
2. **Precision**: Millisecond precision may not be enough
3. **Time Zones**: Timezone issues can cause problems

**Recommendation**: Prefer version number over timestamp.

---

## Optimistic Locking in JPA/Hibernate

### Using @Version Annotation

```java
@Entity
public class Account {
    @Id
    @GeneratedValue
    private Long id;
    
    private String accountNumber;
    private BigDecimal balance;
    
    @Version
    private Long version; // Automatically managed by JPA
}
```

### Automatic Version Management

JPA/Hibernate automatically:
- Initializes version to 0 or 1 on insert
- Increments version on each update
- Includes version in WHERE clause
- Throws `OptimisticLockException` on conflict

### Manual Version Check

```java
@Service
public class AccountService {
    
    public void transfer(Long fromId, Long toId, BigDecimal amount) {
        Account from = accountRepository.findById(fromId)
            .orElseThrow();
        Account to = accountRepository.findById(toId)
            .orElseThrow();
        
        // Check version before modifying
        Long fromVersion = from.getVersion();
        Long toVersion = to.getVersion();
        
        // Business logic
        from.setBalance(from.getBalance().subtract(amount));
        to.setBalance(to.getBalance().add(amount));
        
        // Save - version check happens automatically
        accountRepository.save(from);
        accountRepository.save(to);
        
        // If version changed, OptimisticLockException is thrown
    }
}
```

### Custom Version Field

```java
@Entity
public class Product {
    @Id
    private Long id;
    
    private String name;
    
    // Custom version field name
    @Version
    @Column(name = "opt_lock_version")
    private Integer lockVersion; // Can be Integer, Long, or Timestamp
}
```

---

## Handling Optimistic Lock Exceptions

### Catching OptimisticLockException

```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public void updateUser(Long userId, UserUpdateRequest request) {
        int maxRetries = 3;
        int retryCount = 0;
        
        while (retryCount < maxRetries) {
            try {
                // Read current state
                User user = userRepository.findById(userId)
                    .orElseThrow();
                
                // Apply changes
                user.setName(request.getName());
                user.setEmail(request.getEmail());
                
                // Save - may throw OptimisticLockException
                userRepository.save(user);
                
                // Success - exit retry loop
                return;
                
            } catch (OptimisticLockException e) {
                retryCount++;
                
                if (retryCount >= maxRetries) {
                    throw new ConcurrentModificationException(
                        "Failed to update user after " + maxRetries + " retries. " +
                        "Please refresh and try again.", e);
                }
                
                // Wait before retry (exponential backoff)
                try {
                    Thread.sleep(100 * retryCount);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException("Interrupted during retry", ie);
                }
            }
        }
    }
}
```

### Retry with Exponential Backoff

```java
@Service
public class OptimisticLockRetryService {
    
    public <T> T executeWithRetry(Supplier<T> operation, int maxRetries) {
        int retryCount = 0;
        long backoffMs = 100;
        
        while (retryCount < maxRetries) {
            try {
                return operation.get();
            } catch (OptimisticLockException e) {
                retryCount++;
                
                if (retryCount >= maxRetries) {
                    throw new OptimisticLockException(
                        "Operation failed after " + maxRetries + " retries", e);
                }
                
                // Exponential backoff
                try {
                    Thread.sleep(backoffMs);
                    backoffMs *= 2; // Double the wait time
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException("Interrupted", ie);
                }
            }
        }
        
        throw new RuntimeException("Should not reach here");
    }
}

// Usage
public void updateUser(Long userId, UserUpdateRequest request) {
    executeWithRetry(() -> {
        User user = userRepository.findById(userId).orElseThrow();
        user.setName(request.getName());
        return userRepository.save(user);
    }, 3);
}
```

### User-Friendly Error Messages

```java
@ControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(OptimisticLockException.class)
    public ResponseEntity<ErrorResponse> handleOptimisticLock(
            OptimisticLockException e) {
        
        ErrorResponse error = ErrorResponse.builder()
            .code("CONCURRENT_MODIFICATION")
            .message("The record was modified by another user. " +
                    "Please refresh the page and try again.")
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(HttpStatus.CONFLICT).body(error);
    }
}
```

---

## Use Cases and When to Use

### Ideal Use Cases

#### 1. Web Applications with Short Transactions

```java
// User updates profile
@PutMapping("/users/{id}")
public ResponseEntity<User> updateUser(
        @PathVariable Long id,
        @RequestBody UserUpdateRequest request) {
    
    try {
        User user = userService.updateUser(id, request);
        return ResponseEntity.ok(user);
    } catch (OptimisticLockException e) {
        return ResponseEntity.status(HttpStatus.CONFLICT)
            .body(null); // Client should refresh and retry
    }
}
```

#### 2. High Read-to-Write Ratio

```java
// Product catalog - many reads, few writes
@Entity
public class Product {
    @Version
    private Long version; // Rare conflicts
}
```

#### 3. Collaborative Editing (with Conflict Resolution)

```java
// Document editing - multiple users can edit
@Entity
public class Document {
    @Version
    private Long version;
    
    // Merge strategy for conflicts
    public void merge(Document other) {
        // Intelligent merge logic
    }
}
```

#### 4. Inventory Management

```java
// Product inventory - concurrent orders
@Entity
public class Product {
    @Version
    private Long version;
    
    private Integer stock;
    
    public void decreaseStock(int quantity) {
        if (this.stock >= quantity) {
            this.stock -= quantity;
        else
            throw new InsufficientStockException();
    }
}
```

### When NOT to Use Optimistic Locking

1. **Critical Financial Transactions**: Use pessimistic locking
2. **High Conflict Scenarios**: Use pessimistic locking
3. **Long-Running Transactions**: Use pessimistic locking
4. **Cannot Handle Retries**: Use pessimistic locking

---

## Advantages and Disadvantages

### Advantages

#### 1. High Concurrency

```java
// Multiple transactions can read simultaneously
User user1 = userRepository.findById(1L); // No lock
User user2 = userRepository.findById(1L); // No lock
User user3 = userRepository.findById(1L); // No lock
// All can read concurrently
```

#### 2. Better Performance

- No database locks during read
- No blocking of other transactions
- Lower database load
- Better scalability

#### 3. No Deadlocks

```java
// Optimistic locking doesn't cause deadlocks
// Because no locks are held during transaction
```

#### 4. Works Well with Caching

```java
// Can cache entities without worrying about locks
@Cacheable("users")
public User findById(Long id) {
    return userRepository.findById(id).orElseThrow();
}
```

### Disadvantages

#### 1. May Fail at Commit Time

```java
// Transaction may fail after doing work
public void processOrder(Order order) {
    // Do expensive processing
    calculateTax(order);
    applyDiscounts(order);
    updateInventory(order);
    
    // May fail here due to conflict
    orderRepository.save(order); // OptimisticLockException!
    // All previous work is lost
}
```

#### 2. Requires Retry Logic

```java
// Need to implement retry mechanism
int retries = 0;
while (retries < MAX_RETRIES) {
    try {
        updateUser(user);
        break;
    } catch (OptimisticLockException e) {
        retries++;
        // Retry logic needed
    }
}
```

#### 3. Stale Data Risk

```java
// May work with stale data
User user = userRepository.findById(1L); // Version 1
// ... long processing ...
// Another transaction updates to version 2
userRepository.save(user); // Fails - was working with stale data
```

#### 4. More Complex Error Handling

```java
// Need to handle conflicts gracefully
try {
    updateUser(user);
} catch (OptimisticLockException e) {
    // Need to inform user, refresh data, retry
    // More complex than pessimistic locking
}
```

---

## Real-World Examples

### Example 1: E-Commerce Shopping Cart

```java
@Entity
public class CartItem {
    @Id
    private Long id;
    
    @ManyToOne
    private Product product;
    
    private Integer quantity;
    
    @Version
    private Long version;
}

@Service
public class CartService {
    
    public void updateQuantity(Long cartItemId, Integer newQuantity) {
        CartItem item = cartItemRepository.findById(cartItemId)
            .orElseThrow();
        
        // Check stock availability
        if (newQuantity > item.getProduct().getStock()) {
            throw new InsufficientStockException();
        }
        
        item.setQuantity(newQuantity);
        
        try {
            cartItemRepository.save(item);
        } catch (OptimisticLockException e) {
            // Another user modified the cart
            throw new CartModifiedException(
                "Your cart was updated. Please refresh and try again.");
        }
    }
}
```

### Example 2: Bank Account Transfer

```java
@Entity
public class Account {
    @Id
    private Long id;
    
    private String accountNumber;
    private BigDecimal balance;
    
    @Version
    private Long version;
}

@Service
@Transactional
public class TransferService {
    
    public void transfer(Long fromId, Long toId, BigDecimal amount) {
        Account from = accountRepository.findById(fromId)
            .orElseThrow();
        Account to = accountRepository.findById(toId)
            .orElseThrow();
        
        // Validate
        if (from.getBalance().compareTo(amount) < 0) {
            throw new InsufficientFundsException();
        }
        
        // Transfer
        from.setBalance(from.getBalance().subtract(amount));
        to.setBalance(to.getBalance().add(amount));
        
        // Save - optimistic lock checks both accounts
        try {
            accountRepository.save(from);
            accountRepository.save(to);
        } catch (OptimisticLockException e) {
            // One of the accounts was modified
            throw new ConcurrentModificationException(
                "Account was modified. Please retry the transfer.");
        }
    }
}
```

### Example 3: Document Collaboration

```java
@Entity
public class Document {
    @Id
    private Long id;
    
    private String title;
    
    @Lob
    private String content;
    
    @Version
    private Long version;
    
    // Merge strategy for conflicts
    public void mergeContent(String newContent, Long expectedVersion) {
        if (!this.version.equals(expectedVersion)) {
            throw new OptimisticLockException(
                "Document was modified. Current version: " + this.version);
        }
        
        // Intelligent merge
        this.content = mergeStrategies.merge(this.content, newContent);
    }
}

@Service
public class DocumentService {
    
    public void updateDocument(Long docId, String newContent, Long version) {
        Document doc = documentRepository.findById(docId)
            .orElseThrow();
        
        doc.mergeContent(newContent, version);
        
        try {
            documentRepository.save(doc);
        } catch (OptimisticLockException e) {
            // Return current version to client for merge
            throw new DocumentConflictException(doc.getVersion(), doc.getContent());
        }
    }
}
```

### Example 4: Inventory Management

```java
@Entity
public class Product {
    @Id
    private Long id;
    
    private String name;
    private Integer stock;
    
    @Version
    private Long version;
    
    public void decreaseStock(int quantity) {
        if (this.stock < quantity) {
            throw new InsufficientStockException();
        }
        this.stock -= quantity;
    }
}

@Service
public class OrderService {
    
    public void processOrder(Order order) {
        for (OrderItem item : order.getItems()) {
            Product product = productRepository.findById(
                item.getProductId()).orElseThrow();
            
            product.decreaseStock(item.getQuantity());
            
            try {
                productRepository.save(product);
            } catch (OptimisticLockException e) {
                // Stock was modified by another order
                // Retry or inform user
                throw new StockConflictException(
                    "Product stock was updated. Please review your order.");
            }
        }
    }
}
```

---

## Best Practices

### 1. Always Use @Version Annotation

```java
// ✅ GOOD
@Entity
public class User {
    @Version
    private Long version;
}

// ❌ BAD - No version field
@Entity
public class User {
    // Missing @Version
}
```

### 2. Implement Retry Logic

```java
// ✅ GOOD - With retry
public void updateUser(Long id, UserUpdateRequest request) {
    int maxRetries = 3;
    for (int i = 0; i < maxRetries; i++) {
        try {
            User user = userRepository.findById(id).orElseThrow();
            // Apply changes
            userRepository.save(user);
            return;
        } catch (OptimisticLockException e) {
            if (i == maxRetries - 1) throw e;
            // Retry
        }
    }
}
```

### 3. Provide User-Friendly Error Messages

```java
// ✅ GOOD
catch (OptimisticLockException e) {
    throw new UserFriendlyException(
        "The record was modified by another user. " +
        "Please refresh and try again.");
}
```

### 4. Refresh Entity Before Retry

```java
// ✅ GOOD
public void updateUser(Long id, UserUpdateRequest request) {
    int retries = 0;
    while (retries < 3) {
        try {
            User user = userRepository.findById(id).orElseThrow();
            // Refresh to get latest version
            entityManager.refresh(user);
            
            // Apply changes
            user.setName(request.getName());
            userRepository.save(user);
            return;
        } catch (OptimisticLockException e) {
            retries++;
        }
    }
}
```

### 5. Use Appropriate Version Type

```java
// ✅ GOOD - Use Long for version
@Version
private Long version; // Recommended

// ✅ OK - Integer works too
@Version
private Integer version;

// ⚠️ CAUTION - Timestamp has issues
@Version
private Timestamp lastModified; // Clock skew issues
```

### 6. Handle Exceptions Gracefully

```java
// ✅ GOOD
@ExceptionHandler(OptimisticLockException.class)
public ResponseEntity<ErrorResponse> handleConflict(
        OptimisticLockException e) {
    return ResponseEntity.status(HttpStatus.CONFLICT)
        .body(new ErrorResponse("CONFLICT", 
            "Record was modified. Please refresh."));
}
```

### 7. Consider Read-Only Transactions

```java
// ✅ GOOD - Read-only doesn't need version check
@Transactional(readOnly = true)
public User getUser(Long id) {
    return userRepository.findById(id).orElseThrow();
    // No version check needed for reads
}
```

### 8. Use Pessimistic Locking for Critical Operations

```java
// ✅ GOOD - Use pessimistic for critical operations
@Transactional
public void transferMoney(Long fromId, Long toId, BigDecimal amount) {
    Account from = accountRepository.findById(fromId, 
        LockModeType.PESSIMISTIC_WRITE).orElseThrow();
    Account to = accountRepository.findById(toId, 
        LockModeType.PESSIMISTIC_WRITE).orElseThrow();
    
    // Critical operation - use pessimistic lock
    // to guarantee success
}
```

---

## Summary

### Key Points

1. **Optimistic Locking** assumes conflicts are rare
2. **Version field** tracks modifications
3. **Check happens at commit time**, not during read
4. **High concurrency** - multiple reads allowed
5. **May fail at commit** - requires retry logic
6. **Better performance** than pessimistic locking
7. **Ideal for** web apps with low conflict rates

### When to Use

✅ **Use Optimistic Locking when:**
- Low conflict probability
- High read-to-write ratio
- Need high concurrency
- Can handle retries
- Short transactions

❌ **Don't use Optimistic Locking when:**
- High conflict probability
- Critical operations (use pessimistic)
- Cannot handle retries
- Long-running transactions

### Implementation Checklist

- [ ] Add `@Version` field to entity
- [ ] Implement retry logic
- [ ] Handle `OptimisticLockException`
- [ ] Provide user-friendly error messages
- [ ] Consider refresh before retry
- [ ] Test concurrent scenarios
- [ ] Monitor conflict rates

---

*Optimistic locking is a powerful concurrency control mechanism that provides high performance and scalability for applications with low conflict rates. Understanding when and how to use it is crucial for building robust, concurrent applications.*

