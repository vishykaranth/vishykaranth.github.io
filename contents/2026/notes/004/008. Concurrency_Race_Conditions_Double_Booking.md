# Concurrency & Race Conditions: Preventing Double Booking

## Table of Contents
1. [Understanding the Problem](#understanding-the-problem)
2. [What is a Race Condition?](#what-is-a-race-condition)
3. [Double Booking Scenario](#double-booking-scenario)
4. [Solutions Overview](#solutions-overview)
5. [Solution 1: Pessimistic Locking](#solution-1-pessimistic-locking)
6. [Solution 2: Optimistic Locking](#solution-2-optimistic-locking)
7. [Solution 3: Distributed Locks (Redis)](#solution-3-distributed-locks-redis)
8. [Solution 4: Two-Phase Booking](#solution-4-two-phase-booking)
9. [Solution 5: Database Constraints](#solution-5-database-constraints)
10. [Solution 6: Message Queue with Single Consumer](#solution-6-message-queue-with-single-consumer)
11. [Comparison & Trade-offs](#comparison--trade-offs)
12. [Best Practices](#best-practices)
13. [Real-World Examples](#real-world-examples)

---

## Understanding the Problem

### The Double Booking Problem

In a ticket booking system, when multiple users try to book the same seat simultaneously, there's a risk that both bookings succeed, resulting in **double booking**. This is a classic concurrency problem.

### Why It Happens

```
Time    User A                    Database                    User B
─────────────────────────────────────────────────────────────────────
T1      Check if seat available   →  Seat status: available
T2                                  ←  Returns: available
T3      Book seat                 →  Update: seat = booked
T4                                  ←  Success
T5                                  ←  Seat status: available  ←  Check if seat available
T6                                  ←  Returns: available
T7                                  →  Update: seat = booked   Book seat
T8                                  ←  Success
T9      Both users think they     →  DOUBLE BOOKING! ❌
        successfully booked
```

Both users checked availability **before** either booking was committed, so both saw the seat as available.

---

## What is a Race Condition?

A **race condition** occurs when the outcome of a program depends on the relative timing of events (threads, processes, or requests). The "race" refers to multiple operations racing to access and modify the same resource.

### Characteristics

1. **Non-deterministic**: Results vary based on timing
2. **Hard to reproduce**: May work correctly most of the time
3. **Critical in concurrent systems**: Especially with shared resources
4. **Data corruption risk**: Can lead to inconsistent states

### Example: Simple Counter

```python
# Shared counter
counter = 0

# Thread 1
def increment():
    global counter
    temp = counter      # Read: counter = 0
    temp = temp + 1     # Increment: temp = 1
    counter = temp      # Write: counter = 1

# Thread 2 (runs simultaneously)
def increment():
    global counter
    temp = counter      # Read: counter = 0 (before Thread 1 writes)
    temp = temp + 1     # Increment: temp = 1
    counter = temp      # Write: counter = 1

# Expected: counter = 2
# Actual: counter = 1 (lost update!)
```

---

## Double Booking Scenario

### Scenario: Two Users Book Same Seat

```python
# Naive implementation (WRONG - has race condition)
def book_seat_naive(event_id, seat_id, user_id):
    # Step 1: Check availability
    seat = db.query("SELECT * FROM seats WHERE seat_id = ? AND status = 'available'", seat_id)
    
    if not seat:
        raise SeatUnavailableError()
    
    # Step 2: Book the seat
    db.execute("UPDATE seats SET status = 'booked', user_id = ? WHERE seat_id = ?", 
               user_id, seat_id)
    
    # Step 3: Create booking record
    db.execute("INSERT INTO bookings (user_id, seat_id) VALUES (?, ?)", 
               user_id, seat_id)
    
    return "Booking successful"
```

### What Goes Wrong

```
Time    User A (Thread 1)              Database                    User B (Thread 2)
─────────────────────────────────────────────────────────────────────────────────────
T1      SELECT * FROM seats            →  Check seat status
        WHERE seat_id = 'S1'           
        AND status = 'available'
T2                                      ←  Returns: {seat_id: 'S1', status: 'available'}
T3      Seat is available! ✅
T4                                      ←  SELECT * FROM seats  ←  Check seat status
                                           WHERE seat_id = 'S1'
                                           AND status = 'available'
T5                                      ←  Returns: {seat_id: 'S1', status: 'available'}
T6                                      Seat is available! ✅
T7      UPDATE seats SET               →  Update seat to 'booked'
        status = 'booked'...
T8                                      ←  Success
T9                                      ←  UPDATE seats SET    ←  Update seat to 'booked'
                                           status = 'booked'...
T10                                     ←  Success
T11     INSERT INTO bookings...        →  Create booking A
T12                                     ←  Success
T13                                     ←  INSERT INTO bookings...  ←  Create booking B
T14                                     ←  Success
T15     Both bookings created! ❌      →  DOUBLE BOOKING!
```

**Result**: Both users successfully booked the same seat!

---

## Solutions Overview

| Solution | Approach | Pros | Cons | Use Case |
|----------|----------|------|------|----------|
| **Pessimistic Locking** | Lock before read | Simple, guaranteed | Blocks other requests | Low concurrency needs |
| **Optimistic Locking** | Version check | High concurrency | Retry logic needed | High read/write ratio |
| **Distributed Locks** | Redis locks | Fast, scalable | Network dependency | Distributed systems |
| **Two-Phase Booking** | Lock then confirm | Best UX, flexible | More complex | Production systems |
| **Database Constraints** | Unique constraints | Database enforced | Limited flexibility | Simple cases |
| **Message Queue** | Serialize requests | Guaranteed order | Higher latency | Very high load |

---

## Solution 1: Pessimistic Locking

### Concept

**Pessimistic locking** assumes conflicts will occur, so it **locks the resource before reading** to prevent other transactions from modifying it.

### Implementation

#### Database-Level Locking (SELECT FOR UPDATE)

```python
def book_seat_pessimistic(event_id, seat_id, user_id):
    """
    Book seat using pessimistic locking
    """
    # Start transaction
    with db.transaction():
        # Lock the seat row (blocks other transactions)
        seat = db.query("""
            SELECT * FROM seats 
            WHERE seat_id = ? 
            AND event_id = ?
            FOR UPDATE  -- This locks the row!
        """, seat_id, event_id)
        
        if not seat:
            raise SeatNotFoundError()
        
        if seat.status != 'available':
            raise SeatUnavailableError(f"Seat is {seat.status}")
        
        # Now we have exclusive lock, safe to update
        db.execute("""
            UPDATE seats 
            SET status = 'booked', 
                user_id = ?,
                booked_at = NOW()
            WHERE seat_id = ?
        """, user_id, seat_id)
        
        # Create booking record
        booking_id = db.execute("""
            INSERT INTO bookings (user_id, event_id, seat_id, status)
            VALUES (?, ?, ?, 'confirmed')
            RETURNING booking_id
        """, user_id, event_id, seat_id)
        
        # Commit releases the lock
        db.commit()
        
    return booking_id
```

### How It Works

```
Time    User A                          Database                    User B
─────────────────────────────────────────────────────────────────────────────
T1      BEGIN TRANSACTION
T2      SELECT ... FOR UPDATE          →  Lock row for seat S1
T3                                      ←  Returns: {status: 'available'}
                                      [Row is LOCKED - User B must wait]
T4                                      ←  SELECT ... FOR UPDATE  ←  Try to lock
                                      [BLOCKED - waiting for User A]
T5      UPDATE seats SET...            →  Update seat
T6      INSERT INTO bookings...        →  Create booking
T7      COMMIT                         →  Release lock
T8                                      ←  Lock acquired
                                      ←  Returns: {status: 'booked'}
T9                                      ←  Seat unavailable! ✅
```

### Lock Types

#### 1. Row-Level Lock (SELECT FOR UPDATE)
```sql
-- Locks specific rows
SELECT * FROM seats 
WHERE seat_id IN ('S1', 'S2', 'S3')
FOR UPDATE;
```

#### 2. Table-Level Lock
```sql
-- Locks entire table (rarely used)
LOCK TABLE seats IN EXCLUSIVE MODE;
```

#### 3. Deadlock Prevention
```python
# Use NOWAIT to fail fast instead of waiting
seat = db.query("""
    SELECT * FROM seats 
    WHERE seat_id = ?
    FOR UPDATE NOWAIT  -- Fails immediately if locked
""", seat_id)

# Or use SKIP LOCKED to skip locked rows
available_seats = db.query("""
    SELECT * FROM seats 
    WHERE event_id = ? 
    AND status = 'available'
    FOR UPDATE SKIP LOCKED  -- Skip already locked seats
    LIMIT 5
""", event_id)
```

### Pros & Cons

**Pros:**
- ✅ Simple to implement
- ✅ Guarantees no conflicts
- ✅ Database handles locking
- ✅ Works well for low-medium concurrency

**Cons:**
- ❌ Blocks other requests (lower throughput)
- ❌ Can cause deadlocks
- ❌ Doesn't scale well for high concurrency
- ❌ Locks held for entire transaction duration

### When to Use

- Low to medium concurrency
- Critical data integrity requirements
- Short transactions
- Single database instance

---

## Solution 2: Optimistic Locking

### Concept

**Optimistic locking** assumes conflicts are rare. It doesn't lock resources but uses a **version number** or **timestamp** to detect if data changed between read and write.

### Implementation

#### Using Version Number

```sql
-- Add version column to seats table
ALTER TABLE seats ADD COLUMN version INT DEFAULT 0;
```

```python
def book_seat_optimistic(event_id, seat_id, user_id):
    """
    Book seat using optimistic locking
    """
    max_retries = 3
    retry_count = 0
    
    while retry_count < max_retries:
        try:
            # Step 1: Read current state (no lock)
            seat = db.query("""
                SELECT seat_id, status, version
                FROM seats
                WHERE seat_id = ? AND event_id = ?
            """, seat_id, event_id)
            
            if not seat:
                raise SeatNotFoundError()
            
            if seat.status != 'available':
                raise SeatUnavailableError()
            
            current_version = seat.version
            
            # Step 2: Try to update with version check
            rows_updated = db.execute("""
                UPDATE seats
                SET status = 'booked',
                    user_id = ?,
                    version = version + 1,
                    booked_at = NOW()
                WHERE seat_id = ?
                AND version = ?  -- Only update if version matches!
                AND status = 'available'
            """, user_id, seat_id, current_version)
            
            # Step 3: Check if update succeeded
            if rows_updated == 0:
                # Version changed or status changed - retry
                retry_count += 1
                if retry_count >= max_retries:
                    raise SeatUnavailableError("Seat was booked by another user")
                # Wait a bit before retry (exponential backoff)
                time.sleep(0.1 * (2 ** retry_count))
                continue
            
            # Step 4: Create booking (only if update succeeded)
            booking_id = db.execute("""
                INSERT INTO bookings (user_id, event_id, seat_id, status)
                VALUES (?, ?, ?, 'confirmed')
                RETURNING booking_id
            """, user_id, event_id, seat_id)
            
            return booking_id
            
        except Exception as e:
            if retry_count >= max_retries:
                raise
            retry_count += 1
            time.sleep(0.1 * (2 ** retry_count))
```

### How It Works

```
Time    User A                          Database                    User B
─────────────────────────────────────────────────────────────────────────────
T1      SELECT seat, version=5         →  Read seat (version=5)
T2                                      ←  Returns: {status: 'available', version: 5}
T3                                      ←  SELECT seat, version=5  ←  Read seat
T4                                      ←  Returns: {status: 'available', version: 5}
T5      UPDATE ... WHERE version=5     →  Update with version check
        AND status='available'
T6                                      ←  Success! version=6
T7                                      ←  UPDATE ... WHERE version=5  ←  Try update
                                        AND status='available'
T8                                      ←  FAILED! (version is now 6)
T9                                      ←  Retry: Read again (version=6)
T10                                     ←  Returns: {status: 'booked', version: 6}
T11                                     ←  Seat unavailable! ✅
```

### Using Timestamp Instead of Version

```sql
ALTER TABLE seats ADD COLUMN updated_at TIMESTAMP DEFAULT NOW();
```

```python
def book_seat_optimistic_timestamp(event_id, seat_id, user_id):
    seat = db.query("""
        SELECT seat_id, status, updated_at
        FROM seats
        WHERE seat_id = ? AND event_id = ?
    """, seat_id, event_id)
    
    if seat.status != 'available':
        raise SeatUnavailableError()
    
    original_timestamp = seat.updated_at
    
    # Update only if timestamp hasn't changed
    rows_updated = db.execute("""
        UPDATE seats
        SET status = 'booked',
            user_id = ?,
            updated_at = NOW()
        WHERE seat_id = ?
        AND updated_at = ?  -- Timestamp check
        AND status = 'available'
    """, user_id, seat_id, original_timestamp)
    
    if rows_updated == 0:
        raise ConcurrentModificationError("Seat was modified by another user")
```

### Pros & Cons

**Pros:**
- ✅ High concurrency (no blocking)
- ✅ Better performance under low conflict
- ✅ No deadlocks
- ✅ Works well with read-heavy workloads

**Cons:**
- ❌ Requires retry logic
- ❌ Can waste resources on retries
- ❌ Not suitable for high conflict scenarios
- ❌ More complex error handling

### When to Use

- High read/write ratio
- Low conflict probability
- Need high throughput
- Can tolerate retries

---

## Solution 3: Distributed Locks (Redis)

### Concept

Use **Redis** as a distributed lock manager. Redis provides atomic operations that work across multiple application servers.

### Implementation

#### Basic Redis Lock

```python
import redis
import time
import uuid

redis_client = redis.Redis(host='localhost', port=6379, db=0)

def acquire_lock(lock_key, timeout=10, lock_duration=15):
    """
    Acquire a distributed lock
    
    Args:
        lock_key: Unique key for the lock (e.g., "lock:event:123:seat:S1")
        timeout: How long to wait for lock (seconds)
        lock_duration: How long lock is held (seconds)
    
    Returns:
        lock_id if successful, None otherwise
    """
    lock_id = str(uuid.uuid4())
    end_time = time.time() + timeout
    
    while time.time() < end_time:
        # Try to acquire lock (SET if Not eXists)
        if redis_client.set(lock_key, lock_id, nx=True, ex=lock_duration):
            return lock_id
        
        # Wait a bit before retrying
        time.sleep(0.01)
    
    return None

def release_lock(lock_key, lock_id):
    """
    Release lock only if we own it (atomic operation)
    """
    # Lua script for atomic check-and-delete
    lua_script = """
    if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
    else
        return 0
    end
    """
    
    return redis_client.eval(lua_script, 1, lock_key, lock_id)

def book_seat_redis_lock(event_id, seat_id, user_id):
    """
    Book seat using Redis distributed lock
    """
    lock_key = f"lock:event:{event_id}:seat:{seat_id}"
    lock_id = None
    
    try:
        # Step 1: Acquire lock
        lock_id = acquire_lock(lock_key, timeout=5, lock_duration=15)
        if not lock_id:
            raise SeatUnavailableError("Could not acquire lock - seat may be locked")
        
        # Step 2: Check availability (now we have exclusive access)
        seat = db.query("""
            SELECT * FROM seats
            WHERE seat_id = ? AND event_id = ?
        """, seat_id, event_id)
        
        if not seat:
            raise SeatNotFoundError()
        
        if seat.status != 'available':
            raise SeatUnavailableError(f"Seat is {seat.status}")
        
        # Step 3: Book the seat
        db.execute("""
            UPDATE seats
            SET status = 'booked',
                user_id = ?,
                booked_at = NOW()
            WHERE seat_id = ?
        """, user_id, seat_id)
        
        # Step 4: Create booking
        booking_id = db.execute("""
            INSERT INTO bookings (user_id, event_id, seat_id, status)
            VALUES (?, ?, ?, 'confirmed')
            RETURNING booking_id
        """, user_id, event_id, seat_id)
        
        return booking_id
        
    finally:
        # Always release lock
        if lock_id:
            release_lock(lock_key, lock_id)
```

### Locking Multiple Seats

```python
def book_multiple_seats_redis(event_id, seat_ids, user_id):
    """
    Book multiple seats atomically using Redis locks
    """
    lock_keys = [f"lock:event:{event_id}:seat:{seat_id}" for seat_id in seat_ids]
    acquired_locks = []
    
    try:
        # Step 1: Try to acquire all locks
        for lock_key in lock_keys:
            lock_id = acquire_lock(lock_key, timeout=2, lock_duration=15)
            if not lock_id:
                # Release all acquired locks
                for acquired_lock_key, acquired_lock_id in acquired_locks:
                    release_lock(acquired_lock_key, acquired_lock_id)
                raise SeatUnavailableError("Could not lock all seats")
            acquired_locks.append((lock_key, lock_id))
        
        # Step 2: Check all seats are available
        seats = db.query("""
            SELECT * FROM seats
            WHERE seat_id IN ({})
            AND event_id = ?
        """.format(','.join(['?'] * len(seat_ids))), *seat_ids, event_id)
        
        unavailable = [s for s in seats if s.status != 'available']
        if unavailable:
            raise SeatUnavailableError(f"Seats {unavailable} are not available")
        
        # Step 3: Book all seats in transaction
        with db.transaction():
            for seat_id in seat_ids:
                db.execute("""
                    UPDATE seats
                    SET status = 'booked', user_id = ?
                    WHERE seat_id = ?
                """, user_id, seat_id)
            
            booking_id = db.execute("""
                INSERT INTO bookings (user_id, event_id, status)
                VALUES (?, ?, 'confirmed')
                RETURNING booking_id
            """, user_id, event_id)
            
            for seat_id in seat_ids:
                db.execute("""
                    INSERT INTO booking_seats (booking_id, seat_id)
                    VALUES (?, ?)
                """, booking_id, seat_id)
        
        return booking_id
        
    finally:
        # Release all locks
        for lock_key, lock_id in acquired_locks:
            release_lock(lock_key, lock_id)
```

### Lock Extension (For Long Operations)

```python
def extend_lock(lock_key, lock_id, additional_time=15):
    """
    Extend lock duration (e.g., during payment processing)
    """
    lua_script = """
    if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("expire", KEYS[1], ARGV[2])
    else
        return 0
    end
    """
    
    return redis_client.eval(lua_script, 1, lock_key, lock_id, additional_time)
```

### Pros & Cons

**Pros:**
- ✅ Works across multiple servers
- ✅ Fast (in-memory)
- ✅ Flexible lock duration
- ✅ Good for distributed systems

**Cons:**
- ❌ Network dependency (Redis must be available)
- ❌ Lock expiration can be tricky
- ❌ Need to handle Redis failures
- ❌ More complex than database locks

### When to Use

- Distributed system (multiple app servers)
- Need fast locking (in-memory)
- Temporary locks (e.g., seat reservations)
- High concurrency requirements

---

## Solution 4: Two-Phase Booking

### Concept

Split booking into **two phases**:
1. **Lock Phase**: Temporarily reserve seats (short duration)
2. **Confirm Phase**: Permanently book after payment

This is the **most practical solution** for production systems.

### Implementation

#### Phase 1: Lock Seats

```python
def lock_seats(event_id, seat_ids, user_id, lock_duration_minutes=15):
    """
    Phase 1: Lock seats temporarily
    """
    lock_ids = []
    booking_id = str(uuid.uuid4())
    
    try:
        # Acquire Redis locks
        for seat_id in seat_ids:
            lock_key = f"lock:event:{event_id}:seat:{seat_id}"
            lock_id = acquire_lock(lock_key, timeout=2, lock_duration=lock_duration_minutes * 60)
            
            if not lock_id:
                # Release already acquired locks
                for acquired_lock_key, acquired_lock_id in lock_ids:
                    release_lock(acquired_lock_key, acquired_lock_id)
                raise SeatUnavailableError(f"Seat {seat_id} is not available")
            
            lock_ids.append((lock_key, lock_id))
        
        # Check all seats are available
        seats = db.query("""
            SELECT seat_id, status
            FROM seats
            WHERE seat_id IN ({})
            AND event_id = ?
        """.format(','.join(['?'] * len(seat_ids))), *seat_ids, event_id)
        
        unavailable = [s.seat_id for s in seats if s.status != 'available']
        if unavailable:
            # Release locks
            for lock_key, lock_id in lock_ids:
                release_lock(lock_key, lock_id)
            raise SeatUnavailableError(f"Seats {unavailable} are not available")
        
        # Create pending booking
        with db.transaction():
            booking = db.execute("""
                INSERT INTO bookings (
                    booking_id, user_id, event_id, status,
                    expiry_time, total_amount
                )
                VALUES (?, ?, ?, 'pending', ?, ?)
                RETURNING booking_id
            """, booking_id, user_id, event_id,
                datetime.now() + timedelta(minutes=lock_duration_minutes),
                calculate_total(event_id, seat_ids))
            
            # Store seat locks in database
            for seat_id in seat_ids:
                db.execute("""
                    INSERT INTO seat_locks (
                        event_id, seat_id, user_id, booking_id, lock_expiry
                    )
                    VALUES (?, ?, ?, ?, ?)
                """, event_id, seat_id, user_id, booking_id,
                    datetime.now() + timedelta(minutes=lock_duration_minutes))
            
            # Update seat status to 'locked' (not 'booked' yet)
            db.execute("""
                UPDATE seats
                SET status = 'locked'
                WHERE seat_id IN ({})
            """.format(','.join(['?'] * len(seat_ids))), *seat_ids)
        
        return {
            'booking_id': booking_id,
            'lock_ids': [lock_id for _, lock_id in lock_ids],
            'expires_at': datetime.now() + timedelta(minutes=lock_duration_minutes)
        }
        
    except Exception as e:
        # Cleanup on error
        for lock_key, lock_id in lock_ids:
            release_lock(lock_key, lock_id)
        raise
```

#### Phase 2: Confirm Booking (After Payment)

```python
def confirm_booking(booking_id, payment_id):
    """
    Phase 2: Confirm booking after successful payment
    """
    # Get booking details
    booking = db.query("""
        SELECT * FROM bookings
        WHERE booking_id = ?
    """, booking_id)
    
    if not booking:
        raise BookingNotFoundError()
    
    if booking.status != 'pending':
        raise InvalidBookingStatusError(f"Booking is {booking.status}")
    
    if booking.expiry_time < datetime.now():
        raise BookingExpiredError()
    
    # Get locked seats
    seat_locks = db.query("""
        SELECT seat_id FROM seat_locks
        WHERE booking_id = ?
    """, booking_id)
    
    seat_ids = [sl.seat_id for sl in seat_locks]
    
    # Confirm booking in transaction
    with db.transaction():
        # Update booking status
        db.execute("""
            UPDATE bookings
            SET status = 'confirmed',
                confirmed_at = NOW(),
                payment_id = ?
            WHERE booking_id = ?
        """, payment_id, booking_id)
        
        # Update seats to 'booked'
        db.execute("""
            UPDATE seats
            SET status = 'booked',
                user_id = ?
            WHERE seat_id IN ({})
        """.format(','.join(['?'] * len(seat_ids))), booking.user_id, *seat_ids)
        
        # Release Redis locks
        for seat_id in seat_ids:
            lock_key = f"lock:event:{booking.event_id}:seat:{seat_id}"
            # Get lock_id from database or Redis
            lock_id = get_lock_id_from_db(booking_id, seat_id)
            if lock_id:
                release_lock(lock_key, lock_id)
        
        # Delete seat locks (or mark as confirmed)
        db.execute("""
            DELETE FROM seat_locks
            WHERE booking_id = ?
        """, booking_id)
    
    # Send confirmation
    send_booking_confirmation(booking.user_id, booking_id)
    
    return booking_id
```

#### Lock Expiry Cleanup Job

```python
def cleanup_expired_locks():
    """
    Background job to clean up expired locks
    Runs every minute
    """
    expired_locks = db.query("""
        SELECT lock_id, event_id, seat_id, booking_id, user_id
        FROM seat_locks
        WHERE lock_expiry < NOW()
        AND booking_id IN (
            SELECT booking_id FROM bookings WHERE status = 'pending'
        )
    """)
    
    for lock in expired_locks:
        # Release Redis lock
        lock_key = f"lock:event:{lock.event_id}:seat:{lock.seat_id}"
        lock_id = get_lock_id_from_db(lock.booking_id, lock.seat_id)
        if lock_id:
            release_lock(lock_key, lock_id)
        
        # Update seat status back to available
        db.execute("""
            UPDATE seats
            SET status = 'available'
            WHERE seat_id = ?
        """, lock.seat_id)
        
        # Mark booking as expired
        db.execute("""
            UPDATE bookings
            SET status = 'expired'
            WHERE booking_id = ?
        """, lock.booking_id)
        
        # Delete lock record
        db.execute("""
            DELETE FROM seat_locks
            WHERE lock_id = ?
        """, lock.lock_id)
        
        # Notify user
        notify_lock_expired(lock.user_id, lock.event_id)
```

### Complete Flow

```
User Flow:
1. User selects seats
   ↓
2. POST /api/v1/seats/lock
   - Locks seats for 15 minutes
   - Creates pending booking
   - Returns booking_id
   ↓
3. User proceeds to payment page
   ↓
4. User completes payment
   ↓
5. POST /api/v1/bookings/{booking_id}/confirm
   - Processes payment
   - Confirms booking
   - Releases locks
   - Sends confirmation
   ↓
6. User receives tickets

If payment fails or timeout:
- Locks expire after 15 minutes
- Seats released automatically
- Booking marked as expired
```

### Pros & Cons

**Pros:**
- ✅ Best user experience (reserve before payment)
- ✅ Prevents double booking
- ✅ Handles payment failures gracefully
- ✅ Industry standard approach
- ✅ Flexible (can extend locks)

**Cons:**
- ❌ More complex implementation
- ❌ Requires cleanup jobs
- ❌ Temporary locks consume resources
- ❌ Need to handle lock expiry

### When to Use

- **Production systems** (recommended)
- Need to handle payment processing
- Want good user experience
- Can manage lock expiry

---

## Solution 5: Database Constraints

### Concept

Use **database-level unique constraints** to prevent duplicate bookings at the database level.

### Implementation

```sql
-- Unique constraint: One booking per seat per event
CREATE UNIQUE INDEX idx_unique_booking_seat 
ON booking_seats(event_id, seat_id) 
WHERE status = 'confirmed';

-- Or use a unique constraint on bookings
CREATE UNIQUE INDEX idx_unique_seat_booking
ON bookings(event_id, seat_id)
WHERE status IN ('pending', 'confirmed');
```

```python
def book_seat_with_constraint(event_id, seat_id, user_id):
    """
    Book seat - database constraint prevents duplicates
    """
    try:
        with db.transaction():
            # Check availability (optimistic check)
            seat = db.query("""
                SELECT status FROM seats
                WHERE seat_id = ? AND event_id = ?
            """, seat_id, event_id)
            
            if seat.status != 'available':
                raise SeatUnavailableError()
            
            # Try to create booking
            # Database will reject if constraint violated
            booking_id = db.execute("""
                INSERT INTO bookings (user_id, event_id, seat_id, status)
                VALUES (?, ?, ?, 'confirmed')
                RETURNING booking_id
            """, user_id, event_id, seat_id)
            
            # Update seat status
            db.execute("""
                UPDATE seats
                SET status = 'booked', user_id = ?
                WHERE seat_id = ?
            """, user_id, seat_id)
            
            db.commit()
            return booking_id
            
    except db.IntegrityError as e:
        # Unique constraint violation
        if 'idx_unique_booking_seat' in str(e):
            raise SeatUnavailableError("Seat already booked")
        raise
```

### Pros & Cons

**Pros:**
- ✅ Database enforces constraint
- ✅ Simple implementation
- ✅ No application-level locking needed

**Cons:**
- ❌ Limited flexibility
- ❌ Error handling required
- ❌ Doesn't prevent race conditions (just detects them)
- ❌ Can cause transaction rollbacks

### When to Use

- Simple booking scenarios
- Single database instance
- Can tolerate constraint violations
- Additional safety measure (combined with other solutions)

---

## Solution 6: Message Queue with Single Consumer

### Concept

Serialize all booking requests through a **message queue** with a **single consumer** that processes bookings sequentially.

### Implementation

```python
# Producer: Add booking request to queue
def request_booking(event_id, seat_ids, user_id):
    """
    Add booking request to queue
    """
    request_id = str(uuid.uuid4())
    
    message = {
        'request_id': request_id,
        'event_id': event_id,
        'seat_ids': seat_ids,
        'user_id': user_id,
        'timestamp': datetime.now().isoformat()
    }
    
    # Send to queue (e.g., RabbitMQ, Kafka)
    queue.publish('booking_requests', json.dumps(message))
    
    return request_id

# Consumer: Process bookings sequentially
def process_booking_consumer():
    """
    Single consumer processes bookings one at a time
    """
    while True:
        message = queue.consume('booking_requests', timeout=1)
        if not message:
            continue
        
        try:
            request = json.loads(message.body)
            
            # Process booking (no concurrency issues - single consumer)
            booking_id = book_seat_safely(
                request['event_id'],
                request['seat_ids'],
                request['user_id']
            )
            
            # Send result back to user (via WebSocket, polling, etc.)
            notify_booking_result(request['user_id'], request['request_id'], booking_id)
            
            queue.ack(message)
            
        except Exception as e:
            # Handle error
            notify_booking_error(request['user_id'], request['request_id'], str(e))
            queue.nack(message)
```

### Pros & Cons

**Pros:**
- ✅ Guaranteed no race conditions
- ✅ Natural serialization
- ✅ Can handle very high load
- ✅ Easy to scale consumers if needed

**Cons:**
- ❌ Higher latency (queuing delay)
- ❌ More complex architecture
- ❌ Need async result delivery
- ❌ Queue becomes bottleneck

### When to Use

- Extremely high traffic
- Can tolerate queuing delay
- Need guaranteed ordering
- Flash sales scenarios

---

## Comparison & Trade-offs

### Performance Comparison

| Solution | Latency | Throughput | Scalability | Complexity |
|----------|---------|------------|-------------|------------|
| Pessimistic Locking | Medium | Low-Medium | Low | Low |
| Optimistic Locking | Low | High | High | Medium |
| Distributed Locks | Low | High | High | Medium |
| Two-Phase Booking | Medium | Medium-High | High | High |
| Database Constraints | Low | Medium | Medium | Low |
| Message Queue | High | Very High | Very High | High |

### Conflict Handling

| Solution | How Conflicts Handled | User Experience |
|----------|----------------------|-----------------|
| Pessimistic | Blocked until available | Wait time |
| Optimistic | Retry with new state | May need retry |
| Distributed Locks | Fail fast or wait | Immediate feedback |
| Two-Phase | Lock then confirm | Smooth flow |
| Constraints | Database rejects | Error message |
| Message Queue | Queued sequentially | Delayed response |

---

## Best Practices

### 1. Combine Multiple Solutions

```python
def book_seat_production(event_id, seat_id, user_id):
    """
    Production-ready booking with multiple safeguards
    """
    # 1. Quick availability check (cache)
    if not is_seat_available_cached(event_id, seat_id):
        raise SeatUnavailableError()
    
    # 2. Acquire distributed lock
    lock_id = acquire_lock(f"lock:event:{event_id}:seat:{seat_id}")
    if not lock_id:
        raise SeatUnavailableError()
    
    try:
        # 3. Database transaction with pessimistic lock
        with db.transaction():
            seat = db.query("""
                SELECT * FROM seats
                WHERE seat_id = ? AND event_id = ?
                FOR UPDATE
            """, seat_id, event_id)
            
            if seat.status != 'available':
                raise SeatUnavailableError()
            
            # 4. Create booking (with unique constraint)
            try:
                booking_id = db.execute("""
                    INSERT INTO bookings (user_id, event_id, seat_id, status)
                    VALUES (?, ?, ?, 'confirmed')
                    RETURNING booking_id
                """, user_id, event_id, seat_id)
            except db.IntegrityError:
                raise SeatUnavailableError()
            
            # 5. Update seat
            db.execute("""
                UPDATE seats
                SET status = 'booked', user_id = ?
                WHERE seat_id = ?
            """, user_id, seat_id)
            
            db.commit()
        
        return booking_id
        
    finally:
        release_lock(f"lock:event:{event_id}:seat:{seat_id}", lock_id)
```

### 2. Idempotency

```python
def book_seat_idempotent(event_id, seat_id, user_id, idempotency_key):
    """
    Idempotent booking - same request processed only once
    """
    # Check if already processed
    existing = db.query("""
        SELECT booking_id FROM idempotency_keys
        WHERE key = ?
    """, idempotency_key)
    
    if existing:
        return existing.booking_id
    
    # Process booking
    booking_id = book_seat(event_id, seat_id, user_id)
    
    # Store idempotency key
    db.execute("""
        INSERT INTO idempotency_keys (key, booking_id)
        VALUES (?, ?)
    """, idempotency_key, booking_id)
    
    return booking_id
```

### 3. Monitoring

```python
# Track booking attempts
def track_booking_attempt(event_id, seat_id, user_id, success, method):
    metrics.increment('booking.attempts', tags={
        'event_id': event_id,
        'success': success,
        'method': method
    })
    
    if not success:
        metrics.increment('booking.conflicts', tags={
            'event_id': event_id,
            'seat_id': seat_id
        })
```

### 4. Error Handling

```python
def book_seat_with_retry(event_id, seat_id, user_id, max_retries=3):
    """
    Book seat with automatic retry on conflicts
    """
    for attempt in range(max_retries):
        try:
            return book_seat(event_id, seat_id, user_id)
        except SeatUnavailableError as e:
            if attempt == max_retries - 1:
                raise
            # Exponential backoff
            time.sleep(0.1 * (2 ** attempt))
            continue
```

---

## Real-World Examples

### Example 1: Movie Ticket Booking (Two-Phase)

```
1. User selects seats → Lock for 5 minutes
2. User enters payment details
3. Payment processed
4. If successful → Confirm booking
5. If failed → Locks expire, seats released
```

### Example 2: Concert Tickets (Message Queue)

```
1. User clicks "Buy Now"
2. Request added to queue
3. User sees "Processing..."
4. Consumer processes sequentially
5. User receives result (success/failure)
```

### Example 3: Flight Booking (Optimistic + Constraints)

```
1. Check availability (cached)
2. User selects flight
3. Optimistic update with version
4. If conflict → Show updated availability
5. Database constraint as final safeguard
```

---

## Conclusion

Preventing double booking requires understanding:
1. **The problem**: Race conditions in concurrent systems
2. **Multiple solutions**: Each with trade-offs
3. **Combining approaches**: Defense in depth
4. **Production considerations**: Monitoring, retries, idempotency

**Recommended approach for production**: **Two-Phase Booking** with distributed locks, as it provides the best balance of user experience, reliability, and scalability.

