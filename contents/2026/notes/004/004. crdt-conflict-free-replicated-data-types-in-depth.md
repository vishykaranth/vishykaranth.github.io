# CRDT (Conflict-free Replicated Data Types): In-Depth Guide with Java Examples

## Table of Contents
1. [Introduction to CRDTs](#introduction-to-crdts)
2. [Why CRDTs?](#why-crdts)
3. [Core Properties](#core-properties)
4. [Types of CRDTs](#types-of-crdts)
5. [State-Based CRDTs (CvRDTs)](#state-based-crdts-cvrdts)
6. [Operation-Based CRDTs (CmRDTs)](#operation-based-crdts-cmrdts)
7. [Common CRDT Implementations](#common-crdt-implementations)
8. [Advanced CRDTs](#advanced-crdts)
9. [CRDTs in Distributed Systems](#crdts-in-distributed-systems)
10. [Use Cases](#use-cases)
11. [Advantages and Disadvantages](#advantages-and-disadvantages)
12. [Real-World Examples](#real-world-examples)

---

## Introduction to CRDTs

### What are CRDTs?

**CRDT (Conflict-free Replicated Data Type)** is a data structure that can be replicated across multiple computers in a network, where the replicas can be updated independently and concurrently without coordination, and it is always mathematically possible to resolve inconsistencies that might result.

### Key Concept

**"Operations are Commutative"** - The order of operations doesn't matter. Applying operations in any order produces the same result.

### Simple Example

```java
// Traditional approach - needs coordination
int counter = 0;
counter++; // Node A
counter++; // Node B
// Problem: Need to coordinate to avoid conflicts

// CRDT approach - no coordination needed
GCounter counter = new GCounter();
counter.increment("nodeA"); // Can happen independently
counter.increment("nodeB"); // Can happen independently
// Merge automatically resolves - always consistent
```

---

## Why CRDTs?

### The Distributed Systems Challenge

In distributed systems, you have:
- **Network partitions**: Nodes can't communicate
- **Concurrent updates**: Multiple nodes update simultaneously
- **Eventual consistency**: Need to converge to same state

### Traditional Solutions

```java
// ❌ PROBLEM: Requires coordination
public class TraditionalCounter {
    private int value;
    private Lock lock = new ReentrantLock();
    
    public void increment() {
        lock.lock(); // Blocks other nodes
        try {
            value++;
        } finally {
            lock.unlock();
        }
    }
}

// Issues:
// - Requires network communication for every operation
// - Blocks during network partitions
// - Single point of failure
// - High latency
```

### CRDT Solution

```java
// ✅ SOLUTION: No coordination needed
public class GCounter {
    private Map<String, Integer> counts = new HashMap<>();
    
    public void increment(String nodeId) {
        counts.merge(nodeId, 1, Integer::sum);
        // No network call needed!
        // Works offline!
    }
    
    public int getValue() {
        return counts.values().stream()
            .mapToInt(Integer::intValue)
            .sum();
    }
    
    public void merge(GCounter other) {
        // Merge is commutative and idempotent
        for (Map.Entry<String, Integer> entry : other.counts.entrySet()) {
            counts.merge(entry.getKey(), 
                entry.getValue(), 
                Integer::max);
        }
    }
}
```

**Benefits:**
- ✅ Works offline
- ✅ No coordination needed
- ✅ Automatic conflict resolution
- ✅ High availability
- ✅ Low latency

---

## Core Properties

### 1. Commutativity

Operations can be applied in any order with the same result.

```java
// Commutative: a + b = b + a
GCounter counter1 = new GCounter();
counter1.increment("A");
counter1.increment("B");

GCounter counter2 = new GCounter();
counter2.increment("B");
counter2.increment("A");

counter1.merge(counter2);
// Result is the same regardless of order
```

### 2. Associativity

Grouping of operations doesn't matter.

```java
// Associative: (a + b) + c = a + (b + c)
GCounter c1 = new GCounter();
c1.increment("A");
c1.increment("B");

GCounter c2 = new GCounter();
c2.increment("C");

GCounter c3 = new GCounter();
c3.increment("A");

// (c1 + c2) + c3 = c1 + (c2 + c3)
```

### 3. Idempotency

Applying the same operation multiple times has the same effect as applying it once.

```java
// Idempotent: merge(a, a) = a
GCounter counter = new GCounter();
counter.increment("A");

GCounter copy = new GCounter();
copy.increment("A");

counter.merge(copy); // Same as before
counter.merge(copy); // Still same (idempotent)
```

### 4. Monotonicity

State only moves forward, never backward.

```java
// Monotonic: Once a value is added, it stays (for sets)
GSet<String> set = new GSet<>();
set.add("item1");

GSet<String> other = new GSet<>();
other.add("item2");

set.merge(other);
// set now has both items
// Removing "item1" would violate monotonicity in G-Set
```

---

## Types of CRDTs

### Classification

1. **State-Based CRDTs (CvRDTs - Convergent Replicated Data Types)**
   - Replicate entire state
   - Merge function must be commutative, associative, and idempotent
   - Examples: G-Counter, G-Set, PN-Counter

2. **Operation-Based CRDTs (CmRDTs - Commutative Replicated Data Types)**
   - Replicate operations
   - Operations must be commutative
   - Examples: Counter, Set with add/remove

### Comparison

| Aspect | State-Based (CvRDT) | Operation-Based (CmRDT) |
|--------|---------------------|--------------------------|
| **What's Replicated** | Entire state | Operations |
| **Network Usage** | Higher (full state) | Lower (just operations) |
| **Complexity** | Simpler merge logic | More complex operation handling |
| **Use Case** | Small state, frequent merges | Large state, infrequent merges |

---

## State-Based CRDTs (CvRDTs)

### G-Counter (Grow-Only Counter)

A counter that can only increase. Each node maintains its own count.

```java
public class GCounter {
    private final Map<String, Integer> counts;
    private final String nodeId;
    
    public GCounter(String nodeId) {
        this.nodeId = nodeId;
        this.counts = new HashMap<>();
    }
    
    /**
     * Increment counter for this node
     */
    public void increment() {
        increment(1);
    }
    
    public void increment(int delta) {
        counts.merge(nodeId, delta, Integer::sum);
    }
    
    /**
     * Get total value across all nodes
     */
    public int getValue() {
        return counts.values().stream()
            .mapToInt(Integer::intValue)
            .sum();
    }
    
    /**
     * Merge with another GCounter
     * Takes maximum value for each node
     */
    public void merge(GCounter other) {
        for (Map.Entry<String, Integer> entry : other.counts.entrySet()) {
            String key = entry.getKey();
            Integer value = entry.getValue();
            counts.merge(key, value, Integer::max);
        }
    }
    
    /**
     * Create a copy for merging
     */
    public GCounter copy() {
        GCounter copy = new GCounter(this.nodeId);
        copy.counts.putAll(this.counts);
        return copy;
    }
    
    public Map<String, Integer> getCounts() {
        return new HashMap<>(counts);
    }
}

// Usage
GCounter counterA = new GCounter("nodeA");
counterA.increment();
counterA.increment(5);

GCounter counterB = new GCounter("nodeB");
counterB.increment(3);

// Merge
counterA.merge(counterB);
System.out.println(counterA.getValue()); // 9 (1 + 5 + 3)
```

### PN-Counter (Positive-Negative Counter)

A counter that can both increase and decrease.

```java
public class PNCounter {
    private final GCounter increments;
    private final GCounter decrements;
    
    public PNCounter(String nodeId) {
        this.increments = new GCounter(nodeId + ":inc");
        this.decrements = new GCounter(nodeId + ":dec");
    }
    
    public void increment() {
        increments.increment();
    }
    
    public void increment(int delta) {
        increments.increment(delta);
    }
    
    public void decrement() {
        decrements.increment();
    }
    
    public void decrement(int delta) {
        decrements.increment(delta);
    }
    
    public int getValue() {
        return increments.getValue() - decrements.getValue();
    }
    
    public void merge(PNCounter other) {
        increments.merge(other.increments);
        decrements.merge(other.decrements);
    }
    
    public PNCounter copy() {
        PNCounter copy = new PNCounter("temp");
        copy.increments.merge(this.increments);
        copy.decrements.merge(this.decrements);
        return copy;
    }
}

// Usage
PNCounter counterA = new PNCounter("nodeA");
counterA.increment(10);
counterA.decrement(3);

PNCounter counterB = new PNCounter("nodeB");
counterB.increment(5);
counterB.decrement(2);

counterA.merge(counterB);
System.out.println(counterA.getValue()); // 10 (10 - 3 + 5 - 2)
```

### G-Set (Grow-Only Set)

A set that can only add elements, never remove.

```java
public class GSet<T> {
    private final Set<T> elements;
    
    public GSet() {
        this.elements = new HashSet<>();
    }
    
    public void add(T element) {
        elements.add(element);
    }
    
    public boolean contains(T element) {
        return elements.contains(element);
    }
    
    public Set<T> getElements() {
        return new HashSet<>(elements);
    }
    
    public int size() {
        return elements.size();
    }
    
    /**
     * Merge: Union of both sets
     */
    public void merge(GSet<T> other) {
        elements.addAll(other.elements);
    }
    
    public GSet<T> copy() {
        GSet<T> copy = new GSet<>();
        copy.elements.addAll(this.elements);
        return copy;
    }
}

// Usage
GSet<String> setA = new GSet<>();
setA.add("apple");
setA.add("banana");

GSet<String> setB = new GSet<>();
setB.add("banana");
setB.add("cherry");

setA.merge(setB);
System.out.println(setA.getElements()); // [apple, banana, cherry]
```

### 2P-Set (Two-Phase Set)

A set that can add and remove, but once removed, an element can never be added again.

```java
public class TwoPSet<T> {
    private final GSet<T> added;
    private final GSet<T> removed;
    
    public TwoPSet() {
        this.added = new GSet<>();
        this.removed = new GSet<>();
    }
    
    public void add(T element) {
        if (!removed.contains(element)) {
            added.add(element);
        }
    }
    
    public void remove(T element) {
        if (added.contains(element)) {
            removed.add(element);
            added.getElements().remove(element); // Remove from added set
        }
    }
    
    public boolean contains(T element) {
        return added.contains(element) && !removed.contains(element);
    }
    
    public Set<T> getElements() {
        Set<T> result = new HashSet<>(added.getElements());
        result.removeAll(removed.getElements());
        return result;
    }
    
    public void merge(TwoPSet<T> other) {
        added.merge(other.added);
        removed.merge(other.removed);
    }
    
    public TwoPSet<T> copy() {
        TwoPSet<T> copy = new TwoPSet<>();
        copy.added.merge(this.added);
        copy.removed.merge(this.removed);
        return copy;
    }
}

// Usage
TwoPSet<String> setA = new TwoPSet<>();
setA.add("apple");
setA.add("banana");
setA.remove("apple");

TwoPSet<String> setB = new TwoPSet<>();
setB.add("apple"); // Won't work - already removed
setB.add("cherry");

setA.merge(setB);
System.out.println(setA.getElements()); // [banana, cherry]
// "apple" cannot be re-added
```

### OR-Set (Observed-Remove Set)

A set that allows add and remove, with proper handling of concurrent add/remove.

```java
public class ORSet<T> {
    // Map: element -> set of unique tags (adds)
    private final Map<T, Set<UUID>> elements;
    // Set of tags that have been removed
    private final Set<UUID> removed;
    
    public ORSet() {
        this.elements = new HashMap<>();
        this.removed = new HashSet<>();
    }
    
    public void add(T element) {
        UUID tag = UUID.randomUUID();
        elements.computeIfAbsent(element, k -> new HashSet<>()).add(tag);
    }
    
    public void remove(T element) {
        Set<UUID> tags = elements.get(element);
        if (tags != null) {
            removed.addAll(tags);
            elements.remove(element);
        }
    }
    
    public boolean contains(T element) {
        Set<UUID> tags = elements.get(element);
        if (tags == null) return false;
        
        // Check if any tag is not removed
        return tags.stream().anyMatch(tag -> !removed.contains(tag));
    }
    
    public Set<T> getElements() {
        Set<T> result = new HashSet<>();
        for (Map.Entry<T, Set<UUID>> entry : elements.entrySet()) {
            T element = entry.getKey();
            Set<UUID> tags = entry.getValue();
            
            // Element exists if any tag is not removed
            if (tags.stream().anyMatch(tag -> !removed.contains(tag))) {
                result.add(element);
            }
        }
        return result;
    }
    
    public void merge(ORSet<T> other) {
        // Merge elements
        for (Map.Entry<T, Set<UUID>> entry : other.elements.entrySet()) {
            T element = entry.getKey();
            Set<UUID> tags = entry.getValue();
            
            elements.merge(element, new HashSet<>(tags), (existing, incoming) -> {
                Set<UUID> merged = new HashSet<>(existing);
                merged.addAll(incoming);
                return merged;
            });
        }
        
        // Merge removed tags
        removed.addAll(other.removed);
        
        // Clean up: remove elements where all tags are removed
        elements.entrySet().removeIf(entry -> 
            entry.getValue().stream().allMatch(removed::contains));
    }
    
    public ORSet<T> copy() {
        ORSet<T> copy = new ORSet<>();
        copy.merge(this);
        return copy;
    }
}

// Usage
ORSet<String> setA = new ORSet<>();
setA.add("apple");
setA.add("banana");

ORSet<String> setB = new ORSet<>();
setB.add("apple"); // Different tag
setB.remove("banana");

setA.merge(setB);
// "apple" exists (either tag works)
// "banana" removed (all tags removed)
```

### LWW-Register (Last-Write-Wins Register)

A register that stores the value with the latest timestamp.

```java
public class LWWRegister<T> {
    private T value;
    private long timestamp;
    private String nodeId;
    
    public LWWRegister(String nodeId) {
        this.nodeId = nodeId;
        this.timestamp = 0;
        this.value = null;
    }
    
    public void set(T newValue) {
        this.value = newValue;
        this.timestamp = System.currentTimeMillis();
    }
    
    public void set(T newValue, long timestamp) {
        if (timestamp > this.timestamp) {
            this.value = newValue;
            this.timestamp = timestamp;
        } else if (timestamp == this.timestamp) {
            // Tie-breaking: use nodeId comparison
            if (nodeId.compareTo(this.nodeId) < 0) {
                this.value = newValue;
            }
        }
    }
    
    public T get() {
        return value;
    }
    
    public long getTimestamp() {
        return timestamp;
    }
    
    public void merge(LWWRegister<T> other) {
        if (other.timestamp > this.timestamp) {
            this.value = other.value;
            this.timestamp = other.timestamp;
        } else if (other.timestamp == this.timestamp) {
            // Tie-breaking
            if (other.nodeId.compareTo(this.nodeId) < 0) {
                this.value = other.value;
            }
        }
    }
    
    public LWWRegister<T> copy() {
        LWWRegister<T> copy = new LWWRegister<>(this.nodeId);
        copy.value = this.value;
        copy.timestamp = this.timestamp;
        return copy;
    }
}

// Usage
LWWRegister<String> regA = new LWWRegister<>("nodeA");
regA.set("value1");

LWWRegister<String> regB = new LWWRegister<>("nodeB");
regB.set("value2", System.currentTimeMillis() + 1000); // Later timestamp

regA.merge(regB);
System.out.println(regA.get()); // "value2" (later timestamp wins)
```

### MV-Register (Multi-Value Register)

A register that keeps all concurrent values.

```java
public class MVRegister<T> {
    private Map<String, LWWRegister<T>> versions;
    private String nodeId;
    
    public MVRegister(String nodeId) {
        this.nodeId = nodeId;
        this.versions = new HashMap<>();
    }
    
    public void set(T value) {
        // Create new version
        LWWRegister<T> newVersion = new LWWRegister<>(nodeId);
        newVersion.set(value);
        versions.put(nodeId, newVersion);
    }
    
    public Set<T> get() {
        // Return all concurrent values
        Set<T> values = new HashSet<>();
        for (LWWRegister<T> reg : versions.values()) {
            if (reg.get() != null) {
                values.add(reg.get());
            }
        }
        return values;
    }
    
    public void merge(MVRegister<T> other) {
        // Merge all versions
        for (Map.Entry<String, LWWRegister<T>> entry : other.versions.entrySet()) {
            String key = entry.getKey();
            LWWRegister<T> otherReg = entry.getValue();
            
            LWWRegister<T> thisReg = versions.get(key);
            if (thisReg == null) {
                thisReg = new LWWRegister<>(nodeId);
                versions.put(key, thisReg);
            }
            thisReg.merge(otherReg);
        }
        
        // Remove obsolete versions (all values that are dominated)
        // Simplified: keep all non-dominated versions
    }
}

// Usage
MVRegister<String> regA = new MVRegister<>("nodeA");
regA.set("value1");

MVRegister<String> regB = new MVRegister<>("nodeB");
regB.set("value2"); // Concurrent write

regA.merge(regB);
System.out.println(regA.get()); // [value1, value2] - both kept
```

---

## Operation-Based CRDTs (CmRDTs)

### Operation-Based Counter

```java
public class OpBasedCounter {
    private int value;
    private String nodeId;
    private List<Operation> pendingOps;
    
    public OpBasedCounter(String nodeId) {
        this.nodeId = nodeId;
        this.value = 0;
        this.pendingOps = new ArrayList<>();
    }
    
    public void increment() {
        Operation op = new IncrementOperation(nodeId);
        applyOperation(op);
        pendingOps.add(op);
    }
    
    public void decrement() {
        Operation op = new DecrementOperation(nodeId);
        applyOperation(op);
        pendingOps.add(op);
    }
    
    private void applyOperation(Operation op) {
        if (op instanceof IncrementOperation) {
            value++;
        } else if (op instanceof DecrementOperation) {
            value--;
        }
    }
    
    public List<Operation> getPendingOperations() {
        return new ArrayList<>(pendingOps);
    }
    
    public void applyOperations(List<Operation> operations) {
        for (Operation op : operations) {
            applyOperation(op);
        }
    }
    
    public int getValue() {
        return value;
    }
    
    // Operation interface
    public interface Operation {
        String getNodeId();
    }
    
    public static class IncrementOperation implements Operation {
        private String nodeId;
        
        public IncrementOperation(String nodeId) {
            this.nodeId = nodeId;
        }
        
        @Override
        public String getNodeId() {
            return nodeId;
        }
    }
    
    public static class DecrementOperation implements Operation {
        private String nodeId;
        
        public DecrementOperation(String nodeId) {
            this.nodeId = nodeId;
        }
        
        @Override
        public String getNodeId() {
            return nodeId;
        }
    }
}
```

---

## Common CRDT Implementations

### CRDT Map (Key-Value Store)

```java
public class CRDTMap<K, V> {
    private final Map<K, LWWRegister<V>> map;
    private final String nodeId;
    
    public CRDTMap(String nodeId) {
        this.nodeId = nodeId;
        this.map = new HashMap<>();
    }
    
    public void put(K key, V value) {
        LWWRegister<V> reg = map.computeIfAbsent(
            key, k -> new LWWRegister<>(nodeId));
        reg.set(value);
    }
    
    public V get(K key) {
        LWWRegister<V> reg = map.get(key);
        return reg != null ? reg.get() : null;
    }
    
    public void remove(K key) {
        // In LWW-register, set to null or use tombstone
        LWWRegister<V> reg = map.get(key);
        if (reg != null) {
            reg.set(null); // Mark as deleted
        }
    }
    
    public Set<K> keySet() {
        return map.entrySet().stream()
            .filter(entry -> entry.getValue().get() != null)
            .map(Map.Entry::getKey)
            .collect(Collectors.toSet());
    }
    
    public void merge(CRDTMap<K, V> other) {
        for (Map.Entry<K, LWWRegister<V>> entry : other.map.entrySet()) {
            K key = entry.getKey();
            LWWRegister<V> otherReg = entry.getValue();
            
            LWWRegister<V> thisReg = map.get(key);
            if (thisReg == null) {
                thisReg = new LWWRegister<>(nodeId);
                map.put(key, thisReg);
            }
            thisReg.merge(otherReg);
        }
    }
}

// Usage
CRDTMap<String, String> mapA = new CRDTMap<>("nodeA");
mapA.put("key1", "value1");

CRDTMap<String, String> mapB = new CRDTMap<>("nodeB");
mapB.put("key1", "value2"); // Concurrent update

mapA.merge(mapB);
System.out.println(mapA.get("key1")); // "value2" (LWW)
```

### CRDT List (Sequence)

```java
public class CRDTList<T> {
    // Each element has a unique identifier and position
    private final List<Element<T>> elements;
    private final String nodeId;
    
    private static class Element<T> {
        final UUID id;
        final T value;
        final double position; // Fractional position for ordering
        
        Element(UUID id, T value, double position) {
            this.id = id;
            this.value = value;
            this.position = position;
        }
    }
    
    public CRDTList(String nodeId) {
        this.nodeId = nodeId;
        this.elements = new ArrayList<>();
    }
    
    public void insert(int index, T value) {
        double position;
        if (elements.isEmpty()) {
            position = 0.5;
        } else if (index == 0) {
            position = elements.get(0).position / 2.0;
        } else if (index >= elements.size()) {
            position = elements.get(elements.size() - 1).position + 1.0;
        } else {
            double prevPos = elements.get(index - 1).position;
            double nextPos = elements.get(index).position;
            position = (prevPos + nextPos) / 2.0;
        }
        
        elements.add(new Element<>(UUID.randomUUID(), value, position));
        elements.sort(Comparator.comparingDouble(e -> e.position));
    }
    
    public void remove(int index) {
        if (index >= 0 && index < elements.size()) {
            elements.remove(index);
        }
    }
    
    public List<T> toList() {
        return elements.stream()
            .map(e -> e.value)
            .collect(Collectors.toList());
    }
    
    public void merge(CRDTList<T> other) {
        // Merge elements, keeping all and sorting by position
        Map<UUID, Element<T>> merged = new HashMap<>();
        
        for (Element<T> elem : this.elements) {
            merged.put(elem.id, elem);
        }
        
        for (Element<T> elem : other.elements) {
            merged.merge(elem.id, elem, (existing, incoming) -> {
                // If same ID, keep the one with later timestamp or tie-break
                return existing; // Simplified
            });
        }
        
        this.elements.clear();
        this.elements.addAll(merged.values());
        this.elements.sort(Comparator.comparingDouble(e -> e.position));
    }
}

// Usage
CRDTList<String> listA = new CRDTList<>("nodeA");
listA.insert(0, "apple");
listA.insert(1, "banana");

CRDTList<String> listB = new CRDTList<>("nodeB");
listB.insert(0, "cherry");

listA.merge(listB);
System.out.println(listA.toList()); // Merged list
```

---

## Advanced CRDTs

### CRDT for Collaborative Text Editing

```java
public class CRDTText {
    // Each character has a unique ID and position
    private final List<TextChar> characters;
    private final String nodeId;
    
    private static class TextChar {
        final UUID id;
        final char value;
        final List<UUID> position; // Fractional indexing
        
        TextChar(UUID id, char value, List<UUID> position) {
            this.id = id;
            this.value = value;
            this.position = new ArrayList<>(position);
        }
    }
    
    public CRDTText(String nodeId) {
        this.nodeId = nodeId;
        this.characters = new ArrayList<>();
    }
    
    public void insert(int index, char c) {
        List<UUID> position;
        if (characters.isEmpty()) {
            position = Arrays.asList(UUID.randomUUID());
        } else if (index == 0) {
            position = generatePositionBefore(characters.get(0).position);
        } else if (index >= characters.size()) {
            position = generatePositionAfter(
                characters.get(characters.size() - 1).position);
        } else {
            position = generatePositionBetween(
                characters.get(index - 1).position,
                characters.get(index).position);
        }
        
        characters.add(new TextChar(UUID.randomUUID(), c, position));
        characters.sort(Comparator.comparing(c -> c.position));
    }
    
    private List<UUID> generatePositionBetween(
            List<UUID> before, List<UUID> after) {
        // Generate position between two positions
        // Using fractional indexing
        List<UUID> result = new ArrayList<>();
        int minLen = Math.min(before.size(), after.size());
        
        for (int i = 0; i < minLen; i++) {
            if (before.get(i).equals(after.get(i))) {
                result.add(before.get(i));
            } else {
                // Generate UUID between
                result.add(generateUUIDBetween(before.get(i), after.get(i)));
                break;
            }
        }
        
        return result;
    }
    
    private UUID generateUUIDBetween(UUID a, UUID b) {
        // Simplified: generate random UUID
        // Real implementation uses fractional indexing
        return UUID.randomUUID();
    }
    
    private List<UUID> generatePositionBefore(List<UUID> pos) {
        List<UUID> result = new ArrayList<>(pos);
        result.add(UUID.randomUUID());
        return result;
    }
    
    private List<UUID> generatePositionAfter(List<UUID> pos) {
        List<UUID> result = new ArrayList<>(pos);
        result.add(UUID.randomUUID());
        return result;
    }
    
    public void delete(int index) {
        if (index >= 0 && index < characters.size()) {
            characters.remove(index);
        }
    }
    
    public String getText() {
        return characters.stream()
            .map(c -> String.valueOf(c.value))
            .collect(Collectors.joining());
    }
    
    public void merge(CRDTText other) {
        Map<UUID, TextChar> merged = new HashMap<>();
        
        for (TextChar ch : this.characters) {
            merged.put(ch.id, ch);
        }
        
        for (TextChar ch : other.characters) {
            merged.put(ch.id, ch);
        }
        
        this.characters.clear();
        this.characters.addAll(merged.values());
        this.characters.sort(Comparator.comparing(c -> c.position));
    }
}

// Usage
CRDTText textA = new CRDTText("nodeA");
textA.insert(0, 'H');
textA.insert(1, 'i');

CRDTText textB = new CRDTText("nodeB");
textB.insert(0, 'B');
textB.insert(1, 'y');

textA.merge(textB);
System.out.println(textA.getText()); // Merged text
```

---

## CRDTs in Distributed Systems

### Distributed CRDT Service

```java
@Service
public class DistributedCRDTService {
    
    private final Map<String, GCounter> counters = new ConcurrentHashMap<>();
    private final Map<String, Set<String>> replicas = new ConcurrentHashMap<>();
    private final String nodeId;
    
    public DistributedCRDTService(String nodeId) {
        this.nodeId = nodeId;
    }
    
    /**
     * Increment counter (local operation)
     */
    public void increment(String counterId) {
        GCounter counter = counters.computeIfAbsent(
            counterId, k -> new GCounter(nodeId));
        counter.increment();
    }
    
    /**
     * Get local value
     */
    public int getValue(String counterId) {
        GCounter counter = counters.get(counterId);
        return counter != null ? counter.getValue() : 0;
    }
    
    /**
     * Receive state from another replica
     */
    public void receiveState(String counterId, GCounter remoteCounter) {
        GCounter localCounter = counters.computeIfAbsent(
            counterId, k -> new GCounter(nodeId));
        localCounter.merge(remoteCounter);
    }
    
    /**
     * Send state to other replicas
     */
    public void syncWithReplicas(String counterId) {
        GCounter counter = counters.get(counterId);
        if (counter == null) return;
        
        Set<String> replicas = this.replicas.get(counterId);
        if (replicas == null) return;
        
        for (String replicaId : replicas) {
            if (!replicaId.equals(nodeId)) {
                sendStateToReplica(replicaId, counterId, counter);
            }
        }
    }
    
    private void sendStateToReplica(
            String replicaId, String counterId, GCounter counter) {
        // Send via network (simplified)
        // In real implementation: HTTP, gRPC, message queue, etc.
    }
    
    /**
     * Periodic sync (eventual consistency)
     */
    @Scheduled(fixedRate = 5000) // Every 5 seconds
    public void periodicSync() {
        for (String counterId : counters.keySet()) {
            syncWithReplicas(counterId);
        }
    }
}
```

### CRDT with Event Sourcing

```java
public class CRDTEventStore {
    private final List<CRDTEvent> events = new ArrayList<>();
    private final Map<String, GCounter> state = new HashMap<>();
    
    public void applyEvent(CRDTEvent event) {
        events.add(event);
        
        String counterId = event.getCounterId();
        GCounter counter = state.computeIfAbsent(
            counterId, k -> new GCounter(event.getNodeId()));
        
        if (event instanceof IncrementEvent) {
            counter.increment();
        } else if (event instanceof MergeEvent) {
            MergeEvent mergeEvent = (MergeEvent) event;
            counter.merge(mergeEvent.getCounter());
        }
    }
    
    public GCounter getState(String counterId) {
        return state.get(counterId);
    }
    
    public void replayEvents() {
        // Rebuild state from events
        state.clear();
        for (CRDTEvent event : events) {
            applyEvent(event);
        }
    }
    
    // Event classes
    public static abstract class CRDTEvent {
        protected String counterId;
        protected String nodeId;
        protected long timestamp;
        
        // Getters and setters
    }
    
    public static class IncrementEvent extends CRDTEvent {
        // Increment event
    }
    
    public static class MergeEvent extends CRDTEvent {
        private GCounter counter;
        // Merge event
    }
}
```

---

## Use Cases

### 1. Distributed Counters

```java
// Use case: Like counts, view counts
public class LikeCounter {
    private final GCounter counter;
    
    public LikeCounter(String nodeId) {
        this.counter = new GCounter(nodeId);
    }
    
    public void like() {
        counter.increment();
    }
    
    public int getLikeCount() {
        return counter.getValue();
    }
    
    public void merge(LikeCounter other) {
        counter.merge(other.counter);
    }
}
```

### 2. Distributed Sets

```java
// Use case: User tags, categories
public class TagSet {
    private final ORSet<String> tags;
    
    public TagSet() {
        this.tags = new ORSet<>();
    }
    
    public void addTag(String tag) {
        tags.add(tag);
    }
    
    public void removeTag(String tag) {
        tags.remove(tag);
    }
    
    public Set<String> getTags() {
        return tags.getElements();
    }
    
    public void merge(TagSet other) {
        tags.merge(other.tags);
    }
}
```

### 3. Collaborative Editing

```java
// Use case: Google Docs-like editor
public class CollaborativeEditor {
    private final CRDTText document;
    private final String userId;
    
    public CollaborativeEditor(String userId) {
        this.userId = userId;
        this.document = new CRDTText(userId);
    }
    
    public void insertText(int position, String text) {
        for (int i = 0; i < text.length(); i++) {
            document.insert(position + i, text.charAt(i));
        }
    }
    
    public void deleteText(int start, int length) {
        for (int i = 0; i < length; i++) {
            document.delete(start);
        }
    }
    
    public String getText() {
        return document.getText();
    }
    
    public void merge(CollaborativeEditor other) {
        document.merge(other.document);
    }
}
```

### 4. Shopping Cart

```java
// Use case: Distributed shopping cart
public class ShoppingCart {
    private final CRDTMap<String, Integer> items; // itemId -> quantity
    
    public ShoppingCart(String userId) {
        this.items = new CRDTMap<>(userId);
    }
    
    public void addItem(String itemId, int quantity) {
        Integer current = items.get(itemId);
        items.put(itemId, (current != null ? current : 0) + quantity);
    }
    
    public void removeItem(String itemId) {
        items.remove(itemId);
    }
    
    public Map<String, Integer> getItems() {
        Map<String, Integer> result = new HashMap<>();
        for (String itemId : items.keySet()) {
            Integer qty = items.get(itemId);
            if (qty != null && qty > 0) {
                result.put(itemId, qty);
            }
        }
        return result;
    }
    
    public void merge(ShoppingCart other) {
        items.merge(other.items);
    }
}
```

---

## Advantages and Disadvantages

### Advantages

1. **No Coordination Needed**
   ```java
   // Works offline, no network required for operations
   counter.increment(); // Works even offline
   ```

2. **High Availability**
   ```java
   // System remains available during network partitions
   // Operations continue locally
   ```

3. **Low Latency**
   ```java
   // No waiting for network round-trips
   // Immediate local updates
   ```

4. **Automatic Conflict Resolution**
   ```java
   // Merges automatically resolve conflicts
   counterA.merge(counterB); // Always consistent
   ```

5. **Eventual Consistency**
   ```java
   // All replicas converge to same state
   // Guaranteed by mathematical properties
   ```

### Disadvantages

1. **Memory Overhead**
   ```java
   // OR-Set stores tags for each element
   // Can grow large with many operations
   ```

2. **Merge Complexity**
   ```java
   // Some CRDTs have complex merge logic
   // CRDT lists require fractional indexing
   ```

3. **Eventual Consistency**
   ```java
   // Not immediately consistent
   // Users may see temporary inconsistencies
   ```

4. **Limited Operations**
   ```java
   // Some operations not possible
   // E.g., can't have "remove all" in G-Set
   ```

5. **Network Overhead**
   ```java
   // State-based CRDTs send full state
   // Can be large for complex structures
   ```

---

## Real-World Examples

### Example 1: Distributed Like Counter

```java
@Service
public class LikeService {
    private final Map<String, GCounter> postLikes = new ConcurrentHashMap<>();
    private final String nodeId;
    
    public LikeService(String nodeId) {
        this.nodeId = nodeId;
    }
    
    public void likePost(String postId) {
        GCounter counter = postLikes.computeIfAbsent(
            postId, k -> new GCounter(nodeId));
        counter.increment();
        
        // Async sync with other nodes
        syncWithReplicas(postId);
    }
    
    public int getLikeCount(String postId) {
        GCounter counter = postLikes.get(postId);
        return counter != null ? counter.getValue() : 0;
    }
    
    public void receiveLikeState(String postId, GCounter remoteCounter) {
        GCounter localCounter = postLikes.computeIfAbsent(
            postId, k -> new GCounter(nodeId));
        localCounter.merge(remoteCounter);
    }
    
    private void syncWithReplicas(String postId) {
        // Send to other nodes via message queue
    }
}
```

### Example 2: Collaborative Whiteboard

```java
public class CollaborativeWhiteboard {
    private final ORSet<Shape> shapes;
    
    public CollaborativeWhiteboard() {
        this.shapes = new ORSet<>();
    }
    
    public void addShape(Shape shape) {
        shapes.add(shape);
    }
    
    public void removeShape(Shape shape) {
        shapes.remove(shape);
    }
    
    public Set<Shape> getShapes() {
        return shapes.getElements();
    }
    
    public void merge(CollaborativeWhiteboard other) {
        shapes.merge(other.shapes);
    }
    
    // Shape must implement equals and hashCode
    public static class Shape {
        private String id;
        private String type;
        private Map<String, Object> properties;
        
        // Getters, setters, equals, hashCode
    }
}
```

### Example 3: Distributed Configuration

```java
public class DistributedConfig {
    private final CRDTMap<String, String> config;
    
    public DistributedConfig(String nodeId) {
        this.config = new CRDTMap<>(nodeId);
    }
    
    public void setConfig(String key, String value) {
        config.put(key, value);
    }
    
    public String getConfig(String key) {
        return config.get(key);
    }
    
    public void merge(DistributedConfig other) {
        config.merge(other.config);
    }
    
    public Map<String, String> getAllConfig() {
        Map<String, String> result = new HashMap<>();
        for (String key : config.keySet()) {
            String value = config.get(key);
            if (value != null) {
                result.put(key, value);
            }
        }
        return result;
    }
}
```

---

## Summary

### Key Takeaways

1. **CRDTs** provide conflict-free replication without coordination
2. **State-Based (CvRDT)**: Merge entire state
3. **Operation-Based (CmRDT)**: Replicate operations
4. **Properties**: Commutative, Associative, Idempotent, Monotonic
5. **Use Cases**: Counters, Sets, Maps, Lists, Text editing
6. **Benefits**: High availability, low latency, automatic conflict resolution
7. **Trade-offs**: Memory overhead, eventual consistency, network usage

### When to Use CRDTs

✅ **Use CRDTs when:**
- Need high availability
- Can tolerate eventual consistency
- Operations are commutative
- Offline support needed
- Low latency required

❌ **Don't use CRDTs when:**
- Need strong consistency
- Operations are not commutative
- Memory is very constrained
- Need immediate consistency

### Common CRDT Types

| CRDT Type | Use Case | Operations |
|-----------|----------|------------|
| **G-Counter** | Like counts, metrics | Increment only |
| **PN-Counter** | Votes, scores | Increment, Decrement |
| **G-Set** | Tags, categories | Add only |
| **OR-Set** | User lists, items | Add, Remove |
| **LWW-Register** | Last value wins | Set value |
| **MV-Register** | Keep all values | Set value |
| **CRDT Map** | Key-value store | Put, Get, Remove |
| **CRDT List** | Ordered sequences | Insert, Delete |

---

*CRDTs are powerful data structures for building highly available, distributed systems. Understanding their properties and trade-offs is essential for designing robust distributed applications.*

