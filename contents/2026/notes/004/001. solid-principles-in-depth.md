# SOLID Principles: In-Depth Explanation with Java Examples

## Table of Contents
1. [Introduction](#introduction)
2. [Single Responsibility Principle (SRP)](#single-responsibility-principle-srp)
3. [Open/Closed Principle (OCP)](#openclosed-principle-ocp)
4. [Liskov Substitution Principle (LSP)](#liskov-substitution-principle-lsp)
5. [Interface Segregation Principle (ISP)](#interface-segregation-principle-isp)
6. [Dependency Inversion Principle (DIP)](#dependency-inversion-principle-dip)
7. [SOLID Principles Together](#solid-principles-together)
8. [Common Violations and How to Fix Them](#common-violations-and-how-to-fix-them)
9. [Best Practices](#best-practices)

---

## Introduction

SOLID is an acronym for five object-oriented design principles introduced by Robert C. Martin (Uncle Bob). These principles help create maintainable, scalable, and robust software systems.

### Why SOLID Matters

- **Maintainability**: Code is easier to understand and modify
- **Scalability**: System can grow without major refactoring
- **Testability**: Components can be tested in isolation
- **Flexibility**: Changes in one area don't break others
- **Reusability**: Components can be reused across different contexts

---

## Single Responsibility Principle (SRP)

### Definition

**"A class should have only one reason to change."**

Every class should have a single, well-defined responsibility. If a class has multiple responsibilities, it becomes harder to maintain, test, and understand.

### Key Concepts

- **One Reason to Change**: A class should have only one job or responsibility
- **Cohesion**: All methods and properties should be related to the class's single responsibility
- **Separation of Concerns**: Different responsibilities should be in different classes

### Example: Violation of SRP

```java
// ❌ BAD: This class has multiple responsibilities
public class User {
    private String name;
    private String email;
    
    // Responsibility 1: User data management
    public void setName(String name) {
        this.name = name;
    }
    
    public String getName() {
        return name;
    }
    
    // Responsibility 2: Database operations
    public void saveToDatabase() {
        // Database save logic
        System.out.println("Saving user to database...");
    }
    
    public void loadFromDatabase(String userId) {
        // Database load logic
        System.out.println("Loading user from database...");
    }
    
    // Responsibility 3: Email operations
    public void sendEmail(String subject, String body) {
        // Email sending logic
        System.out.println("Sending email to " + email);
    }
    
    // Responsibility 4: Validation
    public boolean validateEmail() {
        return email.contains("@");
    }
}
```

**Problems:**
- If database schema changes, User class needs modification
- If email service changes, User class needs modification
- If validation rules change, User class needs modification
- Hard to test each responsibility in isolation
- Violates SRP - multiple reasons to change

### Example: Following SRP

```java
// ✅ GOOD: User class only manages user data
public class User {
    private String name;
    private String email;
    
    public User(String name, String email) {
        this.name = name;
        this.email = email;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getEmail() {
        return email;
    }
    
    public void setEmail(String email) {
        this.email = email;
    }
}

// ✅ GOOD: Separate class for database operations
public class UserRepository {
    public void save(User user) {
        // Database save logic
        System.out.println("Saving user to database: " + user.getName());
    }
    
    public User findById(String userId) {
        // Database load logic
        System.out.println("Loading user from database: " + userId);
        return new User("John", "john@example.com");
    }
}

// ✅ GOOD: Separate class for email operations
public class EmailService {
    public void sendEmail(User user, String subject, String body) {
        // Email sending logic
        System.out.println("Sending email to " + user.getEmail());
    }
}

// ✅ GOOD: Separate class for validation
public class UserValidator {
    public boolean isValidEmail(String email) {
        return email != null && email.contains("@") && email.contains(".");
    }
    
    public boolean isValidName(String name) {
        return name != null && !name.trim().isEmpty();
    }
}
```

**Benefits:**
- Each class has a single, clear responsibility
- Changes to database logic don't affect User class
- Changes to email logic don't affect User class
- Each class can be tested independently
- Code is more maintainable and understandable

### Real-World Example: Order Processing

```java
// ❌ BAD: Single class handling multiple responsibilities
public class Order {
    private String orderId;
    private double total;
    private List<Item> items;
    
    public void calculateTotal() { /* ... */ }
    public void saveToDatabase() { /* ... */ }
    public void sendConfirmationEmail() { /* ... */ }
    public void generateInvoice() { /* ... */ }
    public void processPayment() { /* ... */ }
}

// ✅ GOOD: Separated responsibilities
public class Order {
    private String orderId;
    private double total;
    private List<Item> items;
    
    // Only order data and basic calculations
    public double calculateTotal() {
        return items.stream()
            .mapToDouble(Item::getPrice)
            .sum();
    }
}

public class OrderRepository {
    public void save(Order order) { /* Database operations */ }
    public Order findById(String orderId) { /* Database operations */ }
}

public class EmailService {
    public void sendOrderConfirmation(Order order) { /* Email logic */ }
}

public class InvoiceGenerator {
    public Invoice generate(Order order) { /* Invoice generation */ }
}

public class PaymentProcessor {
    public PaymentResult process(Order order, PaymentMethod method) { /* Payment logic */ }
}
```

### When to Apply SRP

- **Apply when:**
  - A class is doing too many things
  - Changes in one area require modifying unrelated code
  - Testing becomes difficult
  - Code is hard to understand

- **Don't over-apply:**
  - Don't create classes for every single method
  - Related operations can stay together
  - Balance between granularity and practicality

---

## Open/Closed Principle (OCP)

### Definition

**"Software entities should be open for extension but closed for modification."**

You should be able to add new functionality without modifying existing code. This is achieved through abstraction, interfaces, and polymorphism.

### Key Concepts

- **Open for Extension**: New behavior can be added
- **Closed for Modification**: Existing code doesn't need to change
- **Abstraction**: Use interfaces/abstract classes to define contracts
- **Polymorphism**: Different implementations can be swapped

### Example: Violation of OCP

```java
// ❌ BAD: Adding new shapes requires modifying existing code
public class AreaCalculator {
    public double calculateArea(Object shape) {
        if (shape instanceof Rectangle) {
            Rectangle rect = (Rectangle) shape;
            return rect.getWidth() * rect.getHeight();
        } else if (shape instanceof Circle) {
            Circle circle = (Circle) shape;
            return Math.PI * circle.getRadius() * circle.getRadius();
        } else if (shape instanceof Triangle) {
            Triangle triangle = (Triangle) shape;
            return 0.5 * triangle.getBase() * triangle.getHeight();
        }
        // Adding a new shape requires modifying this method
        throw new IllegalArgumentException("Unknown shape");
    }
}
```

**Problems:**
- Must modify existing code to add new shapes
- Violates OCP - not closed for modification
- Risk of breaking existing functionality
- Hard to test with new shapes

### Example: Following OCP

```java
// ✅ GOOD: Shape interface - open for extension
public interface Shape {
    double calculateArea();
}

// ✅ GOOD: Rectangle implementation
public class Rectangle implements Shape {
    private double width;
    private double height;
    
    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }
    
    @Override
    public double calculateArea() {
        return width * height;
    }
}

// ✅ GOOD: Circle implementation
public class Circle implements Shape {
    private double radius;
    
    public Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
}

// ✅ GOOD: Triangle implementation
public class Triangle implements Shape {
    private double base;
    private double height;
    
    public Triangle(double base, double height) {
        this.base = base;
        this.height = height;
    }
    
    @Override
    public double calculateArea() {
        return 0.5 * base * height;
    }
}

// ✅ GOOD: Calculator is closed for modification, open for extension
public class AreaCalculator {
    public double calculateArea(Shape shape) {
        return shape.calculateArea(); // Works with any Shape implementation
    }
    
    public double calculateTotalArea(List<Shape> shapes) {
        return shapes.stream()
            .mapToDouble(Shape::calculateArea)
            .sum();
    }
}

// ✅ GOOD: New shape can be added without modifying existing code
public class Pentagon implements Shape {
    private double side;
    
    public Pentagon(double side) {
        this.side = side;
    }
    
    @Override
    public double calculateArea() {
        // Pentagon area calculation
        return (5.0 / 4.0) * side * side * (1.0 / Math.tan(Math.PI / 5.0));
    }
}
```

**Benefits:**
- New shapes can be added without modifying AreaCalculator
- Existing code remains unchanged
- No risk of breaking existing functionality
- Easy to test and extend

### Real-World Example: Payment Processing

```java
// ❌ BAD: Adding new payment methods requires modifying existing code
public class PaymentProcessor {
    public void processPayment(String paymentType, double amount) {
        if ("credit_card".equals(paymentType)) {
            // Credit card processing
            System.out.println("Processing credit card payment: " + amount);
        } else if ("paypal".equals(paymentType)) {
            // PayPal processing
            System.out.println("Processing PayPal payment: " + amount);
        } else if ("bank_transfer".equals(paymentType)) {
            // Bank transfer processing
            System.out.println("Processing bank transfer: " + amount);
        }
        // Adding new payment method requires modifying this method
    }
}

// ✅ GOOD: Payment interface - open for extension
public interface PaymentMethod {
    void processPayment(double amount);
    boolean validatePayment();
}

// ✅ GOOD: Credit card implementation
public class CreditCardPayment implements PaymentMethod {
    private String cardNumber;
    private String cvv;
    
    @Override
    public void processPayment(double amount) {
        System.out.println("Processing credit card payment: " + amount);
        // Credit card specific logic
    }
    
    @Override
    public boolean validatePayment() {
        return cardNumber != null && cvv != null;
    }
}

// ✅ GOOD: PayPal implementation
public class PayPalPayment implements PaymentMethod {
    private String email;
    
    @Override
    public void processPayment(double amount) {
        System.out.println("Processing PayPal payment: " + amount);
        // PayPal specific logic
    }
    
    @Override
    public boolean validatePayment() {
        return email != null && email.contains("@");
    }
}

// ✅ GOOD: Bank transfer implementation
public class BankTransferPayment implements PaymentMethod {
    private String accountNumber;
    
    @Override
    public void processPayment(double amount) {
        System.out.println("Processing bank transfer: " + amount);
        // Bank transfer specific logic
    }
    
    @Override
    public boolean validatePayment() {
        return accountNumber != null && accountNumber.length() > 8;
    }
}

// ✅ GOOD: Payment processor is closed for modification
public class PaymentProcessor {
    public void processPayment(PaymentMethod paymentMethod, double amount) {
        if (paymentMethod.validatePayment()) {
            paymentMethod.processPayment(amount);
        } else {
            throw new IllegalArgumentException("Invalid payment method");
        }
    }
}

// ✅ GOOD: New payment method can be added without modifying existing code
public class CryptocurrencyPayment implements PaymentMethod {
    private String walletAddress;
    
    @Override
    public void processPayment(double amount) {
        System.out.println("Processing cryptocurrency payment: " + amount);
        // Cryptocurrency specific logic
    }
    
    @Override
    public boolean validatePayment() {
        return walletAddress != null && walletAddress.startsWith("0x");
    }
}
```

### Strategy Pattern and OCP

The Strategy Pattern is a common way to implement OCP:

```java
// Strategy interface
public interface DiscountStrategy {
    double applyDiscount(double price);
}

// Concrete strategies
public class NoDiscount implements DiscountStrategy {
    @Override
    public double applyDiscount(double price) {
        return price;
    }
}

public class PercentageDiscount implements DiscountStrategy {
    private double percentage;
    
    public PercentageDiscount(double percentage) {
        this.percentage = percentage;
    }
    
    @Override
    public double applyDiscount(double price) {
        return price * (1 - percentage / 100);
    }
}

public class FixedAmountDiscount implements DiscountStrategy {
    private double amount;
    
    public FixedAmountDiscount(double amount) {
        this.amount = amount;
    }
    
    @Override
    public double applyDiscount(double price) {
        return Math.max(0, price - amount);
    }
}

// Context class - closed for modification
public class PriceCalculator {
    private DiscountStrategy discountStrategy;
    
    public PriceCalculator(DiscountStrategy discountStrategy) {
        this.discountStrategy = discountStrategy;
    }
    
    public double calculateFinalPrice(double originalPrice) {
        return discountStrategy.applyDiscount(originalPrice);
    }
    
    // Can change strategy at runtime
    public void setDiscountStrategy(DiscountStrategy discountStrategy) {
        this.discountStrategy = discountStrategy;
    }
}
```

### When to Apply OCP

- **Apply when:**
  - You anticipate adding new functionality
  - You want to avoid modifying existing, tested code
  - You need flexibility in implementation
  - You're building frameworks or libraries

- **Don't over-apply:**
  - Don't create abstractions for things that won't change
  - YAGNI (You Aren't Gonna Need It) - don't over-engineer
  - Balance between flexibility and simplicity

---

## Liskov Substitution Principle (LSP)

### Definition

**"Objects of a superclass should be replaceable with objects of its subclasses without breaking the application."**

Subtypes must be substitutable for their base types. If S is a subtype of T, then objects of type T may be replaced with objects of type S without altering any of the desirable properties of the program.

### Key Concepts

- **Behavioral Subtyping**: Subtypes must maintain the behavior expected by the base type
- **Contract Preservation**: Subtypes must honor the contract of the base type
- **No Weakening of Preconditions**: Subtypes can't require more than the base type
- **No Strengthening of Postconditions**: Subtypes can't guarantee less than the base type
- **Invariant Preservation**: Subtypes must preserve invariants of the base type

### Example: Violation of LSP

```java
// ❌ BAD: Rectangle and Square violate LSP
public class Rectangle {
    protected int width;
    protected int height;
    
    public void setWidth(int width) {
        this.width = width;
    }
    
    public void setHeight(int height) {
        this.height = height;
    }
    
    public int getWidth() {
        return width;
    }
    
    public int getHeight() {
        return height;
    }
    
    public int getArea() {
        return width * height;
    }
}

// ❌ BAD: Square violates LSP
public class Square extends Rectangle {
    @Override
    public void setWidth(int width) {
        this.width = width;
        this.height = width; // Problem: Changes height too
    }
    
    @Override
    public void setHeight(int height) {
        this.width = height; // Problem: Changes width too
        this.height = height;
    }
}

// This code breaks when Square is substituted for Rectangle
public class AreaCalculator {
    public void testRectangle(Rectangle rectangle) {
        rectangle.setWidth(5);
        rectangle.setHeight(4);
        // Expects area to be 20, but if Square is passed, it becomes 16
        assert rectangle.getArea() == 20; // Fails for Square!
    }
}
```

**Problems:**
- Square changes behavior of setWidth/setHeight
- Code expecting Rectangle behavior breaks with Square
- Violates LSP - Square is not a true substitute for Rectangle

### Example: Following LSP

```java
// ✅ GOOD: Shape interface
public interface Shape {
    int getArea();
}

// ✅ GOOD: Rectangle implementation
public class Rectangle implements Shape {
    private int width;
    private int height;
    
    public Rectangle(int width, int height) {
        this.width = width;
        this.height = height;
    }
    
    public void setWidth(int width) {
        this.width = width;
    }
    
    public void setHeight(int height) {
        this.height = height;
    }
    
    @Override
    public int getArea() {
        return width * height;
    }
}

// ✅ GOOD: Square implementation - maintains contract
public class Square implements Shape {
    private int side;
    
    public Square(int side) {
        this.side = side;
    }
    
    public void setSide(int side) {
        this.side = side;
    }
    
    @Override
    public int getArea() {
        return side * side;
    }
}

// ✅ GOOD: Both can be used interchangeably
public class AreaCalculator {
    public int calculateArea(Shape shape) {
        return shape.getArea(); // Works with both Rectangle and Square
    }
}
```

### Real-World Example: Collections

```java
// ❌ BAD: Violates LSP
public class ReadOnlyList<T> extends ArrayList<T> {
    @Override
    public boolean add(T element) {
        throw new UnsupportedOperationException("Read-only list");
    }
    
    @Override
    public boolean remove(Object o) {
        throw new UnsupportedOperationException("Read-only list");
    }
}

// Problem: Code expecting ArrayList behavior breaks
public void processList(ArrayList<String> list) {
    list.add("item"); // Throws exception if ReadOnlyList is passed
}

// ✅ GOOD: Follows LSP
public interface List<T> {
    T get(int index);
    int size();
    // No mutating methods
}

public class MutableList<T> implements List<T> {
    private java.util.List<T> items = new ArrayList<>();
    
    public void add(T item) {
        items.add(item);
    }
    
    @Override
    public T get(int index) {
        return items.get(index);
    }
    
    @Override
    public int size() {
        return items.size();
    }
}

public class ImmutableList<T> implements List<T> {
    private final java.util.List<T> items;
    
    public ImmutableList(java.util.List<T> items) {
        this.items = Collections.unmodifiableList(new ArrayList<>(items));
    }
    
    @Override
    public T get(int index) {
        return items.get(index);
    }
    
    @Override
    public int size() {
        return items.size();
    }
}

// Both can be used interchangeably
public void processList(List<String> list) {
    String item = list.get(0); // Works with both implementations
    int size = list.size(); // Works with both implementations
}
```

### Real-World Example: Payment Processing

```java
// ✅ GOOD: Base payment class with contract
public abstract class Payment {
    protected double amount;
    
    public Payment(double amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("Amount must be positive");
        }
        this.amount = amount;
    }
    
    // Contract: Must process payment and return success status
    public abstract boolean process();
    
    // Contract: Must return payment status
    public abstract String getStatus();
    
    public double getAmount() {
        return amount;
    }
}

// ✅ GOOD: Credit card payment - maintains contract
public class CreditCardPayment extends Payment {
    private String cardNumber;
    
    public CreditCardPayment(double amount, String cardNumber) {
        super(amount);
        if (cardNumber == null || cardNumber.length() < 16) {
            throw new IllegalArgumentException("Invalid card number");
        }
        this.cardNumber = cardNumber;
    }
    
    @Override
    public boolean process() {
        // Credit card processing logic
        System.out.println("Processing credit card payment: " + amount);
        return true; // Maintains contract: returns boolean
    }
    
    @Override
    public String getStatus() {
        return "PROCESSED"; // Maintains contract: returns status
    }
}

// ✅ GOOD: Bank transfer - maintains contract
public class BankTransferPayment extends Payment {
    private String accountNumber;
    
    public BankTransferPayment(double amount, String accountNumber) {
        super(amount);
        if (accountNumber == null || accountNumber.isEmpty()) {
            throw new IllegalArgumentException("Invalid account number");
        }
        this.accountNumber = accountNumber;
    }
    
    @Override
    public boolean process() {
        // Bank transfer processing logic
        System.out.println("Processing bank transfer: " + amount);
        return true; // Maintains contract: returns boolean
    }
    
    @Override
    public String getStatus() {
        return "PENDING"; // Maintains contract: returns status
    }
}

// ✅ GOOD: Can use any Payment subclass interchangeably
public class PaymentProcessor {
    public void processPayment(Payment payment) {
        if (payment.process()) {
            System.out.println("Payment successful: " + payment.getStatus());
        } else {
            System.out.println("Payment failed");
        }
    }
}
```

### Common LSP Violations

1. **Throwing New Exceptions**
```java
// ❌ BAD
public class Base {
    public void method() throws IOException { }
}

public class Derived extends Base {
    @Override
    public void method() throws SQLException { // New exception type
        // Violates LSP
    }
}
```

2. **Returning Incompatible Types**
```java
// ❌ BAD
public class Base {
    public Number getValue() {
        return 10;
    }
}

public class Derived extends Base {
    @Override
    public Integer getValue() { // Covariant return is OK, but...
        return null; // Returning null when base doesn't - violates LSP
    }
}
```

3. **Changing Method Behavior**
```java
// ❌ BAD
public class Base {
    public void process() {
        // Does something
    }
}

public class Derived extends Base {
    @Override
    public void process() {
        throw new UnsupportedOperationException(); // Changes behavior
    }
}
```

### When to Apply LSP

- **Apply when:**
  - Creating inheritance hierarchies
  - Implementing interfaces
  - Using polymorphism
  - Building frameworks that others will extend

- **Key Rules:**
  - Subtypes must not remove base type methods
  - Subtypes must not change method signatures in incompatible ways
  - Subtypes must maintain all invariants of the base type
  - Subtypes must not throw new exceptions not in base type

---

## Interface Segregation Principle (ISP)

### Definition

**"Clients should not be forced to depend on interfaces they do not use."**

Instead of one large interface, create smaller, more specific interfaces. Clients should only depend on the methods they actually use.

### Key Concepts

- **Fat Interfaces**: Interfaces with too many methods
- **Client-Specific Interfaces**: Interfaces tailored to specific clients
- **Segregation**: Split large interfaces into smaller, focused ones
- **Dependency Minimization**: Clients depend only on what they need

### Example: Violation of ISP

```java
// ❌ BAD: Fat interface forcing clients to implement unused methods
public interface Worker {
    void work();
    void eat();
    void sleep();
}

// ❌ BAD: Human worker must implement all methods
public class HumanWorker implements Worker {
    @Override
    public void work() {
        System.out.println("Human working...");
    }
    
    @Override
    public void eat() {
        System.out.println("Human eating...");
    }
    
    @Override
    public void sleep() {
        System.out.println("Human sleeping...");
    }
}

// ❌ BAD: Robot worker forced to implement eat() and sleep()
public class RobotWorker implements Worker {
    @Override
    public void work() {
        System.out.println("Robot working...");
    }
    
    @Override
    public void eat() {
        // Robots don't eat! Forced to implement unused method
        throw new UnsupportedOperationException("Robots don't eat");
    }
    
    @Override
    public void sleep() {
        // Robots don't sleep! Forced to implement unused method
        throw new UnsupportedOperationException("Robots don't sleep");
    }
}
```

**Problems:**
- Robot forced to implement methods it doesn't need
- Violates ISP - clients depend on unused methods
- Leads to empty implementations or exceptions
- Hard to maintain and understand

### Example: Following ISP

```java
// ✅ GOOD: Segregated interfaces
public interface Workable {
    void work();
}

public interface Eatable {
    void eat();
}

public interface Sleepable {
    void sleep();
}

// ✅ GOOD: Human implements all relevant interfaces
public class HumanWorker implements Workable, Eatable, Sleepable {
    @Override
    public void work() {
        System.out.println("Human working...");
    }
    
    @Override
    public void eat() {
        System.out.println("Human eating...");
    }
    
    @Override
    public void sleep() {
        System.out.println("Human sleeping...");
    }
}

// ✅ GOOD: Robot only implements what it needs
public class RobotWorker implements Workable {
    @Override
    public void work() {
        System.out.println("Robot working...");
    }
    // No need to implement eat() or sleep()
}

// ✅ GOOD: Can use interfaces independently
public class WorkManager {
    public void manageWork(Workable worker) {
        worker.work(); // Only depends on work() method
    }
}

public class BreakManager {
    public void manageBreak(Eatable worker) {
        worker.eat(); // Only depends on eat() method
    }
}
```

**Benefits:**
- Clients only depend on methods they use
- No forced implementation of unused methods
- More flexible and maintainable
- Easier to understand and test

### Real-World Example: Document Operations

```java
// ❌ BAD: Fat interface
public interface MultiFunctionDevice {
    void print(Document document);
    void scan(Document document);
    void fax(Document document);
    void email(Document document);
}

// ❌ BAD: Simple printer forced to implement all methods
public class SimplePrinter implements MultiFunctionDevice {
    @Override
    public void print(Document document) {
        System.out.println("Printing document...");
    }
    
    @Override
    public void scan(Document document) {
        throw new UnsupportedOperationException("Scanning not supported");
    }
    
    @Override
    public void fax(Document document) {
        throw new UnsupportedOperationException("Faxing not supported");
    }
    
    @Override
    public void email(Document document) {
        throw new UnsupportedOperationException("Emailing not supported");
    }
}

// ✅ GOOD: Segregated interfaces
public interface Printer {
    void print(Document document);
}

public interface Scanner {
    void scan(Document document);
}

public interface FaxMachine {
    void fax(Document document);
}

public interface EmailSender {
    void email(Document document);
}

// ✅ GOOD: Simple printer only implements what it needs
public class SimplePrinter implements Printer {
    @Override
    public void print(Document document) {
        System.out.println("Printing document...");
    }
}

// ✅ GOOD: Multi-function device implements all interfaces
public class MultiFunctionPrinter implements Printer, Scanner, FaxMachine, EmailSender {
    @Override
    public void print(Document document) {
        System.out.println("Printing document...");
    }
    
    @Override
    public void scan(Document document) {
        System.out.println("Scanning document...");
    }
    
    @Override
    public void fax(Document document) {
        System.out.println("Faxing document...");
    }
    
    @Override
    public void email(Document document) {
        System.out.println("Emailing document...");
    }
}

// ✅ GOOD: Clients depend only on what they need
public class PrintService {
    public void printDocument(Printer printer, Document document) {
        printer.print(document); // Only depends on Printer interface
    }
}
```

### Real-World Example: Repository Pattern

```java
// ❌ BAD: Fat repository interface
public interface UserRepository {
    User findById(String id);
    List<User> findAll();
    void save(User user);
    void update(User user);
    void delete(String id);
    void sendEmail(User user);
    void generateReport(User user);
    void backup(User user);
}

// ✅ GOOD: Segregated interfaces
public interface ReadableRepository<T> {
    T findById(String id);
    List<T> findAll();
}

public interface WritableRepository<T> {
    void save(T entity);
    void update(T entity);
    void delete(String id);
}

public interface EmailService {
    void sendEmail(User user);
}

public interface ReportGenerator {
    void generateReport(User user);
}

public interface BackupService {
    void backup(User user);
}

// ✅ GOOD: Repository implements only data access interfaces
public class UserRepository implements ReadableRepository<User>, WritableRepository<User> {
    @Override
    public User findById(String id) {
        // Database query
        return new User();
    }
    
    @Override
    public List<User> findAll() {
        // Database query
        return new ArrayList<>();
    }
    
    @Override
    public void save(User user) {
        // Database save
    }
    
    @Override
    public void update(User user) {
        // Database update
    }
    
    @Override
    public void delete(String id) {
        // Database delete
    }
}

// ✅ GOOD: Separate services for other concerns
public class UserEmailService implements EmailService {
    @Override
    public void sendEmail(User user) {
        // Email logic
    }
}
```

### Interface Composition

```java
// ✅ GOOD: Compose interfaces for flexibility
public interface Readable<T> {
    T read(String id);
    List<T> readAll();
}

public interface Writable<T> {
    void write(T entity);
    void update(T entity);
}

public interface Deletable {
    void delete(String id);
}

// Compose interfaces as needed
public interface CrudRepository<T> extends Readable<T>, Writable<T>, Deletable {
    // Combines all CRUD operations
}

// Or use only what you need
public class ReadOnlyRepository<T> implements Readable<T> {
    // Only read operations
}
```

### When to Apply ISP

- **Apply when:**
  - Interfaces have many methods
  - Clients only use a subset of interface methods
  - You see empty implementations or exceptions
  - Interfaces are hard to understand

- **Signs of Violation:**
  - Classes implementing interfaces with empty methods
  - Classes throwing UnsupportedOperationException
  - Clients depending on methods they don't use
  - Large interfaces with unrelated methods

---

## Dependency Inversion Principle (DIP)

### Definition

**"High-level modules should not depend on low-level modules. Both should depend on abstractions."**

Depend on abstractions (interfaces/abstract classes) rather than concrete implementations. This promotes loose coupling and flexibility.

### Key Concepts

- **High-Level Modules**: Business logic, application flow
- **Low-Level Modules**: Database, file system, external services
- **Abstractions**: Interfaces, abstract classes
- **Dependency Injection**: Dependencies provided from outside
- **Inversion of Control (IoC)**: Framework controls object creation

### Example: Violation of DIP

```java
// ❌ BAD: High-level module depends on low-level module
public class UserService {
    // Direct dependency on concrete MySQL database
    private MySQLDatabase database;
    
    public UserService() {
        this.database = new MySQLDatabase(); // Tight coupling
    }
    
    public void saveUser(User user) {
        database.save(user); // Depends on MySQLDatabase
    }
    
    public User getUser(String id) {
        return database.findById(id);
    }
}

// Low-level module
public class MySQLDatabase {
    public void save(User user) {
        System.out.println("Saving to MySQL: " + user.getName());
    }
    
    public User findById(String id) {
        System.out.println("Finding in MySQL: " + id);
        return new User();
    }
}
```

**Problems:**
- UserService tightly coupled to MySQLDatabase
- Can't easily switch to PostgreSQL or MongoDB
- Hard to test (can't mock database)
- Violates DIP - depends on concrete implementation

### Example: Following DIP

```java
// ✅ GOOD: Abstraction (interface)
public interface UserRepository {
    void save(User user);
    User findById(String id);
}

// ✅ GOOD: Low-level module implements abstraction
public class MySQLUserRepository implements UserRepository {
    @Override
    public void save(User user) {
        System.out.println("Saving to MySQL: " + user.getName());
    }
    
    @Override
    public User findById(String id) {
        System.out.println("Finding in MySQL: " + id);
        return new User();
    }
}

// ✅ GOOD: Another implementation
public class PostgreSQLUserRepository implements UserRepository {
    @Override
    public void save(User user) {
        System.out.println("Saving to PostgreSQL: " + user.getName());
    }
    
    @Override
    public User findById(String id) {
        System.out.println("Finding in PostgreSQL: " + id);
        return new User();
    }
}

// ✅ GOOD: High-level module depends on abstraction
public class UserService {
    private UserRepository userRepository; // Depends on abstraction
    
    // Dependency injection via constructor
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    public void saveUser(User user) {
        userRepository.save(user); // Uses abstraction
    }
    
    public User getUser(String id) {
        return userRepository.findById(id);
    }
}

// ✅ GOOD: Can easily switch implementations
public class Application {
    public static void main(String[] args) {
        // Can use MySQL
        UserRepository mysqlRepo = new MySQLUserRepository();
        UserService service1 = new UserService(mysqlRepo);
        
        // Or PostgreSQL
        UserRepository postgresRepo = new PostgreSQLUserRepository();
        UserService service2 = new UserService(postgresRepo);
        
        // Or even a mock for testing
        UserRepository mockRepo = new MockUserRepository();
        UserService service3 = new UserService(mockRepo);
    }
}
```

**Benefits:**
- Loose coupling between modules
- Easy to switch implementations
- Easy to test with mocks
- Follows DIP - depends on abstractions

### Real-World Example: Notification System

```java
// ❌ BAD: High-level depends on low-level
public class OrderService {
    private EmailService emailService;
    private SMSService smsService;
    
    public OrderService() {
        this.emailService = new EmailService(); // Tight coupling
        this.smsService = new SMSService(); // Tight coupling
    }
    
    public void processOrder(Order order) {
        // Process order logic
        emailService.sendEmail(order.getCustomerEmail(), "Order confirmed");
        smsService.sendSMS(order.getCustomerPhone(), "Order confirmed");
    }
}

// ✅ GOOD: Abstraction
public interface NotificationService {
    void sendNotification(String recipient, String message);
}

// ✅ GOOD: Concrete implementations
public class EmailNotificationService implements NotificationService {
    @Override
    public void sendNotification(String recipient, String message) {
        System.out.println("Sending email to " + recipient + ": " + message);
    }
}

public class SMSNotificationService implements NotificationService {
    @Override
    public void sendNotification(String recipient, String message) {
        System.out.println("Sending SMS to " + recipient + ": " + message);
    }
}

public class PushNotificationService implements NotificationService {
    @Override
    public void sendNotification(String recipient, String message) {
        System.out.println("Sending push notification to " + recipient + ": " + message);
    }
}

// ✅ GOOD: High-level depends on abstraction
public class OrderService {
    private List<NotificationService> notificationServices;
    
    public OrderService(List<NotificationService> notificationServices) {
        this.notificationServices = notificationServices; // Dependency injection
    }
    
    public void processOrder(Order order) {
        // Process order logic
        String message = "Order confirmed";
        notificationServices.forEach(service -> 
            service.sendNotification(order.getCustomerContact(), message)
        );
    }
}
```

### Dependency Injection Patterns

#### 1. Constructor Injection (Recommended)
```java
public class UserService {
    private UserRepository userRepository;
    
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
```

#### 2. Setter Injection
```java
public class UserService {
    private UserRepository userRepository;
    
    public void setUserRepository(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
```

#### 3. Interface Injection
```java
public interface RepositoryInjectable {
    void injectRepository(UserRepository repository);
}

public class UserService implements RepositoryInjectable {
    private UserRepository userRepository;
    
    @Override
    public void injectRepository(UserRepository repository) {
        this.userRepository = repository;
    }
}
```

### Spring Framework and DIP

```java
// ✅ GOOD: Using Spring's dependency injection
@Service
public class UserService {
    private final UserRepository userRepository;
    
    @Autowired
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository; // Spring injects implementation
    }
}

@Repository
public class MySQLUserRepository implements UserRepository {
    // Implementation
}

// Spring automatically wires dependencies based on interfaces
```

### When to Apply DIP

- **Apply when:**
  - You need to switch implementations
  - You want to test components in isolation
  - You're building frameworks or libraries
  - You need loose coupling

- **Benefits:**
  - Flexibility: Easy to swap implementations
  - Testability: Can inject mocks
  - Maintainability: Changes in low-level don't affect high-level
  - Reusability: Components can be reused

---

## SOLID Principles Together

### Example: Complete SOLID-Compliant Design

```java
// ========== SRP: Single Responsibility ==========
// User entity - only user data
public class User {
    private String id;
    private String name;
    private String email;
    
    // Getters and setters only
}

// ========== DIP: Dependency Inversion ==========
// Abstraction for repository
public interface UserRepository {
    User findById(String id);
    void save(User user);
}

// ========== OCP: Open/Closed ==========
// Different repository implementations
public class MySQLUserRepository implements UserRepository {
    @Override
    public User findById(String id) {
        // MySQL implementation
        return new User();
    }
    
    @Override
    public void save(User user) {
        // MySQL implementation
    }
}

public class MongoDBUserRepository implements UserRepository {
    @Override
    public User findById(String id) {
        // MongoDB implementation
        return new User();
    }
    
    @Override
    public void save(User user) {
        // MongoDB implementation
    }
}

// ========== ISP: Interface Segregation ==========
// Segregated interfaces for different operations
public interface ReadableRepository<T> {
    T findById(String id);
}

public interface WritableRepository<T> {
    void save(T entity);
}

// ========== LSP: Liskov Substitution ==========
// All repository implementations are substitutable
public class UserService {
    private UserRepository userRepository; // DIP: depends on abstraction
    
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository; // Can use any implementation
    }
    
    public User getUser(String id) {
        return userRepository.findById(id); // Works with any implementation
    }
    
    public void saveUser(User user) {
        userRepository.save(user); // Works with any implementation
    }
}
```

### Benefits of Applying All SOLID Principles

1. **Maintainability**: Code is easier to understand and modify
2. **Testability**: Components can be tested in isolation
3. **Flexibility**: Easy to extend and modify
4. **Reusability**: Components can be reused in different contexts
5. **Scalability**: System can grow without major refactoring

---

## Common Violations and How to Fix Them

### 1. God Class (SRP Violation)

**Problem:**
```java
public class UserManager {
    // Too many responsibilities
    public void createUser() { }
    public void deleteUser() { }
    public void sendEmail() { }
    public void generateReport() { }
    public void backupData() { }
    public void validateInput() { }
}
```

**Solution:**
```java
public class UserService {
    public void createUser() { }
    public void deleteUser() { }
}

public class EmailService {
    public void sendEmail() { }
}

public class ReportService {
    public void generateReport() { }
}
```

### 2. Switch Statements (OCP Violation)

**Problem:**
```java
public double calculateArea(String shapeType, double... params) {
    switch(shapeType) {
        case "rectangle": return params[0] * params[1];
        case "circle": return Math.PI * params[0] * params[0];
        // Adding new shape requires modifying this method
    }
}
```

**Solution:**
```java
public interface Shape {
    double calculateArea();
}

public class Rectangle implements Shape {
    public double calculateArea() { /* ... */ }
}

// New shapes can be added without modifying existing code
```

### 3. Derived Classes Changing Base Behavior (LSP Violation)

**Problem:**
```java
public class Bird {
    public void fly() { /* ... */ }
}

public class Penguin extends Bird {
    @Override
    public void fly() {
        throw new UnsupportedOperationException(); // Violates LSP
    }
}
```

**Solution:**
```java
public interface Flyable {
    void fly();
}

public class Bird implements Flyable {
    public void fly() { /* ... */ }
}

public class Penguin {
    // Doesn't implement Flyable - no violation
}
```

### 4. Fat Interfaces (ISP Violation)

**Problem:**
```java
public interface Animal {
    void eat();
    void sleep();
    void fly();
    void swim();
    void walk();
}
```

**Solution:**
```java
public interface Eatable { void eat(); }
public interface Sleepable { void sleep(); }
public interface Flyable { void fly(); }
public interface Swimmable { void swim(); }
public interface Walkable { void walk(); }
```

### 5. Direct Dependencies (DIP Violation)

**Problem:**
```java
public class OrderService {
    private MySQLDatabase database = new MySQLDatabase(); // Direct dependency
}
```

**Solution:**
```java
public class OrderService {
    private Database database; // Depends on abstraction
    
    public OrderService(Database database) {
        this.database = database; // Dependency injection
    }
}
```

---

## Best Practices

### 1. Start with SRP
- Identify responsibilities
- Separate concerns
- Create focused classes

### 2. Use Abstractions for OCP
- Define interfaces/abstract classes
- Use polymorphism
- Design for extension

### 3. Design Inheritance Carefully for LSP
- Ensure substitutability
- Maintain contracts
- Preserve invariants

### 4. Keep Interfaces Focused for ISP
- One interface per concern
- Avoid fat interfaces
- Compose interfaces when needed

### 5. Inject Dependencies for DIP
- Use constructor injection
- Depend on abstractions
- Use dependency injection frameworks

### 6. Balance Principles
- Don't over-engineer
- Apply principles where they add value
- Consider YAGNI (You Aren't Gonna Need It)

### 7. Refactor Gradually
- Don't rewrite everything at once
- Identify violations
- Refactor incrementally

### 8. Test Your Design
- Write unit tests
- Verify substitutability
- Test in isolation

---

## Summary

### SOLID Principles at a Glance

| Principle | Key Idea | Benefit |
|-----------|----------|---------|
| **SRP** | One class, one responsibility | Easier to maintain and test |
| **OCP** | Open for extension, closed for modification | Flexible and extensible |
| **LSP** | Subtypes must be substitutable | Reliable polymorphism |
| **ISP** | Clients shouldn't depend on unused methods | Focused and flexible interfaces |
| **DIP** | Depend on abstractions, not concretions | Loose coupling and testability |

### Remember

- **SOLID principles work together** to create maintainable software
- **Apply principles judiciously** - don't over-engineer
- **Refactor incrementally** - improve code over time
- **Test your design** - verify principles are followed
- **Balance is key** - practical solutions over perfect theory

---

## References and Further Reading

- "Clean Code" by Robert C. Martin
- "Agile Software Development: Principles, Patterns, and Practices" by Robert C. Martin
- "Design Patterns: Elements of Reusable Object-Oriented Software" by Gang of Four
- "Refactoring" by Martin Fowler

---

*This document provides an in-depth explanation of SOLID principles with practical Java examples. Apply these principles to create maintainable, scalable, and robust software systems.*

