# System Design: Ticket Booking System

## Table of Contents
1. [Problem Statement](#problem-statement)
2. [Requirements](#requirements)
3. [System Architecture](#system-architecture)
4. [Database Design](#database-design)
5. [API Design](#api-design)
6. [Concurrency & Race Conditions](#concurrency--race-conditions)
7. [Seat Selection & Locking](#seat-selection--locking)
8. [Payment Processing](#payment-processing)
9. [Scalability Considerations](#scalability-considerations)
10. [Technology Stack](#technology-stack)
11. [Example Flows](#example-flows)

---

## Problem Statement

Design a ticket booking system that allows users to:
- Browse available events/shows (movies, concerts, sports events, etc.)
- Select seats
- Book tickets
- Make payments
- Receive confirmation
- Cancel/refund tickets

The system must handle:
- High concurrent booking requests
- Prevent double booking
- Real-time seat availability
- Payment processing
- Notification system

---

## Requirements

### Functional Requirements
1. **User Management**
   - User registration and authentication
   - User profiles
   - Booking history

2. **Event Management**
   - Create/manage events
   - Event details (venue, date, time, pricing)
   - Seat layout and availability

3. **Booking System**
   - Browse events
   - View seat availability
   - Select seats
   - Reserve seats (temporary lock)
   - Book tickets
   - Cancel bookings
   - Refund processing

4. **Payment Processing**
   - Multiple payment methods
   - Payment gateway integration
   - Transaction history
   - Refund processing

5. **Notifications**
   - Booking confirmation
   - Payment receipts
   - Reminders
   - Cancellation notifications

### Non-Functional Requirements
1. **Performance**
   - Handle 100K+ concurrent users
   - Response time < 200ms for seat availability
   - Support 10K+ bookings per minute

2. **Reliability**
   - 99.9% uptime
   - No double bookings
   - Data consistency

3. **Scalability**
   - Horizontal scaling
   - Handle traffic spikes (flash sales)
   - Support multiple venues/events

4. **Security**
   - Secure payment processing
   - Prevent fraud
   - Data encryption

---

## System Architecture

### High-Level Architecture

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   Web App   │     │  Mobile App │     │  Admin UI   │
└──────┬──────┘     └──────┬──────┘     └──────┬──────┘
       │                   │                    │
       └───────────────────┼────────────────────┘
                            │
                   ┌────────▼────────┐
                   │   API Gateway   │
                   │  (Load Balancer)│
                   └────────┬────────┘
                            │
        ┌───────────────────┼───────────────────┐
        │                   │                   │
┌───────▼────────┐  ┌───────▼────────┐  ┌───────▼────────┐
│  Auth Service  │  │  Booking       │  │  Event        │
│                │  │  Service       │  │  Service       │
└────────────────┘  └───────┬────────┘  └───────┬────────┘
                            │                   │
        ┌───────────────────┼───────────────────┐
        │                   │                   │
┌───────▼────────┐  ┌───────▼────────┐  ┌───────▼────────┐
│  Payment      │  │  Seat Lock     │  │  Notification  │
│  Service      │  │  Service       │  │  Service       │
└───────┬───────┘  └────────────────┘  └───────┬────────┘
        │                                       │
        │                              ┌────────▼────────┐
        │                              │  Message Queue │
        │                              │  (Kafka/RabbitMQ)│
        │                              └─────────────────┘
        │
┌───────▼──────────────────────────────────────────────────┐
│              Database Layer                               │
│  - PostgreSQL (Transactions, Bookings)                  │
│  - Redis (Seat availability cache, locks)                │
│  - MongoDB (Event details, logs)                         │
└──────────────────────────────────────────────────────────┘
```

### Component Details

#### 1. API Gateway
- Request routing
- Authentication/authorization
- Rate limiting
- Request/response transformation
- SSL termination

#### 2. Booking Service
- Core booking logic
- Seat selection
- Booking creation/updates
- Booking validation

#### 3. Event Service
- Event management
- Event details
- Seat layout management
- Pricing rules

#### 4. Seat Lock Service
- Temporary seat reservations
- Lock expiration management
- Lock cleanup

#### 5. Payment Service
- Payment processing
- Payment gateway integration
- Refund processing
- Transaction management

#### 6. Notification Service
- Email notifications
- SMS notifications
- Push notifications
- Notification templates

---

## Database Design

### PostgreSQL Schema

#### Users Table
```sql
CREATE TABLE users (
    user_id UUID PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    username VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    phone_number VARCHAR(20),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    is_active BOOLEAN DEFAULT TRUE
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_username ON users(username);
```

#### Venues Table
```sql
CREATE TABLE venues (
    venue_id UUID PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    address TEXT NOT NULL,
    city VARCHAR(100),
    state VARCHAR(100),
    country VARCHAR(100),
    capacity INT NOT NULL,
    seat_layout JSONB, -- Seat map configuration
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_venues_city ON venues(city);
```

#### Events Table
```sql
CREATE TABLE events (
    event_id UUID PRIMARY KEY,
    venue_id UUID REFERENCES venues(venue_id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    event_type VARCHAR(50), -- 'movie', 'concert', 'sports', etc.
    start_time TIMESTAMP NOT NULL,
    end_time TIMESTAMP NOT NULL,
    status VARCHAR(20) DEFAULT 'upcoming', -- 'upcoming', 'live', 'completed', 'cancelled'
    base_price DECIMAL(10, 2) NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_events_venue ON events(venue_id);
CREATE INDEX idx_events_start_time ON events(start_time);
CREATE INDEX idx_events_status ON events(status);
```

#### Seats Table
```sql
CREATE TABLE seats (
    seat_id UUID PRIMARY KEY,
    venue_id UUID REFERENCES venues(venue_id),
    row_number VARCHAR(10) NOT NULL,
    seat_number VARCHAR(10) NOT NULL,
    seat_type VARCHAR(50), -- 'regular', 'premium', 'vip', etc.
    price_multiplier DECIMAL(3, 2) DEFAULT 1.0, -- Multiplier for base price
    is_active BOOLEAN DEFAULT TRUE,
    UNIQUE(venue_id, row_number, seat_number)
);

CREATE INDEX idx_seats_venue ON seats(venue_id);
CREATE INDEX idx_seats_venue_row ON seats(venue_id, row_number);
```

#### Bookings Table
```sql
CREATE TABLE bookings (
    booking_id UUID PRIMARY KEY,
    user_id UUID REFERENCES users(user_id),
    event_id UUID REFERENCES events(event_id),
    status VARCHAR(20) NOT NULL, -- 'pending', 'confirmed', 'cancelled', 'expired'
    total_amount DECIMAL(10, 2) NOT NULL,
    currency VARCHAR(3) DEFAULT 'USD',
    booking_time TIMESTAMP DEFAULT NOW(),
    expiry_time TIMESTAMP, -- For pending bookings
    confirmed_at TIMESTAMP,
    cancelled_at TIMESTAMP,
    cancellation_reason TEXT
);

CREATE INDEX idx_bookings_user ON bookings(user_id);
CREATE INDEX idx_bookings_event ON bookings(event_id);
CREATE INDEX idx_bookings_status ON bookings(status);
CREATE INDEX idx_bookings_expiry ON bookings(expiry_time) WHERE status = 'pending';
```

#### Booking Seats Table
```sql
CREATE TABLE booking_seats (
    booking_seat_id UUID PRIMARY KEY,
    booking_id UUID REFERENCES bookings(booking_id) ON DELETE CASCADE,
    seat_id UUID REFERENCES seats(seat_id),
    price DECIMAL(10, 2) NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(booking_id, seat_id)
);

CREATE INDEX idx_booking_seats_booking ON booking_seats(booking_id);
CREATE INDEX idx_booking_seats_seat ON booking_seats(seat_id);
```

#### Payments Table
```sql
CREATE TABLE payments (
    payment_id UUID PRIMARY KEY,
    booking_id UUID REFERENCES bookings(booking_id),
    user_id UUID REFERENCES users(user_id),
    amount DECIMAL(10, 2) NOT NULL,
    currency VARCHAR(3) DEFAULT 'USD',
    payment_method VARCHAR(50), -- 'credit_card', 'debit_card', 'paypal', etc.
    payment_status VARCHAR(20) NOT NULL, -- 'pending', 'completed', 'failed', 'refunded'
    transaction_id VARCHAR(255), -- External payment gateway transaction ID
    payment_gateway VARCHAR(50),
    payment_time TIMESTAMP,
    refunded_at TIMESTAMP,
    refund_amount DECIMAL(10, 2),
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_payments_booking ON payments(booking_id);
CREATE INDEX idx_payments_user ON payments(user_id);
CREATE INDEX idx_payments_status ON payments(payment_status);
CREATE INDEX idx_payments_transaction ON payments(transaction_id);
```

#### Seat Locks Table
```sql
CREATE TABLE seat_locks (
    lock_id UUID PRIMARY KEY,
    event_id UUID REFERENCES events(event_id),
    seat_id UUID REFERENCES seats(seat_id),
    user_id UUID REFERENCES users(user_id),
    booking_id UUID REFERENCES bookings(booking_id),
    lock_expiry TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(event_id, seat_id) -- One lock per seat per event
);

CREATE INDEX idx_seat_locks_event_seat ON seat_locks(event_id, seat_id);
CREATE INDEX idx_seat_locks_expiry ON seat_locks(lock_expiry);
CREATE INDEX idx_seat_locks_booking ON seat_locks(booking_id);
```

### Redis Schema

#### Seat Availability Cache
```
Key: event:{event_id}:seats:available
Type: Set
Value: Set of available seat_ids
TTL: Until event ends

Key: event:{event_id}:seat:{seat_id}:status
Type: String
Value: 'available' | 'locked' | 'booked'
TTL: Until event ends
```

#### Seat Locks
```
Key: lock:event:{event_id}:seat:{seat_id}
Type: String
Value: JSON {user_id, booking_id, expiry_time}
TTL: 15 minutes (lock duration)
```

#### Booking Cache
```
Key: booking:{booking_id}
Type: Hash
Value: {user_id, event_id, status, seats, amount}
TTL: 24 hours
```

#### Rate Limiting
```
Key: rate_limit:user:{user_id}:bookings
Type: Counter
Value: Number of booking attempts
TTL: 1 minute
```

---

## API Design

### REST APIs

#### Authentication
```
POST   /api/v1/auth/register
POST   /api/v1/auth/login
POST   /api/v1/auth/logout
POST   /api/v1/auth/refresh
GET    /api/v1/auth/me
```

#### Events
```
GET    /api/v1/events                    # List events (with filters)
GET    /api/v1/events/{event_id}          # Get event details
GET    /api/v1/events/{event_id}/seats    # Get seat availability
GET    /api/v1/venues                     # List venues
GET    /api/v1/venues/{venue_id}          # Get venue details
```

#### Bookings
```
POST   /api/v1/bookings                  # Create booking
GET    /api/v1/bookings/{booking_id}     # Get booking details
GET    /api/v1/bookings                  # Get user's bookings
POST   /api/v1/bookings/{booking_id}/confirm  # Confirm booking
POST   /api/v1/bookings/{booking_id}/cancel   # Cancel booking
DELETE /api/v1/bookings/{booking_id}     # Delete pending booking
```

#### Seats
```
POST   /api/v1/seats/lock                # Lock seats
POST   /api/v1/seats/unlock              # Unlock seats
GET    /api/v1/events/{event_id}/seats/availability  # Get availability
```

#### Payments
```
POST   /api/v1/payments                  # Process payment
GET    /api/v1/payments/{payment_id}     # Get payment status
POST   /api/v1/payments/{payment_id}/refund  # Process refund
```

### Request/Response Examples

#### Get Seat Availability
```http
GET /api/v1/events/123/seats/availability

Response:
{
  "event_id": "123",
  "available_seats": 150,
  "locked_seats": 10,
  "booked_seats": 40,
  "total_seats": 200,
  "seats": [
    {
      "seat_id": "s1",
      "row": "A",
      "number": "1",
      "status": "available",
      "price": 25.00
    },
    {
      "seat_id": "s2",
      "row": "A",
      "number": "2",
      "status": "locked",
      "price": 25.00
    }
  ]
}
```

#### Lock Seats
```http
POST /api/v1/seats/lock
{
  "event_id": "123",
  "seat_ids": ["s1", "s2", "s3"],
  "lock_duration_minutes": 15
}

Response:
{
  "lock_id": "lock-456",
  "booking_id": "booking-789",
  "expires_at": "2024-01-15T10:30:00Z",
  "locked_seats": ["s1", "s2", "s3"]
}
```

#### Create Booking
```http
POST /api/v1/bookings
{
  "event_id": "123",
  "seat_ids": ["s1", "s2"],
  "lock_id": "lock-456"
}

Response:
{
  "booking_id": "booking-789",
  "status": "pending",
  "total_amount": 50.00,
  "expires_at": "2024-01-15T10:30:00Z",
  "seats": [
    {
      "seat_id": "s1",
      "row": "A",
      "number": "1",
      "price": 25.00
    },
    {
      "seat_id": "s2",
      "row": "A",
      "number": "2",
      "price": 25.00
    }
  ]
}
```

#### Process Payment
```http
POST /api/v1/payments
{
  "booking_id": "booking-789",
  "payment_method": "credit_card",
  "card_token": "token-abc123",
  "amount": 50.00
}

Response:
{
  "payment_id": "payment-999",
  "status": "completed",
  "transaction_id": "txn-xyz789",
  "amount": 50.00,
  "paid_at": "2024-01-15T10:25:00Z"
}
```

---

## Concurrency & Race Conditions

### Problem: Double Booking
When multiple users try to book the same seat simultaneously, we need to prevent double booking.

### Solutions

#### 1. Database-Level Locking (Pessimistic Locking)
```sql
-- Use SELECT FOR UPDATE to lock rows
BEGIN TRANSACTION;

SELECT * FROM seats 
WHERE seat_id IN ('s1', 's2') 
AND event_id = '123'
FOR UPDATE;

-- Check availability
-- Insert booking
-- Update seat status

COMMIT;
```

#### 2. Optimistic Locking with Version
```sql
CREATE TABLE seats (
    seat_id UUID PRIMARY KEY,
    event_id UUID REFERENCES events(event_id),
    version INT DEFAULT 0,
    status VARCHAR(20),
    ...
);

-- Update with version check
UPDATE seats 
SET status = 'booked', version = version + 1
WHERE seat_id = 's1' 
AND version = :expected_version;
```

#### 3. Redis-Based Distributed Locking
```python
import redis
import time
import uuid

def acquire_seat_lock(redis_client, event_id, seat_id, user_id, ttl=900):
    """
    Acquire distributed lock for a seat
    Returns lock_id if successful, None otherwise
    """
    lock_key = f"lock:event:{event_id}:seat:{seat_id}"
    lock_id = str(uuid.uuid4())
    
    # Try to set lock (NX = only if not exists)
    if redis_client.set(lock_key, lock_id, nx=True, ex=ttl):
        return lock_id
    return None

def release_seat_lock(redis_client, event_id, seat_id, lock_id):
    """
    Release lock only if it matches (atomic operation)
    """
    lock_key = f"lock:event:{event_id}:seat:{seat_id}"
    
    # Lua script for atomic check-and-delete
    lua_script = """
    if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
    else
        return 0
    end
    """
    
    return redis_client.eval(lua_script, 1, lock_key, lock_id)
```

#### 4. Two-Phase Booking (Recommended)
```
Phase 1: Lock (Temporary Reservation)
- Lock seats for 15 minutes
- Store lock in Redis + Database
- User can proceed to payment

Phase 2: Confirm (Permanent Booking)
- Process payment
- Convert lock to booking
- Update seat status to 'booked'
- Release lock
```

### Implementation Flow

```python
def book_seats(event_id, seat_ids, user_id):
    """
    Book seats with proper concurrency handling
    """
    # Step 1: Acquire locks for all seats (atomic operation)
    lock_ids = []
    try:
        for seat_id in seat_ids:
            lock_id = acquire_seat_lock(redis_client, event_id, seat_id, user_id)
            if not lock_id:
                # Release all acquired locks
                for acquired_lock in lock_ids:
                    release_seat_lock(redis_client, event_id, seat_id, acquired_lock)
                raise SeatUnavailableError(f"Seat {seat_id} is not available")
            lock_ids.append((seat_id, lock_id))
        
        # Step 2: Create booking in database (with transaction)
        with db.transaction():
            booking = create_booking(event_id, seat_ids, user_id)
            
            # Step 3: Update seat status
            update_seat_status(event_id, seat_ids, 'locked')
            
            # Step 4: Store locks in database
            store_seat_locks(booking.id, lock_ids)
        
        return booking
        
    except Exception as e:
        # Rollback: Release all locks
        for seat_id, lock_id in lock_ids:
            release_seat_lock(redis_client, event_id, seat_id, lock_id)
        raise
```

---

## Seat Selection & Locking

### Lock Strategy

#### Lock Duration
- **Initial Lock**: 15 minutes (for user to complete payment)
- **Extendable**: Can extend if payment is in progress
- **Auto-release**: Automatically released after expiry

#### Lock Cleanup
```python
def cleanup_expired_locks():
    """
    Background job to clean up expired locks
    Runs every minute
    """
    expired_locks = db.query("""
        SELECT lock_id, event_id, seat_id, booking_id
        FROM seat_locks
        WHERE lock_expiry < NOW()
        AND booking_id IS NULL
    """)
    
    for lock in expired_locks:
        # Release Redis lock
        release_seat_lock(redis_client, lock.event_id, lock.seat_id, lock.lock_id)
        
        # Update seat status to available
        update_seat_status(lock.event_id, lock.seat_id, 'available')
        
        # Delete lock record
        db.delete_seat_lock(lock.lock_id)
        
        # Notify user (if needed)
        notify_lock_expired(lock.user_id, lock.event_id)
```

### Seat Availability Calculation

```python
def get_seat_availability(event_id):
    """
    Get real-time seat availability
    Uses Redis cache for performance
    """
    cache_key = f"event:{event_id}:availability"
    
    # Try cache first
    cached = redis_client.get(cache_key)
    if cached:
        return json.loads(cached)
    
    # Calculate from database
    total_seats = db.count_seats(event_id)
    booked_seats = db.count_booked_seats(event_id)
    locked_seats = db.count_locked_seats(event_id)
    
    available_seats = total_seats - booked_seats - locked_seats
    
    result = {
        "total": total_seats,
        "available": available_seats,
        "booked": booked_seats,
        "locked": locked_seats
    }
    
    # Cache for 30 seconds
    redis_client.setex(cache_key, 30, json.dumps(result))
    
    return result
```

---

## Payment Processing

### Payment Flow

```
1. User initiates payment
   ↓
2. Payment Service validates booking
   ↓
3. Create payment record (status: pending)
   ↓
4. Call payment gateway API
   ↓
5. Payment gateway processes payment
   ↓
6. Receive webhook/callback
   ↓
7. Update payment status
   ↓
8. If successful:
   - Confirm booking
   - Release seat locks
   - Send confirmation
   ↓
9. If failed:
   - Keep booking as pending
   - Allow retry
   - Release locks after expiry
```

### Payment Gateway Integration

```python
class PaymentService:
    def process_payment(self, booking_id, payment_method, payment_data):
        """
        Process payment through gateway
        """
        booking = get_booking(booking_id)
        
        # Create payment record
        payment = create_payment_record(
            booking_id=booking_id,
            amount=booking.total_amount,
            payment_method=payment_method,
            status='pending'
        )
        
        try:
            # Call payment gateway
            if payment_method == 'credit_card':
                result = credit_card_gateway.charge(
                    amount=booking.total_amount,
                    card_token=payment_data['card_token']
                )
            elif payment_method == 'paypal':
                result = paypal_gateway.charge(
                    amount=booking.total_amount,
                    paypal_id=payment_data['paypal_id']
                )
            
            # Update payment status
            if result.success:
                update_payment_status(payment.id, 'completed', result.transaction_id)
                confirm_booking(booking_id)
                send_confirmation(booking.user_id, booking_id)
            else:
                update_payment_status(payment.id, 'failed', None, result.error)
                
            return payment
            
        except Exception as e:
            update_payment_status(payment.id, 'failed', None, str(e))
            raise
```

### Idempotency
```python
def process_payment_with_idempotency(booking_id, idempotency_key):
    """
    Ensure payment is processed only once
    """
    # Check if payment already processed with this key
    existing = get_payment_by_idempotency_key(idempotency_key)
    if existing:
        return existing
    
    # Process payment
    payment = process_payment(booking_id, ...)
    
    # Store idempotency key
    store_idempotency_key(idempotency_key, payment.id)
    
    return payment
```

---

## Scalability Considerations

### Horizontal Scaling

#### Stateless Services
- All services are stateless
- Can scale horizontally behind load balancer
- Use shared Redis for distributed state

#### Database Scaling
- **Read Replicas**: For read-heavy operations (browsing events, checking availability)
- **Sharding**: Shard by event_id or venue_id
- **Connection Pooling**: Use connection pools

#### Caching Strategy
- **L1 Cache (Redis)**: 
  - Seat availability (30s TTL)
  - Active locks
  - Booking details
- **L2 Cache (Application)**: 
  - Event details
  - Venue layouts

### Load Balancing
- **Round-robin** for API requests
- **Sticky sessions** not needed (stateless)
- **Health checks** for all services

### Rate Limiting
```python
# Per user rate limiting
RATE_LIMIT_BOOKINGS = 10  # per minute
RATE_LIMIT_SEAT_CHECKS = 100  # per minute

# Per IP rate limiting
RATE_LIMIT_IP = 1000  # requests per minute
```

### Handling Flash Sales
1. **Queue System**: Use message queue for booking requests
2. **Pre-allocation**: Pre-allocate seats for high-demand events
3. **Virtual Waiting Room**: Queue users during peak times
4. **Caching**: Aggressively cache seat availability

---

## Technology Stack

### Backend
- **API Framework**: Node.js (Express) / Python (FastAPI) / Java (Spring Boot)
- **Database**: PostgreSQL (transactions), Redis (caching/locks), MongoDB (logs)
- **Message Queue**: Kafka / RabbitMQ / Redis Streams
- **Cache**: Redis
- **Search**: Elasticsearch (for event search)

### Payment
- **Payment Gateways**: Stripe, PayPal, Square
- **Payment Processing**: Dedicated payment service

### Frontend
- **Web**: React / Vue.js / Angular
- **Mobile**: React Native / Flutter
- **Real-time**: WebSocket / Server-Sent Events

### Infrastructure
- **Containerization**: Docker, Kubernetes
- **Load Balancer**: NGINX / AWS ALB
- **CDN**: CloudFront / Cloudflare
- **Monitoring**: Prometheus, Grafana
- **Logging**: ELK Stack

### Cloud Services (AWS Example)
- **Compute**: EC2 / ECS / Lambda
- **Database**: RDS (PostgreSQL), ElastiCache (Redis), DocumentDB (MongoDB)
- **Message Queue**: SQS / Kinesis
- **Storage**: S3 (for receipts, documents)

---

## Example Flows

### Complete Booking Flow

```
1. User browses events
   GET /api/v1/events
   ↓
2. User selects event and views seats
   GET /api/v1/events/123/seats/availability
   ↓
3. User selects seats
   POST /api/v1/seats/lock
   {
     "event_id": "123",
     "seat_ids": ["s1", "s2"],
     "lock_duration_minutes": 15
   }
   Response: {lock_id, booking_id, expires_at}
   ↓
4. User confirms booking
   POST /api/v1/bookings
   {
     "event_id": "123",
     "seat_ids": ["s1", "s2"],
     "lock_id": "lock-456"
   }
   Response: {booking_id, total_amount, expires_at}
   ↓
5. User makes payment
   POST /api/v1/payments
   {
     "booking_id": "booking-789",
     "payment_method": "credit_card",
     "card_token": "token-abc",
     "amount": 50.00
   }
   ↓
6. Payment processed
   - Payment gateway charges card
   - Payment status updated to 'completed'
   - Booking confirmed
   - Seats marked as 'booked'
   - Locks released
   ↓
7. Confirmation sent
   - Email confirmation
   - SMS notification
   - Push notification
   ↓
8. User receives tickets
   GET /api/v1/bookings/booking-789/tickets
```

### Cancellation Flow

```
1. User requests cancellation
   POST /api/v1/bookings/booking-789/cancel
   ↓
2. Check cancellation policy
   - Time until event
   - Refund eligibility
   ↓
3. Cancel booking
   - Update booking status to 'cancelled'
   - Release seats (mark as available)
   - Process refund (if eligible)
   ↓
4. Send notifications
   - Cancellation confirmation
   - Refund details (if applicable)
```

### Lock Expiry Flow

```
1. Background job runs (every minute)
   ↓
2. Find expired locks
   SELECT * FROM seat_locks WHERE lock_expiry < NOW()
   ↓
3. For each expired lock:
   - Release Redis lock
   - Update seat status to 'available'
   - Delete lock record
   - Notify user (optional)
   ↓
4. If booking exists but unpaid:
   - Mark booking as 'expired'
   - Release all associated locks
```

---

## Additional Features

### 1. Waitlist System
```sql
CREATE TABLE waitlist (
    waitlist_id UUID PRIMARY KEY,
    event_id UUID REFERENCES events(event_id),
    user_id UUID REFERENCES users(user_id),
    seat_preferences JSONB, -- Preferred seats
    created_at TIMESTAMP DEFAULT NOW(),
    notified_at TIMESTAMP,
    UNIQUE(event_id, user_id)
);
```

### 2. Group Bookings
- Allow booking multiple seats together
- Ensure adjacent seats
- Group pricing discounts

### 3. Seat Recommendations
- AI-based seat recommendations
- Consider user preferences
- Price optimization

### 4. Dynamic Pricing
```sql
CREATE TABLE pricing_rules (
    rule_id UUID PRIMARY KEY,
    event_id UUID REFERENCES events(event_id),
    rule_type VARCHAR(50), -- 'time_based', 'demand_based', 'seat_based'
    conditions JSONB,
    price_multiplier DECIMAL(3, 2),
    start_time TIMESTAMP,
    end_time TIMESTAMP
);
```

### 5. Analytics
- Booking patterns
- Popular events
- Revenue analytics
- User behavior

---

## Monitoring & Alerts

### Key Metrics
- **Booking Rate**: Bookings per minute
- **Success Rate**: Successful bookings / Total attempts
- **Payment Success Rate**: Successful payments / Total payments
- **Lock Expiry Rate**: Expired locks / Total locks
- **Response Time**: API response times
- **Error Rate**: Failed requests / Total requests

### Alerts
- High error rate (> 1%)
- Payment failures spike
- Lock expiry rate too high
- Database connection issues
- Redis cache misses
- Low seat availability for popular events

---

## Security Considerations

### 1. Input Validation
- Validate all user inputs
- Sanitize seat selections
- Prevent SQL injection

### 2. Authentication & Authorization
- JWT tokens for authentication
- Role-based access control
- Admin-only endpoints protected

### 3. Payment Security
- PCI-DSS compliance
- Tokenization for card data
- Never store full card numbers
- Use secure payment gateways

### 4. Fraud Prevention
- Rate limiting
- CAPTCHA for suspicious activity
- Monitor for bot behavior
- Transaction limits

### 5. Data Encryption
- Encrypt sensitive data at rest
- Use HTTPS for all communications
- Encrypt payment data

---

## Conclusion

This system design provides a scalable, reliable ticket booking system with:
- **Concurrency handling** to prevent double bookings
- **Two-phase booking** (lock → confirm) for better UX
- **Horizontal scalability** for high traffic
- **Payment integration** with proper error handling
- **Real-time seat availability** using caching
- **Comprehensive monitoring** and alerting

The architecture can handle millions of concurrent users and thousands of bookings per minute while maintaining data consistency and preventing race conditions.

