# Pessimistic Locking vs Optimistic Locking: In-Depth Comparison

## Table of Contents
1. [Introduction](#introduction)
2. [Pessimistic Locking - Deep Dive](#pessimistic-locking---deep-dive)
3. [Optimistic Locking - Deep Dive](#optimistic-locking---deep-dive)
4. [Side-by-Side Comparison](#side-by-side-comparison)
5. [Detailed Code Examples](#detailed-code-examples)
6. [Performance Analysis](#performance-analysis)
7. [When to Use Which](#when-to-use-which)
8. [Hybrid Approaches](#hybrid-approaches)
9. [Common Pitfalls](#common-pitfalls)
10. [Real-World Scenarios](#real-world-scenarios)

---

## Introduction

### What is Concurrency Control?

When multiple transactions access the same data simultaneously, we need mechanisms to ensure:
- **Consistency**: Data remains valid
- **Isolation**: Transactions don't interfere with each other
- **No Lost Updates**: Changes aren't overwritten

### Two Main Approaches

**Pessimistic Locking**: "I assume conflicts will happen, so I'll lock the data first"
- Lock before reading
- Block other transactions
- Guaranteed consistency

**Optimistic Locking**: "I assume conflicts are rare, so I'll check if data changed before writing"
- Read without locking
- Check for changes before writing
- Retry if conflict detected

---

## Pessimistic Locking - Deep Dive

### Core Concept

**Pessimistic locking** assumes that conflicts are likely to occur. Therefore, it **locks resources before accessing them** to prevent other transactions from modifying the data until the lock is released.

**Philosophy**: "Better safe than sorry" - Block others to prevent conflicts.

### How It Works

```
Transaction Flow:
1. BEGIN TRANSACTION
2. LOCK resource (exclusive or shared)
3. READ data (guaranteed to be consistent)
4. MODIFY data
5. COMMIT (releases lock)
```

### Types of Pessimistic Locks

#### 1. Exclusive Lock (Write Lock)

```sql
-- Exclusive lock: Only one transaction can hold it
SELECT * FROM accounts WHERE account_id = 123 FOR UPDATE;

-- Other transactions trying to lock the same row will BLOCK
-- They wait until the lock is released
```

**Characteristics:**
- Only one transaction can hold an exclusive lock
- Other transactions are blocked (must wait)
- Used for write operations
- Prevents both reads and writes by others

#### 2. Shared Lock (Read Lock)

```sql
-- Shared lock: Multiple transactions can read, but not write
SELECT * FROM accounts WHERE account_id = 123 FOR SHARE;

-- Other transactions can also acquire shared locks
-- But exclusive locks are blocked
```

**Characteristics:**
- Multiple transactions can hold shared locks
- Allows concurrent reads
- Blocks writes
- Used for read operations that need consistency

#### 3. Row-Level Locking

```sql
-- Lock specific rows
SELECT * FROM seats 
WHERE event_id = 123 
AND status = 'available'
FOR UPDATE;

-- Only locks matching rows, not entire table
```

#### 4. Table-Level Locking

```sql
-- Lock entire table (rarely used)
LOCK TABLE seats IN EXCLUSIVE MODE;

-- All operations on table are blocked
```

### Implementation Examples

#### Example 1: Bank Account Transfer (Pessimistic)

```python
def transfer_money_pessimistic(from_account, to_account, amount):
    """
    Transfer money using pessimistic locking
    """
    with db.transaction():
        # Lock both accounts (exclusive locks)
        from_acc = db.query("""
            SELECT account_id, balance
            FROM accounts
            WHERE account_id = ?
            FOR UPDATE  -- Exclusive lock
        """, from_account)
        
        to_acc = db.query("""
            SELECT account_id, balance
            FROM accounts
            WHERE account_id = ?
            FOR UPDATE  -- Exclusive lock
        """, to_account)
        
        if not from_acc or not to_acc:
            raise AccountNotFoundError()
        
        if from_acc.balance < amount:
            raise InsufficientFundsError()
        
        # Update balances (we have exclusive locks, safe to modify)
        db.execute("""
            UPDATE accounts
            SET balance = balance - ?
            WHERE account_id = ?
        """, amount, from_account)
        
        db.execute("""
            UPDATE accounts
            SET balance = balance + ?
            WHERE account_id = ?
        """, amount, to_account)
        
        # Commit releases locks
        db.commit()
```

**Timeline:**
```
Time    Transaction A                    Database                    Transaction B
─────────────────────────────────────────────────────────────────────────────────
T1      BEGIN TRANSACTION
T2      SELECT ... FOR UPDATE           →  Lock account 123
        (account 123)                   [Lock acquired]
T3                                      ←  Returns: balance = 1000
                                      [Account 123 is LOCKED]
T4                                      ←  SELECT ... FOR UPDATE  ←  Try to lock
                                        (account 123)            [BLOCKED - waiting]
T5      SELECT ... FOR UPDATE           →  Lock account 456
        (account 456)                   [Lock acquired]
T6      UPDATE account 123              →  Update: balance = 900
T7      UPDATE account 456              →  Update: balance = 1100
T8      COMMIT                         →  Release locks
T9                                      ←  Lock acquired        ←  Now can proceed
T10                                     ←  Returns: balance = 900
```

#### Example 2: Seat Booking (Pessimistic)

```python
def book_seat_pessimistic(event_id, seat_id, user_id):
    """
    Book seat using pessimistic locking
    """
    with db.transaction():
        # Lock the seat row
        seat = db.query("""
            SELECT seat_id, status, version
            FROM seats
            WHERE seat_id = ?
            AND event_id = ?
            FOR UPDATE  -- Exclusive lock
        """, seat_id, event_id)
        
        if not seat:
            raise SeatNotFoundError()
        
        if seat.status != 'available':
            raise SeatUnavailableError(f"Seat is {seat.status}")
        
        # Update seat (we have exclusive lock)
        db.execute("""
            UPDATE seats
            SET status = 'booked',
                user_id = ?,
                booked_at = NOW()
            WHERE seat_id = ?
        """, user_id, seat_id)
        
        # Create booking
        booking_id = db.execute("""
            INSERT INTO bookings (user_id, event_id, seat_id, status)
            VALUES (?, ?, ?, 'confirmed')
            RETURNING booking_id
        """, user_id, event_id, seat_id)
        
        db.commit()
        return booking_id
```

### Lock Modes and Options

#### NOWAIT - Fail Fast

```sql
-- Don't wait if lock is unavailable, fail immediately
SELECT * FROM seats WHERE seat_id = 123 FOR UPDATE NOWAIT;

-- If row is locked, throws error immediately instead of waiting
```

```python
def book_seat_nowait(event_id, seat_id, user_id):
    try:
        seat = db.query("""
            SELECT * FROM seats
            WHERE seat_id = ?
            FOR UPDATE NOWAIT
        """, seat_id)
    except db.LockNotAvailableError:
        raise SeatUnavailableError("Seat is currently being booked")
```

#### SKIP LOCKED - Skip Locked Rows

```sql
-- Skip rows that are already locked
SELECT * FROM seats
WHERE event_id = 123
AND status = 'available'
FOR UPDATE SKIP LOCKED
LIMIT 5;

-- Returns only available (unlocked) seats
```

```python
def find_available_seats(event_id, count=5):
    """
    Find available seats, skipping locked ones
    """
    seats = db.query("""
        SELECT seat_id, row_number, seat_number
        FROM seats
        WHERE event_id = ?
        AND status = 'available'
        FOR UPDATE SKIP LOCKED
        LIMIT ?
    """, event_id, count)
    
    return seats
```

### Lock Timeout

```sql
-- Set lock timeout (PostgreSQL)
SET lock_timeout = '5s';

-- If lock cannot be acquired within 5 seconds, transaction fails
```

```python
def book_seat_with_timeout(event_id, seat_id, user_id, timeout_seconds=5):
    with db.transaction():
        # Set lock timeout
        db.execute("SET lock_timeout = ?", f"{timeout_seconds}s")
        
        try:
            seat = db.query("""
                SELECT * FROM seats
                WHERE seat_id = ?
                FOR UPDATE
            """, seat_id)
        except db.LockTimeoutError:
            raise SeatUnavailableError("Could not acquire lock in time")
```

### Deadlock Prevention

```python
def transfer_money_safe(from_account, to_account, amount):
    """
    Prevent deadlocks by always locking in same order
    """
    # Always lock smaller account_id first
    if from_account < to_account:
        first = from_account
        second = to_account
    else:
        first = to_account
        second = from_account
    
    with db.transaction():
        # Lock in consistent order
        acc1 = db.query("SELECT * FROM accounts WHERE account_id = ? FOR UPDATE", first)
        acc2 = db.query("SELECT * FROM accounts WHERE account_id = ? FOR UPDATE", second)
        
        # ... rest of transfer logic
```

### Pros of Pessimistic Locking

✅ **Guaranteed Consistency**: No conflicts possible
✅ **Simple Logic**: No retry mechanisms needed
✅ **Predictable**: Always works the same way
✅ **Database Handles It**: Leverages database locking
✅ **Good for High Conflict**: When conflicts are frequent

### Cons of Pessimistic Locking

❌ **Blocks Other Transactions**: Lower concurrency
❌ **Deadlock Risk**: Can cause deadlocks
❌ **Performance Impact**: Locks held for entire transaction
❌ **Doesn't Scale Well**: Under high concurrency
❌ **Resource Consumption**: Locks consume database resources

---

## Optimistic Locking - Deep Dive

### Core Concept

**Optimistic locking** assumes that conflicts are rare. It allows multiple transactions to read data simultaneously, but **checks if data changed before writing**. If a conflict is detected, the transaction retries.

**Philosophy**: "Trust but verify" - Check for changes before committing.

### How It Works

```
Transaction Flow:
1. BEGIN TRANSACTION
2. READ data (no lock) + remember version/timestamp
3. MODIFY data in memory
4. UPDATE with version check
   - If version matches → Success
   - If version changed → Conflict! Retry or fail
5. COMMIT
```

### Version-Based Optimistic Locking

#### Database Schema

```sql
CREATE TABLE accounts (
    account_id UUID PRIMARY KEY,
    balance DECIMAL(10, 2),
    version INT DEFAULT 0,  -- Version number
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE seats (
    seat_id UUID PRIMARY KEY,
    event_id UUID,
    status VARCHAR(20),
    version INT DEFAULT 0,  -- Version number
    updated_at TIMESTAMP DEFAULT NOW()
);
```

#### Implementation

```python
def transfer_money_optimistic(from_account, to_account, amount):
    """
    Transfer money using optimistic locking
    """
    max_retries = 3
    retry_count = 0
    
    while retry_count < max_retries:
        try:
            with db.transaction():
                # Read both accounts (no locks)
                from_acc = db.query("""
                    SELECT account_id, balance, version
                    FROM accounts
                    WHERE account_id = ?
                """, from_account)
                
                to_acc = db.query("""
                    SELECT account_id, balance, version
                    FROM accounts
                    WHERE account_id = ?
                """, to_account)
                
                if not from_acc or not to_acc:
                    raise AccountNotFoundError()
                
                if from_acc.balance < amount:
                    raise InsufficientFundsError()
                
                # Remember versions
                from_version = from_acc.version
                to_version = to_acc.version
                
                # Try to update with version check
                rows_updated_from = db.execute("""
                    UPDATE accounts
                    SET balance = balance - ?,
                        version = version + 1
                    WHERE account_id = ?
                    AND version = ?  -- Only update if version matches!
                """, amount, from_account, from_version)
                
                if rows_updated_from == 0:
                    # Version changed - conflict detected
                    raise ConflictError("Account was modified")
                
                rows_updated_to = db.execute("""
                    UPDATE accounts
                    SET balance = balance + ?,
                        version = version + 1
                    WHERE account_id = ?
                    AND version = ?  -- Only update if version matches!
                """, amount, to_account, to_version)
                
                if rows_updated_to == 0:
                    # Version changed - conflict detected
                    raise ConflictError("Account was modified")
                
                db.commit()
                return  # Success!
                
        except ConflictError:
            retry_count += 1
            if retry_count >= max_retries:
                raise ConcurrentModificationError("Too many conflicts")
            # Exponential backoff
            time.sleep(0.1 * (2 ** retry_count))
            continue
```

**Timeline:**
```
Time    Transaction A                    Database                    Transaction B
─────────────────────────────────────────────────────────────────────────────────
T1      BEGIN TRANSACTION
T2      SELECT account 123              →  Read account 123
                                      ←  Returns: balance=1000, version=5
T3      SELECT account 456              →  Read account 456
                                      ←  Returns: balance=500, version=3
T4                                      ←  SELECT account 123  ←  Read account 123
                                      ←  Returns: balance=1000, version=5
T5      UPDATE account 123              →  Try: UPDATE ... WHERE version=5
        WHERE version=5                 [Success! version=6]
T6      UPDATE account 456              →  Try: UPDATE ... WHERE version=3
        WHERE version=3                 [Success! version=4]
T7      COMMIT                         →  Commit successful
T8                                      ←  UPDATE account 123  ←  Try: UPDATE
                                        WHERE version=5        [FAILED! version is 6]
T9                                      ←  Retry: Read again
                                      ←  Returns: balance=900, version=6
T10                                     ←  Update with new version
```

#### Seat Booking (Optimistic)

```python
def book_seat_optimistic(event_id, seat_id, user_id):
    """
    Book seat using optimistic locking
    """
    max_retries = 3
    retry_count = 0
    
    while retry_count < max_retries:
        try:
            with db.transaction():
                # Read seat (no lock)
                seat = db.query("""
                    SELECT seat_id, status, version
                    FROM seats
                    WHERE seat_id = ?
                    AND event_id = ?
                """, seat_id, event_id)
                
                if not seat:
                    raise SeatNotFoundError()
                
                if seat.status != 'available':
                    raise SeatUnavailableError(f"Seat is {seat.status}")
                
                current_version = seat.version
                
                # Try to update with version check
                rows_updated = db.execute("""
                    UPDATE seats
                    SET status = 'booked',
                        user_id = ?,
                        version = version + 1,
                        booked_at = NOW()
                    WHERE seat_id = ?
                    AND version = ?  -- Version check!
                    AND status = 'available'
                """, user_id, seat_id, current_version)
                
                if rows_updated == 0:
                    # Conflict detected - version changed or status changed
                    raise ConflictError("Seat was modified by another transaction")
                
                # Create booking
                booking_id = db.execute("""
                    INSERT INTO bookings (user_id, event_id, seat_id, status)
                    VALUES (?, ?, ?, 'confirmed')
                    RETURNING booking_id
                """, user_id, event_id, seat_id)
                
                db.commit()
                return booking_id
                
        except ConflictError:
            retry_count += 1
            if retry_count >= max_retries:
                raise SeatUnavailableError("Seat was booked by another user")
            # Exponential backoff
            time.sleep(0.1 * (2 ** retry_count))
            continue
```

### Timestamp-Based Optimistic Locking

Instead of version numbers, use timestamps:

```sql
CREATE TABLE seats (
    seat_id UUID PRIMARY KEY,
    status VARCHAR(20),
    updated_at TIMESTAMP DEFAULT NOW()  -- Timestamp instead of version
);
```

```python
def book_seat_optimistic_timestamp(event_id, seat_id, user_id):
    """
    Optimistic locking using timestamp
    """
    seat = db.query("""
        SELECT seat_id, status, updated_at
        FROM seats
        WHERE seat_id = ?
    """, seat_id)
    
    if seat.status != 'available':
        raise SeatUnavailableError()
    
    original_timestamp = seat.updated_at
    
    # Update only if timestamp hasn't changed
    rows_updated = db.execute("""
        UPDATE seats
        SET status = 'booked',
            user_id = ?,
            updated_at = NOW()
        WHERE seat_id = ?
        AND updated_at = ?  -- Timestamp check
        AND status = 'available'
    """, user_id, seat_id, original_timestamp)
    
    if rows_updated == 0:
        raise ConcurrentModificationError("Seat was modified")
```

### Hash-Based Optimistic Locking

Use hash of all fields:

```python
import hashlib
import json

def get_row_hash(row):
    """
    Generate hash of row data
    """
    data = {
        'status': row.status,
        'user_id': row.user_id,
        'balance': str(row.balance)
    }
    return hashlib.md5(json.dumps(data, sort_keys=True).encode()).hexdigest()

def update_with_hash_check(table, row_id, new_data, expected_hash):
    """
    Update only if hash matches
    """
    rows_updated = db.execute(f"""
        UPDATE {table}
        SET {', '.join([f"{k} = ?" for k in new_data.keys()])}
        WHERE id = ?
        AND MD5(CONCAT_WS('|', {', '.join(new_data.keys())})) = ?
    """, *new_data.values(), row_id, expected_hash)
    
    return rows_updated > 0
```

### Pros of Optimistic Locking

✅ **High Concurrency**: No blocking, multiple reads allowed
✅ **Better Performance**: Under low conflict scenarios
✅ **No Deadlocks**: No locks = no deadlocks
✅ **Scalable**: Works well with read-heavy workloads
✅ **Non-Blocking**: Reads never block

### Cons of Optimistic Locking

❌ **Retry Logic Required**: Must handle conflicts
❌ **Wasted Work**: May retry multiple times
❌ **Not Suitable for High Conflict**: Many retries = poor performance
❌ **More Complex**: Error handling and retry logic
❌ **Stale Reads**: May read outdated data (but detects before write)

---

## Side-by-Side Comparison

### Conceptual Comparison

| Aspect | Pessimistic Locking | Optimistic Locking |
|--------|---------------------|-------------------|
| **Philosophy** | "Lock first, then read" | "Read first, verify later" |
| **Assumption** | Conflicts are likely | Conflicts are rare |
| **Locking** | Locks before read | No locks on read |
| **Conflict Detection** | Prevents conflicts | Detects conflicts |
| **Blocking** | Blocks other transactions | Non-blocking |
| **Retry Needed** | No | Yes |
| **Complexity** | Simple | More complex |

### Performance Comparison

| Scenario | Pessimistic | Optimistic | Winner |
|----------|-------------|------------|--------|
| **Low Conflict** | Blocks unnecessarily | No blocking | Optimistic |
| **High Conflict** | Blocks but works | Many retries | Pessimistic |
| **Read-Heavy** | Blocks readers | Concurrent reads | Optimistic |
| **Write-Heavy** | Serializes writes | Many conflicts | Pessimistic |
| **Long Transactions** | Holds locks long | No locks | Optimistic |
| **Short Transactions** | Quick lock/release | Overhead of version check | Pessimistic |

### Code Complexity

#### Pessimistic (Simple)

```python
def update_balance_pessimistic(account_id, amount):
    with db.transaction():
        account = db.query("SELECT * FROM accounts WHERE id = ? FOR UPDATE", account_id)
        db.execute("UPDATE accounts SET balance = balance + ? WHERE id = ?", amount, account_id)
        db.commit()
```

#### Optimistic (More Complex)

```python
def update_balance_optimistic(account_id, amount, max_retries=3):
    for attempt in range(max_retries):
        try:
            with db.transaction():
                account = db.query("SELECT balance, version FROM accounts WHERE id = ?", account_id)
                rows = db.execute("""
                    UPDATE accounts 
                    SET balance = balance + ?, version = version + 1
                    WHERE id = ? AND version = ?
                """, amount, account_id, account.version)
                if rows == 0:
                    raise ConflictError()
                db.commit()
                return
        except ConflictError:
            if attempt == max_retries - 1:
                raise
            time.sleep(0.1 * (2 ** attempt))
```

### Resource Usage

| Resource | Pessimistic | Optimistic |
|----------|-------------|------------|
| **Database Locks** | High (many locks held) | None |
| **Memory** | Low | Low |
| **CPU** | Low (blocking) | Medium (retries) |
| **Network** | Low | Medium (retries) |
| **Throughput** | Lower (blocking) | Higher (if low conflict) |

---

## Detailed Code Examples

### Example 1: Inventory Management

#### Pessimistic Approach

```python
def reduce_inventory_pessimistic(product_id, quantity):
    """
    Reduce inventory using pessimistic locking
    """
    with db.transaction():
        # Lock the product row
        product = db.query("""
            SELECT product_id, stock_quantity
            FROM products
            WHERE product_id = ?
            FOR UPDATE
        """, product_id)
        
        if not product:
            raise ProductNotFoundError()
        
        if product.stock_quantity < quantity:
            raise InsufficientStockError()
        
        # Update stock
        db.execute("""
            UPDATE products
            SET stock_quantity = stock_quantity - ?
            WHERE product_id = ?
        """, quantity, product_id)
        
        # Log the transaction
        db.execute("""
            INSERT INTO inventory_logs (product_id, quantity, action)
            VALUES (?, ?, 'sold')
        """, product_id, quantity)
        
        db.commit()
```

#### Optimistic Approach

```python
def reduce_inventory_optimistic(product_id, quantity, max_retries=3):
    """
    Reduce inventory using optimistic locking
    """
    for attempt in range(max_retries):
        try:
            with db.transaction():
                # Read product (no lock)
                product = db.query("""
                    SELECT product_id, stock_quantity, version
                    FROM products
                    WHERE product_id = ?
                """, product_id)
                
                if not product:
                    raise ProductNotFoundError()
                
                if product.stock_quantity < quantity:
                    raise InsufficientStockError()
                
                current_version = product.version
                
                # Try to update with version check
                rows_updated = db.execute("""
                    UPDATE products
                    SET stock_quantity = stock_quantity - ?,
                        version = version + 1
                    WHERE product_id = ?
                    AND version = ?
                    AND stock_quantity >= ?
                """, quantity, product_id, current_version, quantity)
                
                if rows_updated == 0:
                    # Conflict or insufficient stock
                    raise ConflictError("Product was modified or stock insufficient")
                
                # Log the transaction
                db.execute("""
                    INSERT INTO inventory_logs (product_id, quantity, action)
                    VALUES (?, ?, 'sold')
                """, product_id, quantity)
                
                db.commit()
                return  # Success
                
        except ConflictError:
            if attempt == max_retries - 1:
                raise InsufficientStockError("Could not update inventory after retries")
            time.sleep(0.1 * (2 ** attempt))
            continue
```

### Example 2: Voting System

#### Pessimistic Approach

```python
def vote_pessimistic(poll_id, option_id, user_id):
    """
    Record a vote using pessimistic locking
    """
    with db.transaction():
        # Check if user already voted
        existing_vote = db.query("""
            SELECT vote_id FROM votes
            WHERE poll_id = ? AND user_id = ?
            FOR UPDATE
        """, poll_id, user_id)
        
        if existing_vote:
            raise AlreadyVotedError()
        
        # Lock the option to update vote count
        option = db.query("""
            SELECT option_id, vote_count
            FROM poll_options
            WHERE option_id = ?
            FOR UPDATE
        """, option_id)
        
        # Record vote
        db.execute("""
            INSERT INTO votes (poll_id, option_id, user_id)
            VALUES (?, ?, ?)
        """, poll_id, option_id, user_id)
        
        # Update vote count
        db.execute("""
            UPDATE poll_options
            SET vote_count = vote_count + 1
            WHERE option_id = ?
        """, option_id)
        
        db.commit()
```

#### Optimistic Approach

```python
def vote_optimistic(poll_id, option_id, user_id, max_retries=3):
    """
    Record a vote using optimistic locking
    """
    for attempt in range(max_retries):
        try:
            with db.transaction():
                # Check if user already voted (no lock)
                existing_vote = db.query("""
                    SELECT vote_id FROM votes
                    WHERE poll_id = ? AND user_id = ?
                """, poll_id, user_id)
                
                if existing_vote:
                    raise AlreadyVotedError()
                
                # Read option with version
                option = db.query("""
                    SELECT option_id, vote_count, version
                    FROM poll_options
                    WHERE option_id = ?
                """, option_id)
                
                current_version = option.version
                
                # Record vote
                db.execute("""
                    INSERT INTO votes (poll_id, option_id, user_id)
                    VALUES (?, ?, ?)
                """, poll_id, option_id, user_id)
                
                # Update vote count with version check
                rows_updated = db.execute("""
                    UPDATE poll_options
                    SET vote_count = vote_count + 1,
                        version = version + 1
                    WHERE option_id = ?
                    AND version = ?
                """, option_id, current_version)
                
                if rows_updated == 0:
                    raise ConflictError("Option was modified")
                
                db.commit()
                return
                
        except ConflictError:
            if attempt == max_retries - 1:
                raise VotingError("Could not record vote after retries")
            time.sleep(0.1 * (2 ** attempt))
            continue
```

---

## Performance Analysis

### Throughput Comparison

```
Scenario: 1000 concurrent requests updating same account

Pessimistic Locking:
- Request 1: Acquires lock, updates, releases (100ms)
- Request 2-1000: Wait in queue
- Total time: 100ms × 1000 = 100 seconds
- Throughput: 10 requests/second

Optimistic Locking (assuming 10% conflict rate):
- Request 1: Updates successfully (50ms)
- Request 2-100: 90 succeed, 10 conflict and retry
- Retries: 10 requests retry (50ms each)
- Total time: ~100ms for batch
- Throughput: ~900 requests/second
```

### Latency Comparison

```
Pessimistic:
- No conflict: 50ms (lock + update)
- With wait: 50ms + wait_time (could be seconds)

Optimistic:
- No conflict: 30ms (read + update, no lock overhead)
- With conflict: 30ms + retry_time (usually < 100ms)
```

### Resource Usage

```
Pessimistic:
- Database locks: High (many held simultaneously)
- CPU: Low (blocking, less work)
- Memory: Low
- Network: Low

Optimistic:
- Database locks: None
- CPU: Medium (retry logic)
- Memory: Low
- Network: Medium (retries)
```

---

## When to Use Which

### Use Pessimistic Locking When:

1. **High Conflict Rate**
   - Many transactions updating same data
   - Example: Flash sale, limited inventory

2. **Critical Data Integrity**
   - Cannot tolerate any conflicts
   - Example: Financial transactions, medical records

3. **Short Transactions**
   - Quick lock and release
   - Example: Simple updates

4. **Simple Implementation Needed**
   - Don't want retry logic
   - Example: Prototype, simple systems

5. **Consistent Performance**
   - Predictable behavior
   - Example: Real-time systems

### Use Optimistic Locking When:

1. **Low Conflict Rate**
   - Conflicts are rare
   - Example: User profile updates, blog posts

2. **Read-Heavy Workloads**
   - Many reads, few writes
   - Example: Content management systems

3. **High Concurrency Needed**
   - Need to support many concurrent users
   - Example: Social media platforms

4. **Long Transactions**
   - Don't want to hold locks for long
   - Example: Complex business logic

5. **Distributed Systems**
   - Multiple application servers
   - Example: Microservices architecture

### Decision Matrix

```
High Conflict + Short Transaction → Pessimistic
High Conflict + Long Transaction → Optimistic (or hybrid)
Low Conflict + Any Transaction → Optimistic
Critical Data + Any Scenario → Pessimistic
High Concurrency + Low Conflict → Optimistic
```

---

## Hybrid Approaches

### Combine Both Strategies

```python
def update_balance_hybrid(account_id, amount):
    """
    Hybrid approach: Try optimistic first, fallback to pessimistic
    """
    # First attempt: Optimistic (fast path)
    try:
        return update_balance_optimistic(account_id, amount, max_retries=1)
    except ConflictError:
        # Fallback: Pessimistic (slow but guaranteed)
        return update_balance_pessimistic(account_id, amount)
```

### Conditional Locking

```python
def update_seat_conditional(event_id, seat_id, user_id, conflict_threshold=0.1):
    """
    Use pessimistic if conflict rate is high, optimistic otherwise
    """
    conflict_rate = get_conflict_rate(event_id, seat_id)
    
    if conflict_rate > conflict_threshold:
        # High conflict - use pessimistic
        return book_seat_pessimistic(event_id, seat_id, user_id)
    else:
        # Low conflict - use optimistic
        return book_seat_optimistic(event_id, seat_id, user_id)
```

### Read with Optimistic, Write with Pessimistic

```python
def transfer_money_hybrid(from_account, to_account, amount):
    """
    Read optimistically, write pessimistically
    """
    # Read without locks (optimistic)
    from_acc = db.query("SELECT balance, version FROM accounts WHERE id = ?", from_account)
    to_acc = db.query("SELECT balance, version FROM accounts WHERE id = ?", to_account)
    
    # Validate
    if from_acc.balance < amount:
        raise InsufficientFundsError()
    
    # Write with locks (pessimistic)
    with db.transaction():
        # Re-read with lock to ensure consistency
        from_acc = db.query("SELECT * FROM accounts WHERE id = ? FOR UPDATE", from_account)
        to_acc = db.query("SELECT * FROM accounts WHERE id = ? FOR UPDATE", to_account)
        
        # Double-check
        if from_acc.balance < amount:
            raise InsufficientFundsError()
        
        # Update
        db.execute("UPDATE accounts SET balance = balance - ? WHERE id = ?", amount, from_account)
        db.execute("UPDATE accounts SET balance = balance + ? WHERE id = ?", amount, to_account)
        db.commit()
```

---

## Common Pitfalls

### Pessimistic Locking Pitfalls

#### 1. Deadlocks

```python
# WRONG: Different lock order
def transfer_A_to_B(account_a, account_b, amount):
    lock_a = acquire_lock(account_a)
    lock_b = acquire_lock(account_b)
    # ... transfer

def transfer_B_to_A(account_b, account_a, amount):
    lock_b = acquire_lock(account_b)  # Different order!
    lock_a = acquire_lock(account_a)
    # ... transfer

# Can cause deadlock if both run simultaneously
```

**Solution**: Always lock in same order

```python
def acquire_locks_ordered(account1, account2):
    if account1 < account2:
        return acquire_lock(account1), acquire_lock(account2)
    else:
        return acquire_lock(account2), acquire_lock(account1)
```

#### 2. Long-Held Locks

```python
# WRONG: Holding lock during external API call
def book_seat_bad(event_id, seat_id, user_id):
    with db.transaction():
        seat = db.query("SELECT * FROM seats WHERE id = ? FOR UPDATE", seat_id)
        # Lock held here...
        payment_result = payment_gateway.charge(user_id, amount)  # Takes 5 seconds!
        # Lock still held...
        db.execute("UPDATE seats SET status = 'booked' WHERE id = ?", seat_id)
```

**Solution**: Two-phase commit or release lock before external call

#### 3. Locking Too Much

```python
# WRONG: Locking entire table
def update_seat_bad(seat_id):
    db.execute("LOCK TABLE seats IN EXCLUSIVE MODE")
    # ... update
```

**Solution**: Lock only necessary rows

### Optimistic Locking Pitfalls

#### 1. Infinite Retry Loops

```python
# WRONG: No retry limit
def update_balance_bad(account_id, amount):
    while True:  # Infinite loop!
        try:
            # ... update with version check
            return
        except ConflictError:
            continue  # Retry forever
```

**Solution**: Always have retry limit and backoff

#### 2. Ignoring Version in WHERE Clause

```python
# WRONG: Not checking version
def update_seat_bad(seat_id, user_id):
    db.execute("""
        UPDATE seats
        SET status = 'booked', user_id = ?
        WHERE seat_id = ?
        -- Missing: AND version = ?
    """, user_id, seat_id)
```

**Solution**: Always include version check

#### 3. Stale Data Issues

```python
# WRONG: Using stale data after conflict
def transfer_money_bad(from_account, to_account, amount):
    from_acc = db.query("SELECT balance FROM accounts WHERE id = ?", from_account)
    # ... some time passes, account updated by another transaction
    if from_acc.balance < amount:  # Using stale data!
        raise InsufficientFundsError()
```

**Solution**: Re-read after conflict detection

---

## Real-World Scenarios

### Scenario 1: E-Commerce Inventory (Optimistic)

**Why Optimistic?**
- Low conflict rate (many products)
- High read traffic (browsing)
- Need high concurrency

```python
def purchase_item_optimistic(product_id, quantity, user_id):
    max_retries = 3
    for attempt in range(max_retries):
        try:
            product = db.query("SELECT stock, version FROM products WHERE id = ?", product_id)
            if product.stock < quantity:
                raise OutOfStockError()
            
            rows = db.execute("""
                UPDATE products
                SET stock = stock - ?, version = version + 1
                WHERE id = ? AND version = ? AND stock >= ?
            """, quantity, product_id, product.version, quantity)
            
            if rows == 0:
                raise ConflictError()
            
            create_order(product_id, quantity, user_id)
            return
            
        except ConflictError:
            if attempt == max_retries - 1:
                raise OutOfStockError()
            time.sleep(0.1 * (2 ** attempt))
```

### Scenario 2: Banking Transfer (Pessimistic)

**Why Pessimistic?**
- High conflict rate (same accounts)
- Critical data integrity
- Cannot tolerate errors

```python
def transfer_money_pessimistic(from_account, to_account, amount):
    # Lock in consistent order
    if from_account < to_account:
        first, second = from_account, to_account
    else:
        first, second = to_account, from_account
    
    with db.transaction():
        acc1 = db.query("SELECT * FROM accounts WHERE id = ? FOR UPDATE", first)
        acc2 = db.query("SELECT * FROM accounts WHERE id = ? FOR UPDATE", second)
        
        if acc1.balance < amount:
            raise InsufficientFundsError()
        
        db.execute("UPDATE accounts SET balance = balance - ? WHERE id = ?", amount, from_account)
        db.execute("UPDATE accounts SET balance = balance + ? WHERE id = ?", amount, to_account)
        db.commit()
```

### Scenario 3: Ticket Booking (Two-Phase with Optimistic Check)

**Why Hybrid?**
- Need to handle high concurrency
- But also need consistency

```python
def book_ticket_hybrid(event_id, seat_id, user_id):
    # Phase 1: Quick optimistic check
    seat = db.query("SELECT status, version FROM seats WHERE id = ?", seat_id)
    if seat.status != 'available':
        raise SeatUnavailableError()
    
    # Phase 2: Pessimistic lock for booking
    with db.transaction():
        seat = db.query("SELECT * FROM seats WHERE id = ? FOR UPDATE", seat_id)
        if seat.status != 'available':
            raise SeatUnavailableError()
        
        db.execute("UPDATE seats SET status = 'locked' WHERE id = ?", seat_id)
        booking_id = create_booking(event_id, seat_id, user_id)
        db.commit()
    
    return booking_id
```

---

## Conclusion

### Key Takeaways

1. **Pessimistic Locking**:
   - Lock first, then read/write
   - Blocks other transactions
   - Simple but lower concurrency
   - Best for high conflict scenarios

2. **Optimistic Locking**:
   - Read first, verify before write
   - Non-blocking, higher concurrency
   - Requires retry logic
   - Best for low conflict scenarios

3. **Choose Based On**:
   - Conflict rate
   - Transaction duration
   - Concurrency requirements
   - Data criticality

4. **Best Practice**:
   - Consider hybrid approaches
   - Monitor conflict rates
   - Adjust strategy based on metrics

### Final Recommendation

For most production systems:
- **Start with Optimistic** (better performance, scalable)
- **Add Pessimistic** for critical paths (financial, medical)
- **Monitor and adjust** based on actual conflict rates
- **Use hybrid** for best of both worlds

