# Google Docs System Design: Operational Transformation & Differential Synchronization

## Table of Contents
1. [Introduction](#introduction)
2. [Problem Statement](#problem-statement)
3. [Core Challenges](#core-challenges)
4. [Operational Transformation (OT)](#operational-transformation-ot)
5. [Differential Synchronization (DiffSync)](#differential-synchronization-diffsync)
6. [System Architecture](#system-architecture)
7. [Data Models](#data-models)
8. [Conflict Resolution Strategies](#conflict-resolution-strategies)
9. [Implementation Details](#implementation-details)
10. [Scalability Considerations](#scalability-considerations)
11. [Comparison: OT vs DiffSync](#comparison-ot-vs-diffsync)
12. [Real-World Examples](#real-world-examples)

---

## Introduction

### What is Google Docs?

Google Docs is a real-time collaborative document editing system that allows multiple users to edit the same document simultaneously. The key challenge is maintaining consistency and resolving conflicts when multiple users make changes at the same time.

### Key Requirements

1. **Real-Time Collaboration**: Multiple users can edit simultaneously
2. **Consistency**: All users see the same final state
3. **Low Latency**: Changes appear quickly (< 100ms)
4. **Offline Support**: Work offline, sync when online
5. **Conflict Resolution**: Handle simultaneous edits intelligently
6. **Scalability**: Support millions of concurrent users
7. **High Availability**: 99.9%+ uptime

---

## Problem Statement

### The Core Problem

**How do you allow multiple users to edit the same document simultaneously while maintaining consistency?**

### Example Scenario

```
User A: "Hello World"
         ^
         Cursor at position 0

User B: "Hello World"
                ^
                Cursor at position 5

User A types "Hi " → "Hi Hello World"
User B types "Beautiful " → "Hello Beautiful World"

Expected Result: "Hi Hello Beautiful World"
```

### Challenges

1. **Concurrent Edits**: Multiple users editing simultaneously
2. **Network Latency**: Operations arrive out of order
3. **Partial Failures**: Some operations may be lost
4. **Offline Editing**: Users may edit while offline
5. **Conflict Resolution**: How to merge conflicting changes

---

## Core Challenges

### Challenge 1: Operation Ordering

```
Timeline:
T1: User A inserts "Hi " at position 0
T2: User B inserts "Beautiful " at position 5

But due to network:
Server receives: T2 first, then T1
```

**Problem**: Operations arrive out of order, causing incorrect results.

### Challenge 2: Position Shifting

```
Initial: "Hello World"
         [0][1][2][3][4][5][6][7][8][9][10]
          H  e  l  l  o     W  o  r  l  d

User A inserts "Hi " at position 0:
Result: "Hi Hello World"
         [0][1][2][3][4][5][6][7][8][9][10][11][12][13]
          H  i     H  e  l  l  o     W  o  r  l  d

User B wants to insert "Beautiful " at position 5:
But position 5 now points to 'e' instead of 'W'!
```

**Problem**: Positions shift when operations are applied, making later operations invalid.

### Challenge 3: Conflict Resolution

```
User A: Delete "Hello"
User B: Change "Hello" to "Hi"

What should the result be?
```

**Problem**: Conflicting operations need intelligent merging.

---

## Operational Transformation (OT)

### What is Operational Transformation?

**Operational Transformation (OT)** is an algorithm that transforms operations to account for concurrent changes, ensuring all replicas converge to the same state.

### Core Concept

Instead of applying operations directly, **transform** them based on concurrent operations that happened before.

### Basic Operations

```java
// Three basic operations
public enum OperationType {
    INSERT,  // Insert text at position
    DELETE,  // Delete text at position
    RETAIN   // Keep text (for formatting)
}

public class Operation {
    private OperationType type;
    private int position;
    private String content; // For INSERT
    private int length;     // For DELETE/RETAIN
}
```

### OT Algorithm Steps

#### Step 1: Define Operations

```java
public class TextOperation {
    private List<Operation> operations;
    
    // Insert "Hi " at position 0
    public static TextOperation insert(int position, String text) {
        TextOperation op = new TextOperation();
        op.operations.add(new Operation(OperationType.RETAIN, position));
        op.operations.add(new Operation(OperationType.INSERT, text));
        return op;
    }
    
    // Delete 5 characters starting at position 0
    public static TextOperation delete(int position, int length) {
        TextOperation op = new TextOperation();
        op.operations.add(new Operation(OperationType.RETAIN, position));
        op.operations.add(new Operation(OperationType.DELETE, length));
        return op;
    }
}
```

#### Step 2: Transform Operations

```java
public class OperationalTransformer {
    
    /**
     * Transform operation op1 against operation op2
     * Returns op1' such that: apply(op2) then apply(op1') = apply(op1) then apply(op2')
     */
    public static TextOperation transform(
            TextOperation op1, 
            TextOperation op2, 
            boolean priority) {
        
        // Priority determines which operation wins in case of conflict
        // priority = true means op1 has priority
        
        TextOperation result = new TextOperation();
        int i1 = 0, i2 = 0;
        int pos1 = 0, pos2 = 0;
        
        while (i1 < op1.operations.size() || i2 < op2.operations.size()) {
            // Handle different cases based on operation types
            // This is a simplified version - real implementation is more complex
            
            if (i1 >= op1.operations.size()) {
                // op1 is done, copy remaining op2
                result.operations.add(op2.operations.get(i2++));
            } else if (i2 >= op2.operations.size()) {
                // op2 is done, copy remaining op1
                result.operations.add(op1.operations.get(i1++));
            } else {
                Operation o1 = op1.operations.get(i1);
                Operation o2 = op2.operations.get(i2);
                
                // Transform based on operation types
                if (o1.type == OperationType.INSERT && o2.type == OperationType.INSERT) {
                    // Both inserting - priority determines order
                    if (priority) {
                        result.operations.add(o1);
                        result.operations.add(o2);
                    } else {
                        result.operations.add(o2);
                        result.operations.add(o1);
                    }
                    i1++;
                    i2++;
                } else if (o1.type == OperationType.DELETE && o2.type == OperationType.DELETE) {
                    // Both deleting - transform positions
                    // Implementation depends on positions
                    // ... complex logic ...
                } else {
                    // Different operation types - simpler transformation
                    // ... implementation ...
                }
            }
        }
        
        return result;
    }
}
```

### OT Example: Simple Case

```
Initial State: "Hello World"
               [0][1][2][3][4][5][6][7][8][9][10]
                H  e  l  l  o     W  o  r  l  d

User A: Insert "Hi " at position 0
Operation A: INSERT(0, "Hi ")

User B: Insert "Beautiful " at position 5 (before "World")
Operation B: INSERT(5, "Beautiful ")

Timeline:
T1: User A sends Operation A
T2: User B sends Operation B
T3: Server receives Operation A, applies it
    State: "Hi Hello World"
T4: Server receives Operation B
    But position 5 is now wrong! (was 'W', now 'e')
    
Solution: Transform Operation B against Operation A
Operation B' = TRANSFORM(Operation B, Operation A)
Operation B': INSERT(8, "Beautiful ") // Position adjusted

Apply Operation B': "Hi Hello Beautiful World" ✓
```

### OT Transformation Rules

#### Rule 1: Insert vs Insert

```
Operation A: INSERT(pos1, text1)
Operation B: INSERT(pos2, text2)

If pos1 < pos2:
  B' = INSERT(pos2 + len(text1), text2)
Else if pos1 > pos2:
  B' = INSERT(pos2, text2) // No change
Else:
  B' = INSERT(pos2, text2) // Priority determines order
```

#### Rule 2: Insert vs Delete

```
Operation A: INSERT(pos1, text1)
Operation B: DELETE(pos2, len)

If pos1 <= pos2:
  B' = DELETE(pos2 + len(text1), len)
Else:
  B' = DELETE(pos2, len) // No change
```

#### Rule 3: Delete vs Delete

```
Operation A: DELETE(pos1, len1)
Operation B: DELETE(pos2, len2)

If pos1 + len1 <= pos2:
  B' = DELETE(pos2 - len1, len2)
Else if pos2 + len2 <= pos1:
  B' = DELETE(pos2, len2) // No change
Else:
  // Overlapping deletes - complex case
  // Need to handle carefully
```

### OT Implementation Example

```java
public class Document {
    private StringBuilder content;
    private int version; // Operation version
    
    public Document(String initialContent) {
        this.content = new StringBuilder(initialContent);
        this.version = 0;
    }
    
    public void applyOperation(TextOperation op) {
        int pos = 0;
        for (Operation o : op.operations) {
            switch (o.type) {
                case RETAIN:
                    pos += o.length;
                    break;
                case INSERT:
                    content.insert(pos, o.content);
                    pos += o.content.length();
                    break;
                case DELETE:
                    content.delete(pos, pos + o.length);
                    break;
            }
        }
        this.version++;
    }
    
    public TextOperation createOperation(String newContent) {
        // Generate operation to transform current content to new content
        // This is a simplified version
        TextOperation op = new TextOperation();
        // ... diff algorithm to generate operations ...
        return op;
    }
}

public class OTServer {
    private Document document;
    private List<TextOperation> operationHistory;
    
    public synchronized TextOperation applyOperation(
            TextOperation clientOp, 
            int clientVersion) {
        
        // Get operations that happened after client's version
        List<TextOperation> concurrentOps = operationHistory.subList(
            clientVersion, operationHistory.size());
        
        // Transform client operation against all concurrent operations
        TextOperation transformedOp = clientOp;
        for (TextOperation concurrentOp : concurrentOps) {
            transformedOp = OperationalTransformer.transform(
                transformedOp, concurrentOp, false);
        }
        
        // Apply transformed operation
        document.applyOperation(transformedOp);
        
        // Store in history
        operationHistory.add(transformedOp);
        
        return transformedOp;
    }
}
```

---

## Differential Synchronization (DiffSync)

### What is Differential Synchronization?

**Differential Synchronization (DiffSync)** is an alternative algorithm that uses **diffs** (differences) instead of operations. It's simpler than OT but may have different conflict resolution behavior.

### Core Concept

Instead of transforming operations, **compute diffs** between document states and apply them intelligently.

### How DiffSync Works

#### Step 1: Client Sends Diff

```java
public class DiffSyncClient {
    private String localState;
    private String shadowState; // Last known server state
    
    public Diff computeDiff() {
        // Compute diff between shadow and local
        Diff diff = DiffUtils.computeDiff(shadowState, localState);
        return diff;
    }
    
    public void applyServerDiff(Diff serverDiff) {
        // Apply server diff to local state
        localState = DiffUtils.applyDiff(localState, serverDiff);
        
        // Update shadow to match server
        shadowState = DiffUtils.applyDiff(shadowState, serverDiff);
    }
}
```

#### Step 2: Server Merges Diffs

```java
public class DiffSyncServer {
    private String serverState;
    private Map<String, String> clientShadows; // Client ID -> shadow state
    
    public Diff processClientDiff(String clientId, Diff clientDiff) {
        String clientShadow = clientShadows.get(clientId);
        
        // Apply client diff to shadow
        String newShadow = DiffUtils.applyDiff(clientShadow, clientDiff);
        
        // Compute server diff (changes to apply to server state)
        Diff serverDiff = DiffUtils.computeDiff(serverState, newShadow);
        
        // Apply to server state
        serverState = DiffUtils.applyDiff(serverState, serverDiff);
        
        // Update shadow
        clientShadows.put(clientId, serverState);
        
        // Return diff for client to apply
        return serverDiff;
    }
}
```

### DiffSync Example

```
Initial State (Server & All Clients): "Hello World"

Client A (local): "Hi Hello World" (inserted "Hi ")
Client A shadow: "Hello World"
Client A diff: INSERT(0, "Hi ")

Client B (local): "Hello Beautiful World" (inserted "Beautiful ")
Client B shadow: "Hello World"
Client B diff: INSERT(6, "Beautiful ")

Server receives Client A diff:
  Server state: "Hello World"
  Apply diff: "Hi Hello World"
  Server state updated

Server receives Client B diff:
  Server state: "Hi Hello World" (already updated)
  Client B shadow: "Hello World" (stale)
  Compute server diff: INSERT(0, "Hi ")
  Apply to Client B shadow: "Hi Hello World"
  Now compute diff from updated shadow: INSERT(9, "Beautiful ")
  Apply to server: "Hi Hello Beautiful World"
  
Send to Client A: INSERT(9, "Beautiful ")
Send to Client B: INSERT(0, "Hi ")
```

### DiffSync Implementation

```java
public class Diff {
    private List<DiffOperation> operations;
    
    public static class DiffOperation {
        public enum Type { INSERT, DELETE, EQUAL }
        public Type type;
        public String text; // For INSERT/EQUAL
        public int length;  // For DELETE
    }
}

public class DiffUtils {
    // Myers diff algorithm or similar
    public static Diff computeDiff(String oldText, String newText) {
        // Compute differences between two strings
        // Returns list of operations: INSERT, DELETE, EQUAL
        List<Diff.DiffOperation> operations = new ArrayList<>();
        
        // Simplified version - real implementation uses dynamic programming
        int i = 0, j = 0;
        while (i < oldText.length() || j < newText.length()) {
            if (i < oldText.length() && j < newText.length() 
                && oldText.charAt(i) == newText.charAt(j)) {
                // Equal - advance both
                operations.add(new Diff.DiffOperation(
                    Diff.DiffOperation.Type.EQUAL, 
                    String.valueOf(oldText.charAt(i)), 1));
                i++;
                j++;
            } else if (j < newText.length()) {
                // Insert in new text
                operations.add(new Diff.DiffOperation(
                    Diff.DiffOperation.Type.INSERT, 
                    String.valueOf(newText.charAt(j)), 1));
                j++;
            } else {
                // Delete from old text
                operations.add(new Diff.DiffOperation(
                    Diff.DiffOperation.Type.DELETE, 
                    null, 1));
                i++;
            }
        }
        
        return new Diff(operations);
    }
    
    public static String applyDiff(String text, Diff diff) {
        StringBuilder result = new StringBuilder();
        int pos = 0;
        
        for (Diff.DiffOperation op : diff.operations) {
            switch (op.type) {
                case EQUAL:
                case INSERT:
                    result.append(op.text);
                    if (op.type == Diff.DiffOperation.Type.EQUAL) {
                        pos += op.length;
                    }
                    break;
                case DELETE:
                    pos += op.length; // Skip characters
                    break;
            }
        }
        
        // Append remaining text
        if (pos < text.length()) {
            result.append(text.substring(pos));
        }
        
        return result.toString();
    }
}
```

---

## System Architecture

### High-Level Architecture

```
┌─────────────┐         ┌─────────────┐         ┌─────────────┐
│  Client A   │         │  Client B   │         │  Client C   │
│  (Browser)  │         │  (Browser)  │         │  (Mobile)   │
└──────┬──────┘         └──────┬──────┘         └──────┬──────┘
       │                        │                        │
       │  WebSocket/SSE         │                        │
       │                        │                        │
       └────────────────────────┼────────────────────────┘
                                │
                    ┌───────────▼───────────┐
                    │   Load Balancer      │
                    └───────────┬───────────┘
                                │
                    ┌───────────▼───────────┐
                    │   WebSocket Server   │
                    │   (Operation Hub)    │
                    └───────────┬───────────┘
                                │
                ┌───────────────┼───────────────┐
                │               │               │
        ┌───────▼──────┐ ┌──────▼──────┐ ┌─────▼─────┐
        │  Document     │ │  Operation  │ │  User     │
        │  Service      │ │  Transformer│ │  Service  │
        └───────┬───────┘ └─────────────┘ └───────────┘
                │
        ┌───────▼───────┐
        │   Database    │
        │  (Documents) │
        └───────────────┘
```

### Component Breakdown

#### 1. Client Layer

```java
public class DocumentClient {
    private WebSocketClient websocket;
    private Document localDocument;
    private int serverVersion;
    private Queue<Operation> pendingOperations;
    
    public void connect(String documentId) {
        websocket = new WebSocketClient("ws://server/docs/" + documentId);
        websocket.onMessage(this::handleServerOperation);
    }
    
    public void onUserEdit(String newContent) {
        // Compute operation
        Operation op = computeOperation(localDocument.getContent(), newContent);
        
        // Apply optimistically
        localDocument.applyOperation(op);
        updateUI();
        
        // Send to server
        sendOperation(op);
    }
    
    private void handleServerOperation(Operation serverOp) {
        // Transform pending operations against server operation
        transformPendingOperations(serverOp);
        
        // Apply server operation
        localDocument.applyOperation(serverOp);
        serverVersion++;
        
        updateUI();
    }
}
```

#### 2. WebSocket Server

```java
@ServerEndpoint("/docs/{documentId}")
public class DocumentWebSocketServer {
    
    private static Map<String, DocumentSession> sessions = new ConcurrentHashMap<>();
    
    @OnOpen
    public void onOpen(Session session, @PathParam("documentId") String docId) {
        DocumentSession docSession = sessions.computeIfAbsent(
            docId, k -> new DocumentSession(docId));
        docSession.addClient(session);
    }
    
    @OnMessage
    public void onMessage(Session session, String message, 
                         @PathParam("documentId") String docId) {
        Operation clientOp = parseOperation(message);
        DocumentSession docSession = sessions.get(docId);
        
        // Process operation
        Operation transformedOp = docSession.processOperation(
            session.getId(), clientOp);
        
        // Broadcast to all clients (except sender)
        docSession.broadcast(transformedOp, session.getId());
    }
}
```

#### 3. Document Service

```java
@Service
public class DocumentService {
    
    @Autowired
    private DocumentRepository documentRepository;
    
    @Autowired
    private OperationTransformer operationTransformer;
    
    public Operation processOperation(String documentId, 
                                     Operation clientOp, 
                                     int clientVersion) {
        // Load document
        Document document = documentRepository.findById(documentId);
        
        // Get concurrent operations
        List<Operation> concurrentOps = document.getOperations()
            .subList(clientVersion, document.getOperations().size());
        
        // Transform operation
        Operation transformedOp = clientOp;
        for (Operation concurrentOp : concurrentOps) {
            transformedOp = operationTransformer.transform(
                transformedOp, concurrentOp);
        }
        
        // Apply to document
        document.applyOperation(transformedOp);
        document.addOperation(transformedOp);
        
        // Save
        documentRepository.save(document);
        
        return transformedOp;
    }
}
```

---

## Data Models

### Document Model

```java
@Entity
public class Document {
    @Id
    private String documentId;
    
    private String title;
    
    @Lob
    private String content; // Current state
    
    @Version
    private Long version; // For optimistic locking
    
    @OneToMany(cascade = CascadeType.ALL)
    private List<Operation> operationHistory; // For OT
    
    private String lastModifiedBy;
    private Timestamp lastModifiedAt;
    
    // For DiffSync
    private Map<String, String> clientShadows; // Client ID -> shadow state
}
```

### Operation Model

```java
@Entity
public class Operation {
    @Id
    @GeneratedValue
    private Long operationId;
    
    private String documentId;
    private int version; // Operation version number
    
    @Enumerated(EnumType.STRING)
    private OperationType type;
    
    private int position;
    private String content; // For INSERT
    private int length;     // For DELETE/RETAIN
    
    private String userId;
    private Timestamp timestamp;
    
    // For transformation
    @Transient
    private List<Operation> subOperations; // Composed operations
}
```

### Client Session Model

```java
public class ClientSession {
    private String sessionId;
    private String userId;
    private String documentId;
    private int clientVersion; // Last operation version client knows
    private String shadowState; // For DiffSync
    private WebSocketSession websocketSession;
    private Queue<Operation> pendingOperations;
}
```

---

## Conflict Resolution Strategies

### Strategy 1: Last Writer Wins (LWW)

```java
// Simple but can lose data
public Operation resolveConflict(Operation op1, Operation op2) {
    if (op1.timestamp.after(op2.timestamp)) {
        return op1; // op1 wins
    } else {
        return op2; // op2 wins
    }
}
```

**Pros:** Simple, fast  
**Cons:** Can lose user's work

### Strategy 2: Operational Transformation (OT)

```java
// Transform operations to preserve both
public Operation resolveConflict(Operation op1, Operation op2) {
    // Transform op1 against op2
    Operation op1Transformed = transform(op1, op2);
    // Transform op2 against op1
    Operation op2Transformed = transform(op2, op1);
    
    // Apply both transformed operations
    return compose(op1Transformed, op2Transformed);
}
```

**Pros:** Preserves all changes  
**Cons:** Complex, may have edge cases

### Strategy 3: Three-Way Merge

```java
// Like Git merge
public String resolveConflict(String base, String client, String server) {
    // Find common ancestor (base)
    // Compute diff: base -> client
    // Compute diff: base -> server
    // Merge diffs intelligently
    return mergeDiffs(base, client, server);
}
```

**Pros:** Handles complex conflicts  
**Cons:** Requires base version

### Strategy 4: Character-Level CRDTs

```java
// Conflict-free Replicated Data Types
// Each character has unique ID, operations are commutative
public class CRDTDocument {
    private List<CRDTCharacter> characters;
    
    public void insert(int position, char c) {
        CRDTCharacter char = new CRDTCharacter(
            generateUniqueId(), c, getPositionId(position));
        characters.add(char);
        sortByPosition();
    }
}
```

**Pros:** No conflicts, simpler  
**Cons:** More memory, complex position management

---

## Implementation Details

### Client-Side Implementation

```java
public class CollaborativeEditor {
    private Document document;
    private WebSocketClient websocket;
    private int serverVersion = 0;
    private Queue<Operation> pendingOps = new LinkedList<>();
    
    public void initialize(String documentId) {
        // Load document
        document = loadDocument(documentId);
        
        // Connect WebSocket
        websocket = new WebSocketClient("ws://server/docs/" + documentId);
        websocket.onMessage(this::handleServerMessage);
        
        // Listen to user edits
        editor.onTextChange(this::handleUserEdit);
    }
    
    private void handleUserEdit(String newContent) {
        // Compute operation
        Operation op = computeOperation(
            document.getContent(), newContent);
        
        // Apply optimistically (optimistic UI update)
        document.applyOperation(op);
        updateEditorUI();
        
        // Add to pending queue
        pendingOps.offer(op);
        
        // Send to server
        sendOperation(op, serverVersion);
    }
    
    private void handleServerMessage(Message message) {
        Operation serverOp = message.getOperation();
        int serverVersion = message.getVersion();
        
        // Transform all pending operations against server operation
        Queue<Operation> transformedPending = new LinkedList<>();
        while (!pendingOps.isEmpty()) {
            Operation pending = pendingOps.poll();
            Operation transformed = transform(pending, serverOp);
            transformedPending.offer(transformed);
        }
        pendingOps = transformedPending;
        
        // Apply server operation
        document.applyOperation(serverOp);
        this.serverVersion = serverVersion;
        
        // Update UI
        updateEditorUI();
    }
    
    private void sendOperation(Operation op, int version) {
        Message message = new Message();
        message.setType("OPERATION");
        message.setOperation(op);
        message.setVersion(version);
        message.setDocumentId(document.getId());
        
        websocket.send(message.toJson());
    }
}
```

### Server-Side Implementation

```java
@Service
public class CollaborativeDocumentService {
    
    private Map<String, DocumentSession> activeSessions = new ConcurrentHashMap<>();
    
    public void handleClientOperation(String documentId, 
                                     String clientId,
                                     Operation clientOp, 
                                     int clientVersion) {
        DocumentSession session = activeSessions.computeIfAbsent(
            documentId, k -> new DocumentSession(documentId));
        
        // Get concurrent operations
        List<Operation> concurrentOps = session.getOperations()
            .subList(clientVersion, session.getOperations().size());
        
        // Transform operation
        Operation transformedOp = clientOp;
        for (Operation concurrentOp : concurrentOps) {
            transformedOp = transform(transformedOp, concurrentOp);
        }
        
        // Apply to document
        session.applyOperation(transformedOp);
        
        // Broadcast to all clients
        session.broadcast(transformedOp, clientId);
        
        // Persist
        persistOperation(documentId, transformedOp);
    }
    
    private Operation transform(Operation op1, Operation op2) {
        // OT transformation logic
        // Handle INSERT vs INSERT, INSERT vs DELETE, etc.
        return OperationalTransformer.transform(op1, op2);
    }
}
```

### Operational Transformer Implementation

```java
public class OperationalTransformer {
    
    public static Operation transform(Operation op1, Operation op2) {
        // Handle different operation type combinations
        
        if (op1.type == OperationType.INSERT && 
            op2.type == OperationType.INSERT) {
            return transformInsertInsert(op1, op2);
        }
        
        if (op1.type == OperationType.INSERT && 
            op2.type == OperationType.DELETE) {
            return transformInsertDelete(op1, op2);
        }
        
        if (op1.type == OperationType.DELETE && 
            op2.type == OperationType.INSERT) {
            return transformDeleteInsert(op1, op2);
        }
        
        if (op1.type == OperationType.DELETE && 
            op2.type == OperationType.DELETE) {
            return transformDeleteDelete(op1, op2);
        }
        
        return op1; // No transformation needed
    }
    
    private static Operation transformInsertInsert(
            Operation op1, Operation op2) {
        // op1: INSERT(pos1, text1)
        // op2: INSERT(pos2, text2)
        
        if (op1.position < op2.position) {
            // op1 happens before op2, op2 position shifts
            return new Operation(
                OperationType.INSERT,
                op1.position,
                op1.content);
        } else if (op1.position > op2.position) {
            // op2 happens before op1, op1 position shifts
            return new Operation(
                OperationType.INSERT,
                op1.position + op2.content.length(),
                op1.content);
        } else {
            // Same position - use priority (e.g., user ID hash)
            if (op1.userId.compareTo(op2.userId) < 0) {
                return op1; // op1 wins
            } else {
                return new Operation(
                    OperationType.INSERT,
                    op1.position + op2.content.length(),
                    op1.content);
            }
        }
    }
    
    private static Operation transformInsertDelete(
            Operation op1, Operation op2) {
        // op1: INSERT(pos1, text1)
        // op2: DELETE(pos2, len2)
        
        if (op1.position <= op2.position) {
            // Insert before delete, delete position shifts
            return op1; // No change
        } else if (op1.position >= op2.position + op2.length) {
            // Insert after delete, insert position shifts back
            return new Operation(
                OperationType.INSERT,
                op1.position - op2.length,
                op1.content);
        } else {
            // Insert in the middle of deleted text
            // Adjust position to start of deletion
            return new Operation(
                OperationType.INSERT,
                op2.position,
                op1.content);
        }
    }
    
    private static Operation transformDeleteInsert(
            Operation op1, Operation op2) {
        // op1: DELETE(pos1, len1)
        // op2: INSERT(pos2, text2)
        
        if (op1.position + op1.length <= op2.position) {
            // Delete before insert, no change
            return op1;
        } else if (op1.position >= op2.position) {
            // Delete after insert, delete position shifts forward
            return new Operation(
                OperationType.DELETE,
                op1.position + op2.content.length(),
                op1.length);
        } else {
            // Overlapping - complex case
            // Delete range needs to be adjusted
            int overlapStart = Math.max(op1.position, op2.position);
            int overlapEnd = Math.min(
                op1.position + op1.length, 
                op2.position + op2.content.length());
            
            if (overlapStart < overlapEnd) {
                // There's overlap
                int newLength = op1.length - (overlapEnd - overlapStart);
                return new Operation(
                    OperationType.DELETE,
                    op1.position,
                    newLength);
            }
            
            return op1;
        }
    }
    
    private static Operation transformDeleteDelete(
            Operation op1, Operation op2) {
        // op1: DELETE(pos1, len1)
        // op2: DELETE(pos2, len2)
        
        if (op1.position + op1.length <= op2.position) {
            // op1 completely before op2
            return op1; // No change
        } else if (op2.position + op2.length <= op1.position) {
            // op2 completely before op1
            return new Operation(
                OperationType.DELETE,
                op1.position - op2.length,
                op1.length);
        } else {
            // Overlapping deletes
            // Compute intersection and adjust
            int intersectionStart = Math.max(op1.position, op2.position);
            int intersectionEnd = Math.min(
                op1.position + op1.length,
                op2.position + op2.length);
            
            int intersectionLength = intersectionEnd - intersectionStart;
            int newLength = op1.length - intersectionLength;
            
            if (newLength <= 0) {
                // Entire op1 is deleted by op2
                return null; // Operation is cancelled
            }
            
            return new Operation(
                OperationType.DELETE,
                op1.position,
                newLength);
        }
    }
}
```

---

## Scalability Considerations

### 1. Horizontal Scaling

```java
// Use message queue for distributed system
public class DistributedDocumentService {
    
    @Autowired
    private MessageQueue messageQueue;
    
    @Autowired
    private DocumentRepository documentRepository;
    
    public void handleOperation(String documentId, Operation op) {
        // Publish to message queue
        messageQueue.publish("document-operations", new OperationEvent(
            documentId, op));
    }
    
    @RabbitListener(queues = "document-operations")
    public void processOperation(OperationEvent event) {
        // All servers process operations in order
        // Ensures consistency across instances
        Document doc = documentRepository.findById(event.documentId);
        doc.applyOperation(event.operation);
        documentRepository.save(doc);
    }
}
```

### 2. Operation Batching

```java
// Batch operations to reduce database writes
public class BatchedDocumentService {
    
    private Map<String, List<Operation>> operationBuffer = new ConcurrentHashMap<>();
    private ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
    
    public void init() {
        // Flush operations every 100ms
        scheduler.scheduleAtFixedRate(
            this::flushOperations, 100, 100, TimeUnit.MILLISECONDS);
    }
    
    public void addOperation(String documentId, Operation op) {
        operationBuffer.computeIfAbsent(documentId, k -> new ArrayList<>())
            .add(op);
    }
    
    private void flushOperations() {
        for (Map.Entry<String, List<Operation>> entry : operationBuffer.entrySet()) {
            String docId = entry.getKey();
            List<Operation> ops = entry.getValue();
            
            if (!ops.isEmpty()) {
                // Batch save operations
                operationRepository.saveAll(ops);
                ops.clear();
            }
        }
    }
}
```

### 3. Caching

```java
// Cache document state
@Service
public class CachedDocumentService {
    
    @Autowired
    private RedisTemplate<String, Document> redisCache;
    
    public Document getDocument(String documentId) {
        // Try cache first
        Document doc = redisCache.opsForValue().get("doc:" + documentId);
        
        if (doc == null) {
            // Load from database
            doc = documentRepository.findById(documentId);
            // Cache for 1 hour
            redisCache.opsForValue().set(
                "doc:" + documentId, doc, 1, TimeUnit.HOURS);
        }
        
        return doc;
    }
    
    public void updateDocument(String documentId, Operation op) {
        Document doc = getDocument(documentId);
        doc.applyOperation(op);
        
        // Update cache
        redisCache.opsForValue().set("doc:" + documentId, doc);
        
        // Async persist to database
        documentRepository.saveAsync(doc);
    }
}
```

### 4. Sharding

```java
// Shard documents across multiple databases
public class ShardedDocumentService {
    
    private List<DocumentRepository> shards;
    
    public DocumentRepository getShard(String documentId) {
        // Consistent hashing
        int shardIndex = Math.abs(documentId.hashCode()) % shards.size();
        return shards.get(shardIndex);
    }
    
    public Document getDocument(String documentId) {
        DocumentRepository shard = getShard(documentId);
        return shard.findById(documentId);
    }
}
```

---

## Comparison: OT vs DiffSync

### Operational Transformation (OT)

**Pros:**
- ✅ Precise conflict resolution
- ✅ Preserves user intent better
- ✅ Industry standard (Google Docs uses OT)
- ✅ Handles complex scenarios well

**Cons:**
- ❌ Complex implementation
- ❌ Hard to get right (many edge cases)
- ❌ Requires operation history
- ❌ Transformation can be computationally expensive

### Differential Synchronization (DiffSync)

**Pros:**
- ✅ Simpler implementation
- ✅ Easier to understand
- ✅ No operation history needed
- ✅ Good for simple text editing

**Cons:**
- ❌ May lose some user intent
- ❌ Conflict resolution less precise
- ❌ Can produce unexpected results
- ❌ Less suitable for complex structures

### When to Use Which?

**Use OT when:**
- Need precise conflict resolution
- Complex document structures (tables, formatting)
- High-quality collaboration required
- Can invest in complex implementation

**Use DiffSync when:**
- Simple text editing
- Need quick implementation
- Can tolerate some conflict resolution issues
- Lower collaboration requirements

---

## Real-World Examples

### Example 1: Simple Text Editing

```
Initial: "Hello World"

User A: Types "Hi " at start
User B: Types "Beautiful " before "World"

With OT:
  A: INSERT(0, "Hi ")
  B: INSERT(6, "Beautiful ")
  
  Transform B against A:
    B': INSERT(9, "Beautiful ")
  
  Result: "Hi Hello Beautiful World" ✓

With DiffSync:
  A diff: "Hello World" -> "Hi Hello World"
  B diff: "Hello World" -> "Hello Beautiful World"
  
  Merge: "Hi Hello Beautiful World" ✓
```

### Example 2: Overlapping Edits

```
Initial: "Hello World"

User A: Deletes "Hello " (positions 0-6)
User B: Changes "Hello" to "Hi" (positions 0-5)

With OT:
  A: DELETE(0, 6)
  B: DELETE(0, 5) + INSERT(0, "Hi")
  
  Transform B against A:
    B': DELETE(0, 5) + INSERT(0, "Hi")
    But A already deleted, so adjust...
    Result: "Hi World" or "World" depending on transformation
  
With DiffSync:
  A: "Hello World" -> "World"
  B: "Hello World" -> "Hi World"
  
  Merge: Could be "Hi World" or "World" depending on algorithm
```

### Example 3: Concurrent Formatting

```
Initial: "Hello World"

User A: Makes "Hello" bold
User B: Makes "World" italic

With OT:
  Need to handle formatting operations
  A: FORMAT(0, 5, BOLD)
  B: FORMAT(6, 5, ITALIC)
  
  These don't conflict, both can be applied
  Result: **Hello** *World*

With DiffSync:
  More complex - need to track formatting separately
  May require additional metadata
```

---

## Summary

### Key Takeaways

1. **Operational Transformation (OT)**:
   - Transforms operations to handle concurrent edits
   - More complex but more precise
   - Used by Google Docs

2. **Differential Synchronization (DiffSync)**:
   - Uses diffs between states
   - Simpler but less precise
   - Good for simple use cases

3. **System Design Considerations**:
   - WebSocket for real-time communication
   - Operation versioning for ordering
   - Conflict resolution strategies
   - Scalability through sharding and caching

4. **Implementation Challenges**:
   - Operation ordering
   - Position shifting
   - Conflict resolution
   - Offline support

### Architecture Components

- **Client**: Optimistic UI updates, operation queuing
- **WebSocket Server**: Real-time operation broadcasting
- **Document Service**: Operation transformation and application
- **Database**: Persistent storage with versioning
- **Cache**: Fast read access
- **Message Queue**: Distributed operation processing

---

*This guide provides comprehensive coverage of Google Docs system design, focusing on Operational Transformation and Differential Synchronization. Understanding these concepts is crucial for building real-time collaborative applications.*

