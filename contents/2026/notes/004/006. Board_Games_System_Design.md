# System Design: Online Board Games Platform

## Table of Contents
1. [Problem Statement](#problem-statement)
2. [Requirements](#requirements)
3. [System Architecture](#system-architecture)
4. [Database Design](#database-design)
5. [API Design](#api-design)
6. [Real-time Communication](#real-time-communication)
7. [Game State Management](#game-state-management)
8. [Scalability Considerations](#scalability-considerations)
9. [Security & Validation](#security--validation)
10. [Technology Stack](#technology-stack)

---

## Problem Statement

Design an online platform that allows users to play various board games (Chess, Checkers, Monopoly, Scrabble, etc.) in real-time with other players over the internet. The system should support:
- Multiple concurrent games
- Real-time move synchronization
- Game state persistence
- Turn-based and real-time games
- Player matching and lobbies
- Game history and replays

---

## Requirements

### Functional Requirements
1. **User Management**
   - User registration and authentication
   - User profiles and statistics
   - Friend system

2. **Game Management**
   - Create/join games
   - Support multiple game types (Chess, Checkers, Monopoly, etc.)
   - Game lobbies and matchmaking
   - Spectator mode

3. **Gameplay**
   - Real-time move synchronization
   - Turn management
   - Move validation
   - Game state persistence
   - Undo/redo functionality (if applicable)

4. **Additional Features**
   - Game history and replays
   - Leaderboards
   - Chat functionality
   - Notifications

### Non-Functional Requirements
1. **Performance**
   - Low latency (< 100ms for move updates)
   - Support 1M+ concurrent users
   - Handle 10K+ concurrent games

2. **Reliability**
   - 99.9% uptime
   - Game state recovery
   - Handle disconnections gracefully

3. **Scalability**
   - Horizontal scaling
   - Support multiple game types
   - Easy to add new games

---

## System Architecture

### High-Level Architecture

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   Web App   │     │  Mobile App │     │   Admin UI  │
└──────┬──────┘     └──────┬──────┘     └──────┬──────┘
       │                   │                    │
       └───────────────────┼────────────────────┘
                            │
                   ┌────────▼────────┐
                   │   API Gateway   │
                   │  (Load Balancer)│
                   └────────┬────────┘
                            │
        ┌───────────────────┼───────────────────┐
        │                   │                   │
┌───────▼────────┐  ┌───────▼────────┐  ┌───────▼────────┐
│  Auth Service  │  │  Game Service  │  │  User Service  │
└────────────────┘  └───────┬────────┘  └────────────────┘
                            │
        ┌───────────────────┼───────────────────┐
        │                   │                   │
┌───────▼────────┐  ┌───────▼────────┐  ┌───────▼────────┐
│ Game Engine   │  │ Matchmaking    │  │ Notification   │
│ Service       │  │ Service        │  │ Service        │
└───────┬───────┘  └────────────────┘  └────────────────┘
        │
        │
┌───────▼──────────────────────────────────────────┐
│         WebSocket Server (Real-time)              │
│  - Game state updates                             │
│  - Move broadcasting                              │
│  - Chat messages                                  │
└───────────────────────────────────────────────────┘
        │
        │
┌───────▼──────────────────────────────────────────┐
│              Message Queue (Kafka/RabbitMQ)      │
│  - Event streaming                                │
│  - Game state events                              │
└───────────────────────────────────────────────────┘
        │
        │
┌───────▼──────────────────────────────────────────┐
│              Database Layer                       │
│  - PostgreSQL (User data, game metadata)         │
│  - Redis (Game state cache, sessions)            │
│  - MongoDB (Game history, logs)                  │
└───────────────────────────────────────────────────┘
```

### Component Details

#### 1. API Gateway
- Routes requests to appropriate services
- Handles authentication/authorization
- Rate limiting
- Request/response transformation

#### 2. Game Service
- Game creation and management
- Game state management
- Move validation
- Turn management

#### 3. Game Engine Service
- Game logic for different board games
- Move validation rules
- Win/loss detection
- Game state transitions

#### 4. Matchmaking Service
- Player matching algorithms
- Lobby management
- Queue management for ranked games

#### 5. WebSocket Server
- Real-time bidirectional communication
- Game state synchronization
- Move broadcasting
- Connection management

#### 6. User Service
- User profiles
- Statistics and achievements
- Friend management

---

## Database Design

### PostgreSQL Schema

#### Users Table
```sql
CREATE TABLE users (
    user_id UUID PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    is_active BOOLEAN DEFAULT TRUE
);

CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);
```

#### Games Table
```sql
CREATE TABLE games (
    game_id UUID PRIMARY KEY,
    game_type VARCHAR(50) NOT NULL, -- 'chess', 'checkers', etc.
    status VARCHAR(20) NOT NULL, -- 'waiting', 'active', 'finished', 'abandoned'
    created_at TIMESTAMP DEFAULT NOW(),
    started_at TIMESTAMP,
    finished_at TIMESTAMP,
    winner_id UUID REFERENCES users(user_id),
    settings JSONB -- Game-specific settings
);

CREATE INDEX idx_games_status ON games(status);
CREATE INDEX idx_games_type ON games(game_type);
CREATE INDEX idx_games_created_at ON games(created_at);
```

#### Game Players Table
```sql
CREATE TABLE game_players (
    game_id UUID REFERENCES games(game_id),
    user_id UUID REFERENCES users(user_id),
    player_number INT NOT NULL, -- 1, 2, 3, etc.
    color VARCHAR(20), -- For games like chess ('white', 'black')
    joined_at TIMESTAMP DEFAULT NOW(),
    left_at TIMESTAMP,
    PRIMARY KEY (game_id, user_id)
);

CREATE INDEX idx_game_players_user ON game_players(user_id);
```

#### Moves Table
```sql
CREATE TABLE moves (
    move_id UUID PRIMARY KEY,
    game_id UUID REFERENCES games(game_id),
    user_id UUID REFERENCES users(user_id),
    move_number INT NOT NULL,
    move_data JSONB NOT NULL, -- Game-specific move representation
    move_timestamp TIMESTAMP DEFAULT NOW(),
    is_valid BOOLEAN DEFAULT TRUE,
    game_state_after JSONB -- Snapshot of game state
);

CREATE INDEX idx_moves_game ON moves(game_id);
CREATE INDEX idx_moves_game_move_number ON moves(game_id, move_number);
```

#### User Statistics Table
```sql
CREATE TABLE user_statistics (
    user_id UUID PRIMARY KEY REFERENCES users(user_id),
    game_type VARCHAR(50),
    games_played INT DEFAULT 0,
    games_won INT DEFAULT 0,
    games_lost INT DEFAULT 0,
    games_drawn INT DEFAULT 0,
    elo_rating INT DEFAULT 1000,
    updated_at TIMESTAMP DEFAULT NOW(),
    PRIMARY KEY (user_id, game_type)
);
```

### Redis Schema

#### Game State Cache
```
Key: game:{game_id}:state
Value: JSON string of current game state
TTL: 24 hours (or until game ends)
```

#### Active Sessions
```
Key: user:{user_id}:session
Value: {game_id, last_activity, connection_id}
TTL: 1 hour
```

#### Matchmaking Queue
```
Key: queue:{game_type}:{skill_level}
Type: Sorted Set
Value: user_id
Score: timestamp (for FIFO)
```

### MongoDB Schema

#### Game History Collection
```javascript
{
  game_id: UUID,
  game_type: String,
  players: [{
    user_id: UUID,
    username: String,
    player_number: Number
  }],
  moves: [{
    move_number: Number,
    user_id: UUID,
    move_data: Object,
    timestamp: Date
  }],
  final_state: Object,
  winner_id: UUID,
  duration_seconds: Number,
  created_at: Date,
  finished_at: Date
}
```

---

## API Design

### REST APIs

#### Authentication
```
POST /api/v1/auth/register
POST /api/v1/auth/login
POST /api/v1/auth/logout
POST /api/v1/auth/refresh
```

#### Games
```
POST   /api/v1/games                    # Create a new game
GET    /api/v1/games/{game_id}          # Get game details
GET    /api/v1/games/{game_id}/state    # Get current game state
POST   /api/v1/games/{game_id}/join     # Join a game
POST   /api/v1/games/{game_id}/leave    # Leave a game
POST   /api/v1/games/{game_id}/move     # Make a move
GET    /api/v1/games/{game_id}/history  # Get game history
GET    /api/v1/games/{game_id}/replay   # Get replay data
```

#### Matchmaking
```
POST   /api/v1/matchmaking/queue        # Join matchmaking queue
DELETE /api/v1/matchmaking/queue        # Leave matchmaking queue
GET    /api/v1/matchmaking/status       # Get queue status
```

#### Users
```
GET    /api/v1/users/{user_id}          # Get user profile
GET    /api/v1/users/{user_id}/stats    # Get user statistics
GET    /api/v1/users/{user_id}/games    # Get user's games
GET    /api/v1/users/{user_id}/history  # Get game history
```

#### Leaderboards
```
GET    /api/v1/leaderboards/{game_type} # Get leaderboard
```

### WebSocket Events

#### Client → Server
```javascript
// Join game room
{
  type: 'JOIN_GAME',
  game_id: 'uuid'
}

// Make a move
{
  type: 'MAKE_MOVE',
  game_id: 'uuid',
  move: {
    from: 'e2',
    to: 'e4'
  }
}

// Send chat message
{
  type: 'CHAT',
  game_id: 'uuid',
  message: 'Hello!'
}

// Leave game
{
  type: 'LEAVE_GAME',
  game_id: 'uuid'
}
```

#### Server → Client
```javascript
// Game state update
{
  type: 'GAME_STATE_UPDATE',
  game_id: 'uuid',
  state: { /* game state */ },
  last_move: { /* move details */ }
}

// Move validation result
{
  type: 'MOVE_RESULT',
  game_id: 'uuid',
  move_id: 'uuid',
  valid: true,
  error: null,
  new_state: { /* updated state */ }
}

// Player joined/left
{
  type: 'PLAYER_UPDATE',
  game_id: 'uuid',
  action: 'joined' | 'left',
  user_id: 'uuid',
  username: 'string'
}

// Game ended
{
  type: 'GAME_ENDED',
  game_id: 'uuid',
  winner_id: 'uuid',
  reason: 'checkmate' | 'resignation' | 'timeout'
}

// Error
{
  type: 'ERROR',
  code: 'INVALID_MOVE' | 'NOT_YOUR_TURN' | 'GAME_NOT_FOUND',
  message: 'string'
}
```

---

## Real-time Communication

### WebSocket Architecture

```
Client 1 ──┐
           ├──> WebSocket Server ──> Game Service ──> Redis (State Cache)
Client 2 ──┘                              │
                                          │
                                          ▼
                                    Message Queue
                                          │
                                          ▼
                                    Analytics Service
```

### Connection Management
1. **Connection Pooling**: Use connection pools for WebSocket servers
2. **Heartbeat**: Ping/pong every 30 seconds to detect dead connections
3. **Reconnection**: Client automatically reconnects on disconnect
4. **State Recovery**: On reconnect, fetch latest game state from Redis/DB

### Message Broadcasting
- When a player makes a move:
  1. Validate move in Game Engine Service
  2. Update game state in Redis
  3. Persist move to PostgreSQL
  4. Broadcast to all players in the game room
  5. Send event to message queue for analytics

---

## Game State Management

### State Storage Strategy

#### Hot State (Active Games)
- Stored in **Redis** for fast access
- Structure: `game:{game_id}:state`
- Updated on every move
- TTL: 24 hours or until game ends

#### Warm State (Recent Games)
- Stored in **PostgreSQL** (moves table)
- Can reconstruct state from moves
- Used for replays and recovery

#### Cold State (Historical Games)
- Stored in **MongoDB** (game history)
- Full game replay data
- Used for analytics and history

### State Reconstruction
```python
def reconstruct_game_state(game_id, up_to_move=None):
    """
    Reconstruct game state from moves
    """
    moves = get_moves_from_db(game_id, limit=up_to_move)
    initial_state = get_initial_state(game_id)
    
    current_state = initial_state
    for move in moves:
        current_state = apply_move(current_state, move)
    
    return current_state
```

### State Synchronization
1. **Optimistic Updates**: Client updates UI immediately
2. **Server Validation**: Server validates and broadcasts
3. **Conflict Resolution**: Server state is source of truth
4. **Rollback**: If move invalid, client reverts to last valid state

---

## Scalability Considerations

### Horizontal Scaling

#### Stateless Services
- API services are stateless
- Can scale horizontally behind load balancer
- Use sticky sessions for WebSocket connections

#### Database Scaling
- **PostgreSQL**: Read replicas for read-heavy operations
- **Redis**: Redis Cluster for distributed caching
- **MongoDB**: Sharding by game_id or user_id

#### WebSocket Scaling
- Use Redis Pub/Sub for cross-server communication
- Sticky sessions: Route same game to same server
- Or use Redis for shared state across servers

### Caching Strategy

#### L1 Cache (In-Memory)
- Active game states in Redis
- User sessions
- Leaderboard data

#### L2 Cache (Database)
- Game metadata
- User profiles
- Statistics

### Load Balancing
- **API Gateway**: Round-robin or least connections
- **WebSocket**: Sticky sessions (same game → same server)
- **Database**: Read/write splitting

### Rate Limiting
- Per user: 100 requests/minute
- Per game: 10 moves/minute
- Per IP: 1000 requests/minute

---

## Security & Validation

### Authentication & Authorization
1. **JWT Tokens**: Stateless authentication
2. **Token Refresh**: Refresh tokens for long sessions
3. **Role-Based Access**: Player, spectator, admin roles

### Move Validation
```python
def validate_move(game_id, user_id, move):
    """
    Validate a move before applying it
    """
    game_state = get_game_state(game_id)
    
    # Check if it's player's turn
    if game_state['current_turn'] != user_id:
        raise ValidationError("Not your turn")
    
    # Check if game is active
    if game_state['status'] != 'active':
        raise ValidationError("Game is not active")
    
    # Game-specific validation
    game_engine = get_game_engine(game_state['game_type'])
    if not game_engine.is_valid_move(game_state, move):
        raise ValidationError("Invalid move")
    
    return True
```

### Input Sanitization
- Validate all user inputs
- Sanitize chat messages
- Prevent SQL injection, XSS attacks
- Rate limit to prevent abuse

### Anti-Cheating Measures
1. **Server-Side Validation**: All moves validated on server
2. **State Verification**: Periodic state checksums
3. **Move Timing**: Detect suspiciously fast moves
4. **Pattern Detection**: Detect bot-like behavior

---

## Technology Stack

### Backend
- **API Framework**: Node.js (Express) / Python (FastAPI) / Go (Gin)
- **WebSocket**: Socket.io / WebSocket (native) / SignalR
- **Database**: PostgreSQL, Redis, MongoDB
- **Message Queue**: Kafka / RabbitMQ / Redis Streams
- **Cache**: Redis
- **Search**: Elasticsearch (for game history search)

### Frontend
- **Web**: React / Vue.js / Angular
- **Mobile**: React Native / Flutter
- **WebSocket Client**: Socket.io-client / native WebSocket

### Infrastructure
- **Containerization**: Docker, Kubernetes
- **Load Balancer**: NGINX / AWS ALB
- **CDN**: CloudFront / Cloudflare
- **Monitoring**: Prometheus, Grafana
- **Logging**: ELK Stack (Elasticsearch, Logstash, Kibana)

### Cloud Services (AWS Example)
- **Compute**: EC2 / ECS / Lambda
- **Database**: RDS (PostgreSQL), ElastiCache (Redis), DocumentDB (MongoDB)
- **Message Queue**: SQS / Kinesis
- **Storage**: S3 (for game replays, assets)

---

## Example: Chess Game Flow

### Game Creation
1. User A creates a game (POST /api/v1/games)
2. System creates game record in PostgreSQL
3. Initial game state stored in Redis
4. User A joins WebSocket room for game

### Player Joining
1. User B joins game (POST /api/v1/games/{id}/join)
2. Update game_players table
3. Broadcast to User A via WebSocket
4. Start game when both players ready

### Making a Move
1. User A makes move via WebSocket
2. Game Service validates move
3. Game Engine applies move to state
4. Update Redis cache
5. Persist move to PostgreSQL
6. Broadcast to User B
7. Check for win condition
8. If game ended, update database and notify both players

### Disconnection Handling
1. Detect disconnection (heartbeat timeout)
2. Mark player as disconnected
3. Start reconnection timer (5 minutes)
4. If reconnects: Resume game
5. If timeout: Mark game as abandoned, notify opponent

---

## Performance Optimizations

### Database Optimizations
- Indexes on frequently queried columns
- Connection pooling
- Query optimization
- Batch operations for bulk updates

### Caching Optimizations
- Cache game states in Redis
- Cache user profiles
- Cache leaderboards
- Use CDN for static assets

### Network Optimizations
- WebSocket compression
- Message batching
- Delta updates (send only changes)
- Connection pooling

---

## Monitoring & Analytics

### Key Metrics
- **Latency**: Move processing time, API response time
- **Throughput**: Requests per second, moves per second
- **Error Rate**: Failed moves, API errors
- **Active Users**: Concurrent users, active games
- **Game Completion Rate**: Finished vs abandoned games

### Logging
- All moves logged with timestamps
- Error logging with stack traces
- Access logs for all APIs
- WebSocket connection events

### Alerts
- High error rate
- High latency
- Database connection issues
- Redis cache misses
- WebSocket connection failures

---

## Future Enhancements

1. **AI Opponents**: Add AI players for practice
2. **Tournaments**: Organize tournaments and brackets
3. **Replay System**: Enhanced replay with annotations
4. **Social Features**: Friends, chat, achievements
5. **Mobile Apps**: Native mobile applications
6. **Spectator Mode**: Watch live games
7. **Game Variants**: Support multiple variants of each game
8. **Custom Rules**: Allow custom game rules

---

## Conclusion

This system design provides a scalable, reliable platform for online board games with:
- Real-time multiplayer support
- Horizontal scalability
- Robust state management
- Security and validation
- Comprehensive monitoring

The architecture can handle millions of concurrent users and thousands of concurrent games while maintaining low latency and high availability.

