# Java Generics & Type Safety: In-Depth Guide

## Table of Contents
1. [Introduction to Generics](#introduction-to-generics)
2. [Why Generics?](#why-generics)
3. [Generic Classes](#generic-classes)
4. [Generic Methods](#generic-methods)
5. [Generic Interfaces](#generic-interfaces)
6. [Wildcards](#wildcards)
7. [Bounded Type Parameters](#bounded-type-parameters)
8. [Type Erasure](#type-erasure)
9. [Type Safety](#type-safety)
10. [Common Patterns and Best Practices](#common-patterns-and-best-practices)
11. [Advanced Topics](#advanced-topics)
12. [Common Pitfalls and Solutions](#common-pitfalls-and-solutions)

---

## Introduction to Generics

### What are Generics?

Generics in Java allow you to write code that works with different types while maintaining type safety at compile time. They enable you to create classes, interfaces, and methods that operate on types specified as parameters.

### Before Generics (Pre-Java 5)

```java
// ❌ OLD WAY: Using raw types (no type safety)
List list = new ArrayList();
list.add("Hello");
list.add(123); // No compile-time error!
String str = (String) list.get(0); // Need explicit cast
Integer num = (Integer) list.get(1); // Need explicit cast

// Runtime error if wrong type is retrieved
String wrong = (String) list.get(1); // ClassCastException at runtime!
```

**Problems:**
- No compile-time type checking
- Need explicit casts everywhere
- Runtime ClassCastException errors
- No type safety

### With Generics (Java 5+)

```java
// ✅ NEW WAY: Using generics (type safe)
List<String> list = new ArrayList<>();
list.add("Hello");
list.add(123); // Compile-time error! Type mismatch
String str = list.get(0); // No cast needed - type is known
```

**Benefits:**
- Compile-time type checking
- No explicit casts needed
- Type safety guaranteed
- Better code readability

---

## Why Generics?

### 1. Type Safety

```java
// Without generics - unsafe
List list = new ArrayList();
list.add("String");
list.add(123);
String s = (String) list.get(1); // Runtime ClassCastException!

// With generics - safe
List<String> list = new ArrayList<>();
list.add("String");
list.add(123); // Compile-time error!
String s = list.get(0); // Type-safe, no cast needed
```

### 2. Eliminate Casts

```java
// Without generics
List list = new ArrayList();
list.add("Hello");
String s = (String) list.get(0); // Cast required

// With generics
List<String> list = new ArrayList<>();
list.add("Hello");
String s = list.get(0); // No cast needed
```

### 3. Better Code Readability

```java
// Clear intent: This list contains Strings
List<String> names = new ArrayList<>();

// Clear intent: This map maps String to Integer
Map<String, Integer> scores = new HashMap<>();
```

### 4. Enables Generic Algorithms

```java
// Can write algorithms that work with any type
public static <T> void swap(List<T> list, int i, int j) {
    T temp = list.get(i);
    list.set(i, list.get(j));
    list.set(j, temp);
}
```

---

## Generic Classes

### Basic Generic Class

```java
// Generic class definition
public class Box<T> {
    private T value;
    
    public void setValue(T value) {
        this.value = value;
    }
    
    public T getValue() {
        return value;
    }
}

// Usage
Box<String> stringBox = new Box<>();
stringBox.setValue("Hello");
String value = stringBox.getValue(); // Type-safe, no cast

Box<Integer> intBox = new Box<>();
intBox.setValue(123);
Integer num = intBox.getValue(); // Type-safe, no cast
```

### Multiple Type Parameters

```java
public class Pair<K, V> {
    private K key;
    private V value;
    
    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }
    
    public K getKey() {
        return key;
    }
    
    public V getValue() {
        return value;
    }
    
    public void setKey(K key) {
        this.key = key;
    }
    
    public void setValue(V value) {
        this.value = value;
    }
}

// Usage
Pair<String, Integer> pair = new Pair<>("Age", 25);
String key = pair.getKey(); // String
Integer value = pair.getValue(); // Integer
```

### Generic Class with Static Methods

```java
public class Container<T> {
    private T item;
    
    public Container(T item) {
        this.item = item;
    }
    
    public T getItem() {
        return item;
    }
    
    // Static method with its own type parameter
    public static <E> Container<E> create(E item) {
        return new Container<>(item);
    }
    
    // Static method cannot use class type parameter
    // public static void print(T item) { } // ERROR!
}

// Usage
Container<String> container = Container.create("Hello");
```

### Real-World Example: Generic Stack

```java
public class Stack<T> {
    private List<T> elements = new ArrayList<>();
    
    public void push(T element) {
        elements.add(element);
    }
    
    public T pop() {
        if (elements.isEmpty()) {
            throw new EmptyStackException();
        }
        return elements.remove(elements.size() - 1);
    }
    
    public T peek() {
        if (elements.isEmpty()) {
            throw new EmptyStackException();
        }
        return elements.get(elements.size() - 1);
    }
    
    public boolean isEmpty() {
        return elements.isEmpty();
    }
    
    public int size() {
        return elements.size();
    }
}

// Usage
Stack<String> stringStack = new Stack<>();
stringStack.push("First");
stringStack.push("Second");
String top = stringStack.pop(); // Type-safe

Stack<Integer> intStack = new Stack<>();
intStack.push(1);
intStack.push(2);
Integer num = intStack.pop(); // Type-safe
```

---

## Generic Methods

### Basic Generic Method

```java
public class Util {
    // Generic method - type parameter before return type
    public static <T> void printArray(T[] array) {
        for (T element : array) {
            System.out.println(element);
        }
    }
    
    // Generic method with return type
    public static <T> T getFirst(T[] array) {
        if (array.length > 0) {
            return array[0];
        }
        return null;
    }
}

// Usage
String[] strings = {"Hello", "World"};
Util.printArray(strings); // Type inferred: <String>

Integer[] numbers = {1, 2, 3};
Util.printArray(numbers); // Type inferred: <Integer>

String first = Util.getFirst(strings); // Type-safe
```

### Generic Method in Non-Generic Class

```java
public class ArrayUtils {
    // Generic method in non-generic class
    public static <T> void swap(T[] array, int i, int j) {
        T temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
    
    public static <T> T[] reverse(T[] array) {
        T[] reversed = Arrays.copyOf(array, array.length);
        for (int i = 0; i < array.length; i++) {
            reversed[i] = array[array.length - 1 - i];
        }
        return reversed;
    }
}

// Usage
String[] names = {"Alice", "Bob", "Charlie"};
ArrayUtils.swap(names, 0, 2);
String[] reversed = ArrayUtils.reverse(names);
```

### Type Inference

```java
public class InferenceExample {
    public static <T> T pick(T a1, T a2) {
        return a2;
    }
    
    public static <T> void process(List<T> list) {
        // Process list
    }
}

// Type inference examples
String s = InferenceExample.pick("a", "b"); // T inferred as String
Integer i = InferenceExample.pick(1, 2); // T inferred as Integer

// Explicit type parameter (usually not needed)
String s2 = InferenceExample.<String>pick("a", "b");

// Type inference with method chaining
List<String> list = new ArrayList<>();
InferenceExample.process(list); // T inferred as String
```

### Generic Method vs Generic Class

```java
// Generic class
public class Box<T> {
    private T value;
    
    public void setValue(T value) {
        this.value = value;
    }
    
    // Generic method in generic class
    public <U> void inspect(U u) {
        System.out.println("T: " + value.getClass().getName());
        System.out.println("U: " + u.getClass().getName());
    }
}

// Usage
Box<String> box = new Box<>();
box.setValue("Hello");
box.inspect(123); // U is Integer, T is String
```

---

## Generic Interfaces

### Basic Generic Interface

```java
public interface Comparable<T> {
    int compareTo(T other);
}

// Implementation
public class Person implements Comparable<Person> {
    private String name;
    private int age;
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    @Override
    public int compareTo(Person other) {
        return Integer.compare(this.age, other.age);
    }
}

// Usage
Person p1 = new Person("Alice", 25);
Person p2 = new Person("Bob", 30);
int result = p1.compareTo(p2); // Type-safe comparison
```

### Generic Interface with Multiple Type Parameters

```java
public interface Map<K, V> {
    void put(K key, V value);
    V get(K key);
    boolean containsKey(K key);
    Set<K> keySet();
}

// Implementation
public class HashMap<K, V> implements Map<K, V> {
    private java.util.Map<K, V> map = new java.util.HashMap<>();
    
    @Override
    public void put(K key, V value) {
        map.put(key, value);
    }
    
    @Override
    public V get(K key) {
        return map.get(key);
    }
    
    @Override
    public boolean containsKey(K key) {
        return map.containsKey(key);
    }
    
    @Override
    public Set<K> keySet() {
        return map.keySet();
    }
}

// Usage
Map<String, Integer> scores = new HashMap<>();
scores.put("Alice", 95);
scores.put("Bob", 87);
Integer aliceScore = scores.get("Alice"); // Type-safe
```

### Generic Interface with Default Methods

```java
public interface List<T> {
    void add(T element);
    T get(int index);
    int size();
    
    // Default method using generic type
    default boolean isEmpty() {
        return size() == 0;
    }
    
    // Default method with generic method
    default <U extends T> void addAll(List<U> other) {
        for (int i = 0; i < other.size(); i++) {
            add(other.get(i));
        }
    }
}
```

---

## Wildcards

### Unbounded Wildcards (`?`)

```java
// Unbounded wildcard - accepts any type
public void printList(List<?> list) {
    for (Object obj : list) {
        System.out.println(obj);
    }
}

// Usage
List<String> stringList = Arrays.asList("a", "b", "c");
printList(stringList); // OK

List<Integer> intList = Arrays.asList(1, 2, 3);
printList(intList); // OK

// Cannot add to unbounded wildcard list (except null)
public void addToList(List<?> list) {
    list.add(null); // OK - null is valid for any type
    // list.add("Hello"); // ERROR! Don't know the type
}
```

### Upper Bounded Wildcards (`? extends T`)

```java
// Upper bounded wildcard - accepts T or any subtype of T
public double sumOfList(List<? extends Number> list) {
    double sum = 0.0;
    for (Number num : list) {
        sum += num.doubleValue();
    }
    return sum;
}

// Usage
List<Integer> intList = Arrays.asList(1, 2, 3);
double sum1 = sumOfList(intList); // OK - Integer extends Number

List<Double> doubleList = Arrays.asList(1.1, 2.2, 3.3);
double sum2 = sumOfList(doubleList); // OK - Double extends Number

List<Long> longList = Arrays.asList(1L, 2L, 3L);
double sum3 = sumOfList(longList); // OK - Long extends Number

// Cannot add to upper bounded wildcard (except null)
public void addNumber(List<? extends Number> list) {
    // list.add(new Integer(1)); // ERROR! Don't know exact type
    list.add(null); // OK
}
```

### Lower Bounded Wildcards (`? super T`)

```java
// Lower bounded wildcard - accepts T or any supertype of T
public void addNumbers(List<? super Integer> list) {
    list.add(1); // OK - can add Integer
    list.add(2); // OK - can add Integer
    // list.add(new Number()); // ERROR! Number might not be Integer
}

// Usage
List<Number> numberList = new ArrayList<>();
addNumbers(numberList); // OK - Number is supertype of Integer

List<Object> objectList = new ArrayList<>();
addNumbers(objectList); // OK - Object is supertype of Integer

List<Integer> intList = new ArrayList<>();
addNumbers(intList); // OK - Integer is Integer

// Can read, but only as Object
public void readList(List<? super Integer> list) {
    Object obj = list.get(0); // OK - can read as Object
    // Integer i = list.get(0); // ERROR! Don't know exact type
}
```

### PECS Principle (Producer Extends, Consumer Super)

**PECS = Producer Extends, Consumer Super**

```java
// PRODUCER: Produces/returns elements - use extends
public void processNumbers(List<? extends Number> numbers) {
    for (Number num : numbers) { // Can read as Number
        System.out.println(num.doubleValue());
    }
    // Cannot add: numbers.add(new Integer(1)); // ERROR
}

// CONSUMER: Consumes/accepts elements - use super
public void addIntegers(List<? super Integer> list) {
    list.add(1); // Can add Integer
    list.add(2); // Can add Integer
    // Cannot read as Integer: Integer i = list.get(0); // ERROR
}

// Real-world example: Collections.copy
public static <T> void copy(List<? super T> dest, List<? extends T> src) {
    // dest consumes T (use super)
    // src produces T (use extends)
    for (int i = 0; i < src.size(); i++) {
        dest.add(src.get(i));
    }
}

// Usage
List<Number> dest = new ArrayList<>();
List<Integer> src = Arrays.asList(1, 2, 3);
copy(dest, src); // OK - dest accepts Number, src provides Integer
```

### Wildcard Examples

```java
// Example 1: Maximum element
public static <T extends Comparable<? super T>> T max(List<? extends T> list) {
    if (list.isEmpty()) {
        throw new IllegalArgumentException("List is empty");
    }
    T max = list.get(0);
    for (T element : list) {
        if (element.compareTo(max) > 0) {
            max = element;
        }
    }
    return max;
}

// Example 2: Swap elements
public static void swap(List<?> list, int i, int j) {
    swapHelper(list, i, j);
}

// Helper method with type parameter
private static <T> void swapHelper(List<T> list, int i, int j) {
    T temp = list.get(i);
    list.set(i, list.get(j));
    list.set(j, temp);
}

// Example 3: Count elements
public static int count(List<?> list, Object target) {
    int count = 0;
    for (Object obj : list) {
        if (obj.equals(target)) {
            count++;
        }
    }
    return count;
}
```

---

## Bounded Type Parameters

### Upper Bounded Type Parameters

```java
// Upper bound: T must be Number or subtype of Number
public class NumberBox<T extends Number> {
    private T value;
    
    public NumberBox(T value) {
        this.value = value;
    }
    
    public T getValue() {
        return value;
    }
    
    // Can use Number methods
    public double getDoubleValue() {
        return value.doubleValue();
    }
}

// Usage
NumberBox<Integer> intBox = new NumberBox<>(123);
NumberBox<Double> doubleBox = new NumberBox<>(45.67);
// NumberBox<String> stringBox = new NumberBox<>("Hello"); // ERROR!

// Multiple bounds
public class Calculator<T extends Number & Comparable<T>> {
    private T value;
    
    public Calculator(T value) {
        this.value = value;
    }
    
    public T getValue() {
        return value;
    }
    
    public boolean isGreaterThan(T other) {
        return value.compareTo(other) > 0;
    }
}

// Usage
Calculator<Integer> calc = new Calculator<>(10);
boolean result = calc.isGreaterThan(5); // OK
```

### Lower Bounded Type Parameters (Not Directly Supported)

```java
// Java doesn't support lower bounds on type parameters directly
// But you can use wildcards with super

// This is not valid:
// public class Box<T super Integer> { } // ERROR!

// But this is valid:
public void addToBox(Box<? super Integer> box) {
    box.setValue(123); // OK
}
```

### Multiple Bounds

```java
// T must extend Number AND implement Comparable
public class ComparableNumber<T extends Number & Comparable<T>> {
    private T value;
    
    public ComparableNumber(T value) {
        this.value = value;
    }
    
    public T getValue() {
        return value;
    }
    
    public int compareTo(ComparableNumber<T> other) {
        return value.compareTo(other.value);
    }
    
    public double getDoubleValue() {
        return value.doubleValue();
    }
}

// Usage
ComparableNumber<Integer> num1 = new ComparableNumber<>(10);
ComparableNumber<Integer> num2 = new ComparableNumber<>(20);
int result = num1.compareTo(num2); // OK
```

### Real-World Example: Generic Sorting

```java
public class SortUtils {
    // Generic method with bounded type parameter
    public static <T extends Comparable<T>> void bubbleSort(T[] array) {
        int n = array.length;
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (array[j].compareTo(array[j + 1]) > 0) {
                    T temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
    }
    
    // With custom comparator
    public static <T> void bubbleSort(T[] array, Comparator<? super T> comparator) {
        int n = array.length;
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (comparator.compare(array[j], array[j + 1]) > 0) {
                    T temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
    }
}

// Usage
Integer[] numbers = {3, 1, 4, 1, 5};
SortUtils.bubbleSort(numbers); // Works because Integer implements Comparable

String[] names = {"Charlie", "Alice", "Bob"};
SortUtils.bubbleSort(names); // Works because String implements Comparable
```

---

## Type Erasure

### What is Type Erasure?

Type erasure is the process by which the Java compiler removes all generic type information at compile time. This means that at runtime, generic types are replaced with their raw types or bounds.

### How Type Erasure Works

```java
// Source code (what you write)
public class Box<T> {
    private T value;
    
    public void setValue(T value) {
        this.value = value;
    }
    
    public T getValue() {
        return value;
    }
}

// After type erasure (what JVM sees)
public class Box {
    private Object value; // T replaced with Object (upper bound)
    
    public void setValue(Object value) {
        this.value = value;
    }
    
    public Object getValue() {
        return value;
    }
}
```

### Type Erasure Rules

1. **Unbounded type parameters** → `Object`
```java
// Before erasure
public class Box<T> { }

// After erasure
public class Box { }
```

2. **Bounded type parameters** → **Upper bound**
```java
// Before erasure
public class NumberBox<T extends Number> { }

// After erasure
public class NumberBox { // T replaced with Number
    private Number value; // Not Object!
}
```

3. **Multiple bounds** → **First bound**
```java
// Before erasure
public class Box<T extends Number & Comparable<T>> { }

// After erasure
public class Box { // T replaced with Number (first bound)
    private Number value;
}
```

### Implications of Type Erasure

#### 1. Cannot Create Generic Arrays

```java
// ❌ ERROR: Cannot create generic arrays
// T[] array = new T[10]; // Compile error!

// Workaround: Use Object array and cast
public class GenericArray<T> {
    private Object[] array;
    
    @SuppressWarnings("unchecked")
    public GenericArray(int size) {
        array = new Object[size];
    }
    
    @SuppressWarnings("unchecked")
    public T get(int index) {
        return (T) array[index];
    }
    
    public void set(int index, T value) {
        array[index] = value;
    }
}
```

#### 2. Cannot Use instanceof with Generics

```java
// ❌ ERROR: Cannot use instanceof with generic types
// if (obj instanceof List<String>) { } // Compile error!

// Workaround: Use raw type
if (obj instanceof List) {
    List<?> list = (List<?>) obj;
    // Process list
}
```

#### 3. Cannot Overload Methods with Same Erased Signature

```java
// ❌ ERROR: Both methods have same erased signature
// public void print(List<String> list) { }
// public void print(List<Integer> list) { } // Compile error!

// Workaround: Use different method names or parameters
public void printStrings(List<String> list) { }
public void printIntegers(List<Integer> list) { }
```

#### 4. Cannot Catch Generic Exceptions

```java
// ❌ ERROR: Cannot catch generic exceptions
// catch (Exception<T> e) { } // Compile error!

// Workaround: Catch the raw type
try {
    // Some code
} catch (Exception e) {
    // Handle exception
}
```

### Bridge Methods

The compiler generates bridge methods to maintain polymorphism:

```java
// Source code
public class Node<T> {
    public void setData(T data) {
        // Implementation
    }
}

public class MyNode extends Node<Integer> {
    @Override
    public void setData(Integer data) {
        // Implementation
    }
}

// After type erasure, compiler generates bridge method
public class MyNode extends Node {
    // Overridden method
    public void setData(Integer data) {
        // Implementation
    }
    
    // Bridge method (generated by compiler)
    public void setData(Object data) {
        setData((Integer) data); // Calls the overridden method
    }
}
```

### Reifiable vs Non-Reifiable Types

**Reifiable Types:** Types whose information is fully available at runtime
- Primitive types
- Non-generic classes/interfaces
- Raw types
- Arrays of reifiable types

**Non-Reifiable Types:** Types whose information is erased at runtime
- Generic types (except unbounded wildcards)
- Parameterized types
- Type variables

```java
// Reifiable
String.class // OK
Integer[].class // OK
List.class // OK (raw type)

// Non-reifiable
List<String>.class // ERROR!
T.class // ERROR!
```

---

## Type Safety

### Compile-Time Type Safety

```java
// Type-safe operations
List<String> stringList = new ArrayList<>();
stringList.add("Hello"); // OK
stringList.add(123); // Compile-time error!

String s = stringList.get(0); // Type-safe, no cast needed
// Integer i = stringList.get(0); // Compile-time error!
```

### Runtime Type Safety

```java
// Type erasure means runtime checks are limited
List<String> stringList = new ArrayList<>();
List rawList = stringList; // Raw type reference
rawList.add(123); // No compile-time error, but unsafe!

// Runtime check needed
String s = stringList.get(0); // ClassCastException at runtime!
```

### Ensuring Type Safety

```java
// 1. Use generics consistently
List<String> list = new ArrayList<>(); // Good
List list = new ArrayList(); // Bad - raw type

// 2. Avoid raw types
// ❌ BAD
List rawList = new ArrayList();
rawList.add("String");
rawList.add(123);

// ✅ GOOD
List<String> typedList = new ArrayList<>();
typedList.add("String");
// typedList.add(123); // Compile-time error

// 3. Use wildcards appropriately
public void process(List<? extends Number> numbers) {
    // Can read as Number
    for (Number num : numbers) {
        // Process
    }
    // Cannot add (except null)
}

// 4. Avoid unchecked warnings
@SuppressWarnings("unchecked") // Use sparingly and document why
List<String> list = (List<String>) someObject;
```

### Type Safety with Collections

```java
// Type-safe collection operations
List<String> names = new ArrayList<>();
names.add("Alice");
names.add("Bob");

// Type-safe iteration
for (String name : names) {
    System.out.println(name.toUpperCase()); // No cast needed
}

// Type-safe stream operations
List<String> upperCase = names.stream()
    .map(String::toUpperCase) // Type-safe
    .collect(Collectors.toList());

// Type-safe method references
names.forEach(System.out::println); // Type-safe
```

---

## Common Patterns and Best Practices

### 1. Generic Factory Pattern

```java
public class Factory {
    public static <T> T create(Class<T> clazz) {
        try {
            return clazz.getDeclaredConstructor().newInstance();
        } catch (Exception e) {
            throw new RuntimeException("Cannot create instance", e);
        }
    }
}

// Usage
String str = Factory.create(String.class);
Integer num = Factory.create(Integer.class);
```

### 2. Generic Builder Pattern

```java
public class Builder<T> {
    private T object;
    
    public Builder(Class<T> clazz) {
        try {
            this.object = clazz.getDeclaredConstructor().newInstance();
        } catch (Exception e) {
            throw new RuntimeException("Cannot create instance", e);
        }
    }
    
    public Builder<T> with(Consumer<T> setter) {
        setter.accept(object);
        return this;
    }
    
    public T build() {
        return object;
    }
}

// Usage
Person person = new Builder<>(Person.class)
    .with(p -> p.setName("Alice"))
    .with(p -> p.setAge(25))
    .build();
```

### 3. Generic Singleton Pattern

```java
public class Singleton<T> {
    private static final Map<Class<?>, Object> instances = new HashMap<>();
    
    @SuppressWarnings("unchecked")
    public static <T> T getInstance(Class<T> clazz) {
        return (T) instances.computeIfAbsent(clazz, k -> {
            try {
                return clazz.getDeclaredConstructor().newInstance();
            } catch (Exception e) {
                throw new RuntimeException("Cannot create instance", e);
            }
        });
    }
}
```

### 4. Generic Repository Pattern

```java
public interface Repository<T, ID> {
    T findById(ID id);
    List<T> findAll();
    void save(T entity);
    void delete(ID id);
}

public class UserRepository implements Repository<User, String> {
    @Override
    public User findById(String id) {
        // Implementation
        return new User();
    }
    
    @Override
    public List<User> findAll() {
        // Implementation
        return new ArrayList<>();
    }
    
    @Override
    public void save(User entity) {
        // Implementation
    }
    
    @Override
    public void delete(String id) {
        // Implementation
    }
}
```

### 5. Generic Comparator

```java
public class GenericComparator {
    public static <T extends Comparable<T>> Comparator<T> naturalOrder() {
        return Comparator.naturalOrder();
    }
    
    public static <T> Comparator<T> comparing(
            Function<? super T, ? extends Comparable> keyExtractor) {
        return Comparator.comparing(keyExtractor);
    }
}

// Usage
List<Person> people = Arrays.asList(
    new Person("Alice", 25),
    new Person("Bob", 30)
);

people.sort(GenericComparator.comparing(Person::getAge));
```

### 6. Generic Cache

```java
public class Cache<K, V> {
    private final Map<K, V> cache = new HashMap<>();
    private final Function<K, V> loader;
    
    public Cache(Function<K, V> loader) {
        this.loader = loader;
    }
    
    public V get(K key) {
        return cache.computeIfAbsent(key, loader);
    }
    
    public void put(K key, V value) {
        cache.put(key, value);
    }
    
    public void clear() {
        cache.clear();
    }
}

// Usage
Cache<String, User> userCache = new Cache<>(id -> 
    userRepository.findById(id)
);
User user = userCache.get("123"); // Loads if not cached
```

---

## Advanced Topics

### Recursive Type Bounds

```java
// T must be comparable to itself
public class MaxFinder {
    public static <T extends Comparable<T>> T max(T a, T b) {
        return a.compareTo(b) > 0 ? a : b;
    }
    
    public static <T extends Comparable<T>> T max(List<T> list) {
        if (list.isEmpty()) {
            throw new IllegalArgumentException("List is empty");
        }
        T max = list.get(0);
        for (T element : list) {
            if (element.compareTo(max) > 0) {
                max = element;
            }
        }
        return max;
    }
}

// Usage
Integer maxInt = MaxFinder.max(10, 20);
String maxStr = MaxFinder.max("Alice", "Bob");
```

### Self-Bounded Types

```java
// Self-bounded generic type
public abstract class Comparable<T extends Comparable<T>> {
    public abstract int compareTo(T other);
    
    public boolean isGreaterThan(T other) {
        return compareTo(other) > 0;
    }
}

// Usage
public class Person extends Comparable<Person> {
    private String name;
    private int age;
    
    @Override
    public int compareTo(Person other) {
        return Integer.compare(this.age, other.age);
    }
}
```

### Generic Type Inference with Lambdas

```java
public class LambdaGenerics {
    // Generic method with lambda
    public static <T> List<T> filter(List<T> list, Predicate<? super T> predicate) {
        List<T> result = new ArrayList<>();
        for (T element : list) {
            if (predicate.test(element)) {
                result.add(element);
            }
        }
        return result;
    }
    
    // Generic method with Function
    public static <T, R> List<R> map(List<T> list, Function<? super T, ? extends R> mapper) {
        List<R> result = new ArrayList<>();
        for (T element : list) {
            result.add(mapper.apply(element));
        }
        return result;
    }
}

// Usage
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
List<String> filtered = LambdaGenerics.filter(names, s -> s.length() > 3);
List<Integer> lengths = LambdaGenerics.map(names, String::length);
```

### Generic Varargs

```java
@SafeVarargs
public static <T> List<T> asList(T... elements) {
    List<T> list = new ArrayList<>();
    for (T element : elements) {
        list.add(element);
    }
    return list;
}

// Usage
List<String> names = asList("Alice", "Bob", "Charlie");
List<Integer> numbers = asList(1, 2, 3, 4, 5);
```

### Generic Reflection

```java
public class GenericReflection {
    public static <T> T createInstance(Class<T> clazz) {
        try {
            return clazz.getDeclaredConstructor().newInstance();
        } catch (Exception e) {
            throw new RuntimeException("Cannot create instance", e);
        }
    }
    
    public static Type getGenericType(Field field) {
        return field.getGenericType();
    }
    
    @SuppressWarnings("unchecked")
    public static <T> Class<T> getClassFromType(Type type) {
        if (type instanceof Class) {
            return (Class<T>) type;
        } else if (type instanceof ParameterizedType) {
            ParameterizedType pt = (ParameterizedType) type;
            return (Class<T>) pt.getRawType();
        }
        throw new IllegalArgumentException("Cannot determine class from type");
    }
}
```

---

## Common Pitfalls and Solutions

### 1. Raw Types

```java
// ❌ BAD: Using raw types
List list = new ArrayList();
list.add("String");
list.add(123);
String s = (String) list.get(1); // ClassCastException!

// ✅ GOOD: Using generics
List<String> list = new ArrayList<>();
list.add("String");
// list.add(123); // Compile-time error
String s = list.get(0); // Type-safe
```

### 2. Unchecked Warnings

```java
// ❌ BAD: Ignoring unchecked warnings
@SuppressWarnings("unchecked")
List<String> list = (List<String>) someObject; // Dangerous!

// ✅ GOOD: Fix the root cause
// Use proper type from the start
List<String> list = getStringList(); // Type-safe method
```

### 3. Wildcard Confusion

```java
// ❌ BAD: Misusing wildcards
public void addToList(List<?> list) {
    list.add("String"); // ERROR! Can't add to unbounded wildcard
}

// ✅ GOOD: Use type parameter when you need to add
public <T> void addToList(List<T> list, T element) {
    list.add(element); // OK
}
```

### 4. Type Erasure Limitations

```java
// ❌ BAD: Trying to use instanceof with generics
if (obj instanceof List<String>) { } // Compile error!

// ✅ GOOD: Use raw type or wildcard
if (obj instanceof List) {
    List<?> list = (List<?>) obj;
    // Process list
}
```

### 5. Generic Array Creation

```java
// ❌ BAD: Cannot create generic arrays
// T[] array = new T[10]; // Compile error!

// ✅ GOOD: Use ArrayList or Object array
List<T> list = new ArrayList<>(); // Preferred
// Or
Object[] array = new Object[10];
@SuppressWarnings("unchecked")
T[] typedArray = (T[]) array;
```

### 6. Overloading with Generics

```java
// ❌ BAD: Cannot overload with same erased signature
// public void process(List<String> list) { }
// public void process(List<Integer> list) { } // Compile error!

// ✅ GOOD: Use different method names or parameters
public void processStrings(List<String> list) { }
public void processIntegers(List<Integer> list) { }
```

---

## Summary

### Key Takeaways

1. **Generics provide type safety** at compile time
2. **Type erasure** removes generic information at runtime
3. **Wildcards** (`?`, `? extends T`, `? super T`) provide flexibility
4. **Bounded type parameters** (`T extends U`) restrict types
5. **PECS principle** guides wildcard usage
6. **Avoid raw types** for type safety
7. **Use generics consistently** throughout your code

### When to Use Generics

- **Collections**: Always use generic collections
- **APIs**: Design generic APIs for flexibility
- **Algorithms**: Write generic algorithms that work with any type
- **Data Structures**: Create reusable data structures
- **Frameworks**: Build flexible frameworks

### Best Practices

1. ✅ Use generics for all collections
2. ✅ Prefer type parameters over wildcards when you need to add elements
3. ✅ Use wildcards for maximum flexibility in method parameters
4. ✅ Follow PECS principle (Producer Extends, Consumer Super)
5. ✅ Avoid raw types
6. ✅ Use bounded type parameters when you need type-specific operations
7. ✅ Document generic constraints clearly

---

*This guide provides comprehensive coverage of Java Generics and Type Safety. Apply these concepts to write type-safe, maintainable, and flexible code.*

