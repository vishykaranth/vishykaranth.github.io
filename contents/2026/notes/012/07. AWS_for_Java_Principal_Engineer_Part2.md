# AWS for Java Principal Engineers

## Part 2: Application Services and Serverless

---

## Table of Contents

1. [Relational Database Service (RDS)](#1-relational-database-service-rds)
2. [DynamoDB](#2-dynamodb)
3. [ElastiCache](#3-elasticache)
4. [Simple Queue Service (SQS)](#4-simple-queue-service-sqs)
5. [Simple Notification Service (SNS)](#5-simple-notification-service-sns)
6. [EventBridge](#6-eventbridge)
7. [Lambda](#7-lambda)
8. [API Gateway](#8-api-gateway)

---

## 1. Relational Database Service (RDS)

### 1.1 RDS Overview

**RDS** is a managed relational database service supporting PostgreSQL, MySQL, MariaDB, Oracle, SQL Server, and Amazon Aurora.

**Key Benefits**:
- **Managed**: AWS handles backups, patching, monitoring
- **Multi-AZ**: High availability with automatic failover
- **Automated Backups**: Point-in-time recovery
- **Scaling**: Easy scaling (storage and compute)

### 1.2 RDS Database Engines

```
RDS Engines:
├── PostgreSQL
│   └── Open source, feature-rich
├── MySQL
│   └── Popular, widely used
├── MariaDB
│   └── MySQL fork, open source
├── Oracle
│   └── Enterprise, licensed
├── SQL Server
│   └── Microsoft, Windows-based
└── Aurora
    └── AWS-optimized, MySQL/PostgreSQL compatible
```

### 1.3 RDS Instance Classes

```
Instance Classes:
├── db.t3 (Burstable)
│   └── Development, testing
├── db.t4g (Burstable, ARM)
│   └── Cost-effective, ARM-based
├── db.m5 (General Purpose)
│   └── Production workloads
├── db.r5 (Memory Optimized)
│   └── Memory-intensive workloads
└── db.x1 (Memory Optimized)
    └── Very large memory
```

### 1.4 RDS Features

**Multi-AZ Deployment**:
- Primary DB in one AZ, standby in another
- Automatic failover (< 60 seconds)
- Synchronous replication

**Read Replicas**:
- Asynchronous replication
- Scale read operations
- Can be promoted to primary

**Automated Backups**:
- Daily backups (retention: 0-35 days)
- Point-in-time recovery
- Backup window configurable

**Encryption**:
- Encryption at rest (AES-256)
- Encryption in transit (SSL/TLS)
- KMS key management

### 1.5 Java Integration: RDS with Spring Boot

**Maven Dependencies**:
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
</dependency>
```

**Application Properties**:
```yaml
# application.yml
spring:
  datasource:
    url: jdbc:postgresql://${DB_HOST}:5432/${DB_NAME}
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
  
  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: false
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        format_sql: true
        jdbc:
          batch_size: 20
        order_inserts: true
        order_updates: true
```

**Entity Example**:
```java
@Entity
@Table(name = "users")
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, unique = true)
    private String email;
    
    @Column(nullable = false)
    private String name;
    
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }
    
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
    
    // Getters and setters
}
```

**Repository**:
```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    Optional<User> findByEmail(String email);
    
    @Query("SELECT u FROM User u WHERE u.createdAt >= :since")
    List<User> findRecentUsers(@Param("since") LocalDateTime since);
    
    @Modifying
    @Query("UPDATE User u SET u.name = :name WHERE u.id = :id")
    void updateName(@Param("id") Long id, @Param("name") String name);
}
```

**Service with Connection Pooling**:
```java
@Service
@Transactional
public class UserService {
    
    private final UserRepository userRepository;
    
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    public User createUser(String email, String name) {
        if (userRepository.findByEmail(email).isPresent()) {
            throw new UserAlreadyExistsException("User with email already exists: " + email);
        }
        
        User user = new User();
        user.setEmail(email);
        user.setName(name);
        
        return userRepository.save(user);
    }
    
    @Transactional(readOnly = true)
    public Optional<User> getUser(Long id) {
        return userRepository.findById(id);
    }
    
    @Transactional(readOnly = true)
    public List<User> getRecentUsers(int days) {
        LocalDateTime since = LocalDateTime.now().minusDays(days);
        return userRepository.findRecentUsers(since);
    }
}
```

**Connection Pool Monitoring**:
```java
@Component
@Slf4j
public class DatabaseHealthIndicator implements HealthIndicator {
    
    @Autowired
    private DataSource dataSource;
    
    @Override
    public Health health() {
        try {
            if (dataSource instanceof HikariDataSource) {
                HikariDataSource hikariDataSource = (HikariDataSource) dataSource;
                HikariPoolMXBean poolBean = hikariDataSource.getHikariPoolMXBean();
                
                return Health.up()
                    .withDetail("active", poolBean.getActiveConnections())
                    .withDetail("idle", poolBean.getIdleConnections())
                    .withDetail("total", poolBean.getTotalConnections())
                    .withDetail("threadsAwaitingConnection", poolBean.getThreadsAwaitingConnection())
                    .build();
            }
            
            return Health.up().build();
            
        } catch (Exception e) {
            return Health.down()
                .withDetail("error", e.getMessage())
                .build();
        }
    }
}
```

---

## 2. DynamoDB

### 2.1 DynamoDB Overview

**DynamoDB** is a fully managed NoSQL database service.

**Key Features**:
- **Serverless**: No servers to manage
- **Scalable**: Auto-scaling, handles millions of requests
- **Fast**: Single-digit millisecond latency
- **Durable**: 99.999999999% (11 9's) durability

### 2.2 DynamoDB Data Model

**Tables**: Collection of items
**Items**: Collection of attributes (like rows)
**Attributes**: Key-value pairs (like columns)

**Primary Keys**:
- **Partition Key**: Single attribute (e.g., `userId`)
- **Composite Key**: Partition key + Sort key (e.g., `userId` + `orderId`)

### 2.3 DynamoDB Features

**On-Demand**: Pay per request, auto-scaling
**Provisioned**: Set capacity units, cost-effective for predictable workloads
**Global Tables**: Multi-region replication
**Streams**: Capture table changes
**TTL**: Automatically delete expired items

### 2.4 Java Integration: DynamoDB

**Maven Dependencies**:
```xml
<dependency>
    <groupId>software.amazon.awssdk</groupId>
    <artifactId>dynamodb</artifactId>
</dependency>
<dependency>
    <groupId>software.amazon.awssdk</groupId>
    <artifactId>dynamodb-enhanced</artifactId>
</dependency>
```

**DynamoDB Entity**:
```java
@DynamoDbBean
public class User {
    
    private String userId;
    private String email;
    private String name;
    private LocalDateTime createdAt;
    
    @DynamoDbPartitionKey
    public String getUserId() {
        return userId;
    }
    
    public void setUserId(String userId) {
        this.userId = userId;
    }
    
    @DynamoDbAttribute("email")
    public String getEmail() {
        return email;
    }
    
    public void setEmail(String email) {
        this.email = email;
    }
    
    @DynamoDbAttribute("name")
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    @DynamoDbAttribute("created_at")
    public LocalDateTime getCreatedAt() {
        return createdAt;
    }
    
    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }
}
```

**DynamoDB Repository**:
```java
@Repository
public class UserRepository {
    
    private final DynamoDbEnhancedClient enhancedClient;
    private final DynamoDbTable<User> userTable;
    
    public UserRepository(DynamoDbEnhancedClient enhancedClient) {
        this.enhancedClient = enhancedClient;
        this.userTable = enhancedClient.table("users", 
            TableSchema.fromBean(User.class));
    }
    
    public void save(User user) {
        if (user.getCreatedAt() == null) {
            user.setCreatedAt(LocalDateTime.now());
        }
        userTable.putItem(user);
    }
    
    public Optional<User> findById(String userId) {
        Key key = Key.builder()
            .partitionValue(userId)
            .build();
        
        User user = userTable.getItem(key);
        return Optional.ofNullable(user);
    }
    
    public void delete(String userId) {
        Key key = Key.builder()
            .partitionValue(userId)
            .build();
        
        userTable.deleteItem(key);
    }
    
    public List<User> findAll() {
        return userTable.scan()
            .items()
            .stream()
            .collect(Collectors.toList());
    }
}
```

**DynamoDB Configuration**:
```java
@Configuration
public class DynamoDbConfiguration {
    
    @Bean
    public DynamoDbClient dynamoDbClient(@Value("${aws.region}") String region) {
        return DynamoDbClient.builder()
            .region(Region.of(region))
            .build();
    }
    
    @Bean
    public DynamoDbEnhancedClient dynamoDbEnhancedClient(DynamoDbClient dynamoDbClient) {
        return DynamoDbEnhancedClient.builder()
            .dynamoDbClient(dynamoDbClient)
            .build();
    }
}
```

**Service Example**:
```java
@Service
public class UserService {
    
    private final UserRepository userRepository;
    
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    public User createUser(String email, String name) {
        String userId = UUID.randomUUID().toString();
        
        User user = new User();
        user.setUserId(userId);
        user.setEmail(email);
        user.setName(name);
        
        userRepository.save(user);
        return user;
    }
    
    public Optional<User> getUser(String userId) {
        return userRepository.findById(userId);
    }
    
    public void deleteUser(String userId) {
        userRepository.delete(userId);
    }
}
```

---

## 3. ElastiCache

### 3.1 ElastiCache Overview

**ElastiCache** is a managed in-memory caching service supporting Redis and Memcached.

**Use Cases**:
- **Session Storage**: Store user sessions
- **Caching**: Cache database queries, API responses
- **Real-time Analytics**: Fast data processing
- **Pub/Sub**: Real-time messaging

### 3.2 ElastiCache Engines

**Redis**:
- Data structures (strings, lists, sets, hashes)
- Persistence (RDB, AOF)
- Replication and clustering
- Pub/Sub, transactions

**Memcached**:
- Simple key-value store
- Multi-threaded
- No persistence
- Simpler than Redis

### 3.3 Java Integration: ElastiCache (Redis)

**Maven Dependencies**:
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<dependency>
    <groupId>redis.clients</groupId>
    <artifactId>jedis</artifactId>
</dependency>
```

**Application Properties**:
```yaml
spring:
  redis:
    host: ${REDIS_HOST}
    port: ${REDIS_PORT:6379}
    password: ${REDIS_PASSWORD:}
    timeout: 2000ms
    jedis:
      pool:
        max-active: 20
        max-idle: 10
        min-idle: 5
```

**Redis Configuration**:
```java
@Configuration
@EnableCaching
public class RedisConfiguration {
    
    @Bean
    public JedisConnectionFactory jedisConnectionFactory(
            @Value("${spring.redis.host}") String host,
            @Value("${spring.redis.port}") int port,
            @Value("${spring.redis.password:}") String password) {
        
        JedisConnectionFactory factory = new JedisConnectionFactory();
        factory.setHostName(host);
        factory.setPort(port);
        if (!password.isEmpty()) {
            factory.setPassword(password);
        }
        return factory;
    }
    
    @Bean
    public RedisTemplate<String, Object> redisTemplate(
            JedisConnectionFactory connectionFactory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        return template;
    }
    
    @Bean
    public CacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofHours(1))
            .serializeKeysWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new GenericJackson2JsonRedisSerializer()));
        
        return RedisCacheManager.builder(connectionFactory)
            .cacheDefaults(config)
            .build();
    }
}
```

**Caching Service**:
```java
@Service
public class ProductService {
    
    private final ProductRepository productRepository;
    
    public ProductService(ProductRepository productRepository) {
        this.productRepository = productRepository;
    }
    
    @Cacheable(value = "products", key = "#id")
    public Product getProduct(Long id) {
        return productRepository.findById(id)
            .orElseThrow(() -> new ProductNotFoundException("Product not found: " + id));
    }
    
    @CacheEvict(value = "products", key = "#product.id")
    public Product updateProduct(Product product) {
        return productRepository.save(product);
    }
    
    @CacheEvict(value = "products", allEntries = true)
    public void clearCache() {
        // Cache cleared
    }
}
```

**Redis Service (Direct Access)**:
```java
@Service
public class RedisService {
    
    private final RedisTemplate<String, Object> redisTemplate;
    
    public RedisService(RedisTemplate<String, Object> redisTemplate) {
        this.redisTemplate = redisTemplate;
    }
    
    public void set(String key, Object value, Duration expiration) {
        redisTemplate.opsForValue().set(key, value, expiration);
    }
    
    public Optional<Object> get(String key) {
        return Optional.ofNullable(redisTemplate.opsForValue().get(key));
    }
    
    public void delete(String key) {
        redisTemplate.delete(key);
    }
    
    public void setHash(String key, String hashKey, Object value) {
        redisTemplate.opsForHash().put(key, hashKey, value);
    }
    
    public Optional<Object> getHash(String key, String hashKey) {
        return Optional.ofNullable(redisTemplate.opsForHash().get(key, hashKey));
    }
    
    public void publish(String channel, Object message) {
        redisTemplate.convertAndSend(channel, message);
    }
}
```

---

## 4. Simple Queue Service (SQS)

### 4.1 SQS Overview

**SQS** is a fully managed message queuing service.

**Key Features**:
- **Decoupling**: Decouple components
- **Scalability**: Auto-scaling
- **Reliability**: Messages stored redundantly
- **FIFO Queues**: First-In-First-Out ordering

### 4.2 SQS Queue Types

**Standard Queue**:
- Unlimited throughput
- At-least-once delivery
- Best-effort ordering
- Use case: High throughput, order not critical

**FIFO Queue**:
- Exactly-once processing
- First-In-First-Out ordering
- Limited throughput (3,000 messages/second)
- Use case: Order critical, no duplicates

### 4.3 Java Integration: SQS

**Maven Dependencies**:
```xml
<dependency>
    <groupId>software.amazon.awssdk</groupId>
    <artifactId>sqs</artifactId>
</dependency>
```

**SQS Service**:
```java
@Service
@Slf4j
public class SqsService {
    
    private final SqsClient sqsClient;
    private final String queueUrl;
    
    public SqsService(SqsClient sqsClient,
                     @Value("${aws.sqs.queue-url}") String queueUrl) {
        this.sqsClient = sqsClient;
        this.queueUrl = queueUrl;
    }
    
    /**
     * Send message to queue
     */
    public void sendMessage(String messageBody) {
        try {
            SendMessageRequest request = SendMessageRequest.builder()
                .queueUrl(queueUrl)
                .messageBody(messageBody)
                .build();
            
            SendMessageResponse response = sqsClient.sendMessage(request);
            log.info("Message sent to SQS: {}", response.messageId());
            
        } catch (SqsException e) {
            log.error("Error sending message to SQS", e);
            throw new SqsException("Failed to send message", e);
        }
    }
    
    /**
     * Send message with attributes
     */
    public void sendMessage(String messageBody, Map<String, String> attributes) {
        Map<String, MessageAttributeValue> messageAttributes = attributes.entrySet().stream()
            .collect(Collectors.toMap(
                Map.Entry::getKey,
                e -> MessageAttributeValue.builder()
                    .stringValue(e.getValue())
                    .dataType("String")
                    .build()
            ));
        
        SendMessageRequest request = SendMessageRequest.builder()
            .queueUrl(queueUrl)
            .messageBody(messageBody)
            .messageAttributes(messageAttributes)
            .build();
        
        sqsClient.sendMessage(request);
    }
    
    /**
     * Receive messages from queue
     */
    public List<Message> receiveMessages(int maxMessages) {
        ReceiveMessageRequest request = ReceiveMessageRequest.builder()
            .queueUrl(queueUrl)
            .maxNumberOfMessages(maxMessages)
            .waitTimeSeconds(20) // Long polling
            .build();
        
        ReceiveMessageResponse response = sqsClient.receiveMessage(request);
        return response.messages();
    }
    
    /**
     * Delete message from queue
     */
    public void deleteMessage(String receiptHandle) {
        DeleteMessageRequest request = DeleteMessageRequest.builder()
            .queueUrl(queueUrl)
            .receiptHandle(receiptHandle)
            .build();
        
        sqsClient.deleteMessage(request);
    }
}
```

**Message Consumer**:
```java
@Component
@Slf4j
public class OrderMessageConsumer {
    
    private final SqsService sqsService;
    private final OrderService orderService;
    
    @Scheduled(fixedDelay = 5000) // Poll every 5 seconds
    public void processMessages() {
        List<Message> messages = sqsService.receiveMessages(10);
        
        for (Message message : messages) {
            try {
                processMessage(message);
                sqsService.deleteMessage(message.receiptHandle());
            } catch (Exception e) {
                log.error("Error processing message: {}", message.body(), e);
                // Message will become visible again after visibility timeout
            }
        }
    }
    
    private void processMessage(Message message) {
        // Parse message body (JSON)
        ObjectMapper mapper = new ObjectMapper();
        OrderMessage orderMessage = mapper.readValue(message.body(), OrderMessage.class);
        
        // Process order
        orderService.processOrder(orderMessage);
    }
}
```

---

## 5. Simple Notification Service (SNS)

### 5.1 SNS Overview

**SNS** is a fully managed pub/sub messaging service.

**Key Features**:
- **Pub/Sub**: Publish to topics, multiple subscribers
- **Multiple Protocols**: HTTP, HTTPS, Email, SMS, SQS, Lambda
- **Fan-out**: One message to many subscribers
- **Filtering**: Message filtering by attributes

### 5.2 SNS Components

**Topics**: Communication channels
**Subscriptions**: Endpoints receiving messages
**Publishers**: Send messages to topics
**Subscribers**: Receive messages from topics

### 5.3 Java Integration: SNS

**Maven Dependencies**:
```xml
<dependency>
    <groupId>software.amazon.awssdk</groupId>
    <artifactId>sns</artifactId>
</dependency>
```

**SNS Service**:
```java
@Service
@Slf4j
public class SnsService {
    
    private final SnsClient snsClient;
    private final String topicArn;
    
    public SnsService(SnsClient snsClient,
                     @Value("${aws.sns.topic-arn}") String topicArn) {
        this.snsClient = snsClient;
        this.topicArn = topicArn;
    }
    
    /**
     * Publish message to topic
     */
    public void publishMessage(String subject, String message) {
        try {
            PublishRequest request = PublishRequest.builder()
                .topicArn(topicArn)
                .subject(subject)
                .message(message)
                .build();
            
            PublishResponse response = snsClient.publish(request);
            log.info("Message published to SNS: {}", response.messageId());
            
        } catch (SnsException e) {
            log.error("Error publishing message to SNS", e);
            throw new SnsException("Failed to publish message", e);
        }
    }
    
    /**
     * Publish message with attributes
     */
    public void publishMessage(String subject, String message, 
                              Map<String, String> attributes) {
        Map<String, MessageAttributeValue> messageAttributes = attributes.entrySet().stream()
            .collect(Collectors.toMap(
                Map.Entry::getKey,
                e -> MessageAttributeValue.builder()
                    .stringValue(e.getValue())
                    .dataType("String")
                    .build()
            ));
        
        PublishRequest request = PublishRequest.builder()
            .topicArn(topicArn)
            .subject(subject)
            .message(message)
            .messageAttributes(messageAttributes)
            .build();
        
        snsClient.publish(request);
    }
}
```

**Event Publisher**:
```java
@Service
public class OrderEventPublisher {
    
    private final SnsService snsService;
    
    public OrderEventPublisher(SnsService snsService) {
        this.snsService = snsService;
    }
    
    public void publishOrderCreated(Order order) {
        OrderCreatedEvent event = OrderCreatedEvent.builder()
            .orderId(order.getId())
            .userId(order.getUserId())
            .totalAmount(order.getTotalAmount())
            .timestamp(LocalDateTime.now())
            .build();
        
        ObjectMapper mapper = new ObjectMapper();
        String message = mapper.writeValueAsString(event);
        
        snsService.publishMessage("OrderCreated", message, Map.of(
            "eventType", "OrderCreated",
            "orderId", order.getId().toString()
        ));
    }
}
```

---

## 6. EventBridge

### 6.1 EventBridge Overview

**EventBridge** is a serverless event bus for building event-driven applications.

**Key Features**:
- **Event Bus**: Central event routing
- **Rules**: Route events to targets
- **Schema Registry**: Event schemas
- **Integration**: AWS services, SaaS partners, custom apps

### 6.2 EventBridge vs SNS

**EventBridge**:
- Event-driven architecture
- Schema registry
- Rule-based routing
- Integration with AWS services

**SNS**:
- Pub/sub messaging
- Multiple protocols
- Simpler use cases

### 6.3 Java Integration: EventBridge

**Maven Dependencies**:
```xml
<dependency>
    <groupId>software.amazon.awssdk</groupId>
    <artifactId>eventbridge</artifactId>
</dependency>
```

**EventBridge Service**:
```java
@Service
@Slf4j
public class EventBridgeService {
    
    private final EventBridgeClient eventBridgeClient;
    private final String eventBusName;
    
    public EventBridgeService(EventBridgeClient eventBridgeClient,
                             @Value("${aws.eventbridge.bus-name}") String eventBusName) {
        this.eventBridgeClient = eventBridgeClient;
        this.eventBusName = eventBusName;
    }
    
    /**
     * Put event to EventBridge
     */
    public void putEvent(String source, String detailType, Object detail) {
        try {
            ObjectMapper mapper = new ObjectMapper();
            String detailJson = mapper.writeValueAsString(detail);
            
            PutEventsRequestEntry entry = PutEventsRequestEntry.builder()
                .source(source)
                .detailType(detailType)
                .detail(detailJson)
                .eventBusName(eventBusName)
                .build();
            
            PutEventsRequest request = PutEventsRequest.builder()
                .entries(entry)
                .build();
            
            PutEventsResponse response = eventBridgeClient.putEvents(request);
            log.info("Event sent to EventBridge: {}", response.entries().get(0).eventId());
            
        } catch (Exception e) {
            log.error("Error putting event to EventBridge", e);
            throw new EventBridgeException("Failed to put event", e);
        }
    }
}
```

---

## 7. Lambda

### 7.1 Lambda Overview

**Lambda** is a serverless compute service that runs code in response to events.

**Key Features**:
- **Serverless**: No servers to manage
- **Auto-scaling**: Scales automatically
- **Pay-per-use**: Pay only for compute time
- **Multiple Runtimes**: Java, Python, Node.js, etc.

### 7.2 Lambda Use Cases

- **API Backend**: API Gateway integration
- **Event Processing**: SQS, SNS, EventBridge
- **Scheduled Tasks**: CloudWatch Events
- **File Processing**: S3 triggers
- **Data Transformation**: ETL pipelines

### 7.3 Java Lambda Function

**Maven Dependencies**:
```xml
<dependency>
    <groupId>com.amazonaws</groupId>
    <artifactId>aws-lambda-java-core</artifactId>
    <version>1.2.2</version>
</dependency>
<dependency>
    <groupId>com.amazonaws</groupId>
    <artifactId>aws-lambda-java-events</artifactId>
    <version>3.11.0</version>
</dependency>
```

**Lambda Handler**:
```java
public class OrderProcessor implements RequestHandler<SQSEvent, String> {
    
    private final ObjectMapper objectMapper = new ObjectMapper();
    private final OrderService orderService;
    
    public OrderProcessor() {
        // Initialize services
        this.orderService = new OrderService();
    }
    
    @Override
    public String handleRequest(SQSEvent event, Context context) {
        context.getLogger().log("Processing " + event.getRecords().size() + " records");
        
        for (SQSEvent.SQSMessage message : event.getRecords()) {
            try {
                // Parse message
                OrderMessage orderMessage = objectMapper.readValue(
                    message.getBody(), 
                    OrderMessage.class
                );
                
                // Process order
                orderService.processOrder(orderMessage);
                
                context.getLogger().log("Processed order: " + orderMessage.getOrderId());
                
            } catch (Exception e) {
                context.getLogger().log("Error processing message: " + e.getMessage());
                throw new RuntimeException("Failed to process order", e);
            }
        }
        
        return "Successfully processed " + event.getRecords().size() + " orders";
    }
}
```

**Lambda Deployment**:
```xml
<!-- Maven Shade Plugin for Lambda -->
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-shade-plugin</artifactId>
    <version>3.2.4</version>
    <configuration>
        <createDependencyReducedPom>false</createDependencyReducedPom>
    </configuration>
    <executions>
        <execution>
            <phase>package</phase>
            <goals>
                <goal>shade</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

---

## 8. API Gateway

### 8.1 API Gateway Overview

**API Gateway** is a fully managed service for creating, publishing, and managing REST and WebSocket APIs.

**Key Features**:
- **REST APIs**: HTTP/HTTPS APIs
- **WebSocket APIs**: Real-time bidirectional communication
- **Authentication**: IAM, Cognito, Lambda authorizers
- **Throttling**: Rate limiting and quotas
- **Caching**: Response caching
- **Integration**: Lambda, HTTP, AWS services

### 8.2 API Gateway Integration Types

**Lambda Integration**: Invoke Lambda function
**HTTP Integration**: Proxy to HTTP endpoint
**AWS Service Integration**: Direct integration with AWS services
**Mock Integration**: Return mock responses

### 8.3 Java Integration: API Gateway

**Lambda Authorizer**:
```java
public class ApiGatewayAuthorizer implements RequestHandler<APIGatewayProxyRequestEvent, AuthPolicy> {
    
    @Override
    public AuthPolicy handleRequest(APIGatewayProxyRequestEvent event, Context context) {
        String token = event.getHeaders().get("Authorization");
        
        // Validate token
        if (token == null || !token.startsWith("Bearer ")) {
            throw new UnauthorizedException("Missing or invalid token");
        }
        
        // Extract and validate JWT
        String jwt = token.substring(7);
        User user = validateJwt(jwt);
        
        // Generate policy
        String principalId = user.getUserId();
        String methodArn = event.getMethodArn();
        
        AuthPolicy policy = new AuthPolicy(principalId, AuthPolicy.PolicyDocument.getAllowAllPolicy(methodArn));
        policy.getPolicyDocument().setStatement(Collections.singletonList(
            new AuthPolicy.PolicyDocument.Statement(
                AuthPolicy.PolicyDocument.Effect.Allow,
                methodArn
            )
        ));
        
        return policy;
    }
    
    private User validateJwt(String jwt) {
        // JWT validation logic
        // Return user if valid, throw exception if invalid
    }
}
```

**API Gateway Proxy Integration**:
```java
@RestController
@RequestMapping("/api")
public class ApiController {
    
    // API Gateway proxies to this endpoint
    // No special code needed - standard Spring Boot controller
    @GetMapping("/orders/{id}")
    public ResponseEntity<Order> getOrder(@PathVariable Long id) {
        // Standard Spring Boot endpoint
        return ResponseEntity.ok(orderService.getOrder(id));
    }
}
```

---

## Summary of Part 2

### Key Takeaways

1. **RDS**: Managed relational databases, Spring Boot integration
2. **DynamoDB**: NoSQL database, high performance
3. **ElastiCache**: In-memory caching (Redis/Memcached)
4. **SQS**: Message queuing, decoupling components
5. **SNS**: Pub/sub messaging, fan-out
6. **EventBridge**: Event-driven architecture
7. **Lambda**: Serverless compute, event-driven
8. **API Gateway**: REST/WebSocket APIs, integration point

### Next Steps

**Part 3** will cover:
- Container Services (ECS, EKS, Fargate)
- CI/CD (CodePipeline, CodeBuild, CodeDeploy)
- Infrastructure as Code (CloudFormation, Terraform)
- Monitoring and Logging (CloudWatch, X-Ray)

---

**Ready for Part 3?** These application services form the core of production Java applications on AWS.

