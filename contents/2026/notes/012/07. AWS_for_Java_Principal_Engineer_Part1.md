# AWS for Java Principal Engineers

## Part 1: AWS Fundamentals and Core Services

---

## Table of Contents

1. [AWS Overview and Core Concepts](#1-aws-overview-and-core-concepts)
2. [Identity and Access Management (IAM)](#2-identity-and-access-management-iam)
3. [Virtual Private Cloud (VPC)](#3-virtual-private-cloud-vpc)
4. [Elastic Compute Cloud (EC2)](#4-elastic-compute-cloud-ec2)
5. [Simple Storage Service (S3)](#5-simple-storage-service-s3)
6. [Elastic Block Store (EBS)](#6-elastic-block-store-ebs)
7. [Java Integration Examples](#7-java-integration-examples)

---

## 1. AWS Overview and Core Concepts

### 1.1 What is AWS?

**Amazon Web Services (AWS)** is a cloud computing platform providing on-demand computing resources, storage, databases, networking, and other services.

**Key Concepts**:
- **On-Demand**: Pay for what you use
- **Scalable**: Scale up or down as needed
- **Global**: Available in multiple regions worldwide
- **Managed Services**: AWS handles infrastructure management

### 1.2 AWS Global Infrastructure

```
AWS Global Infrastructure:
├── Regions (e.g., us-east-1, eu-west-1)
│   ├── Multiple Availability Zones (AZs)
│   │   ├── Data centers
│   │   └── Independent power, networking, cooling
│   └── Isolated from other regions
└── Edge Locations (CloudFront CDN)
```

**Regions**: Geographic areas (e.g., `us-east-1` - N. Virginia, `eu-west-1` - Ireland)

**Availability Zones (AZs)**: Isolated data centers within a region (e.g., `us-east-1a`, `us-east-1b`)

**Why Multiple AZs?**: High availability, disaster recovery

### 1.3 AWS Service Categories

```
AWS Services:
├── Compute (EC2, Lambda, ECS, EKS)
├── Storage (S3, EBS, EFS, Glacier)
├── Database (RDS, DynamoDB, ElastiCache, Redshift)
├── Networking (VPC, CloudFront, Route 53, API Gateway)
├── Security (IAM, KMS, Secrets Manager, WAF)
├── Management (CloudWatch, CloudFormation, CloudTrail)
└── Application Services (SQS, SNS, EventBridge, Step Functions)
```

### 1.4 AWS Pricing Model

**Pay-as-you-go**: Pay only for what you use
- **Compute**: Per hour/second
- **Storage**: Per GB/month
- **Data Transfer**: Per GB (outbound charges)

**Cost Optimization**:
- Reserved Instances (1-3 year commitments, 30-75% savings)
- Spot Instances (up to 90% savings, can be interrupted)
- Savings Plans (flexible pricing model)

---

## 2. Identity and Access Management (IAM)

### 2.1 IAM Overview

**IAM** manages access to AWS services and resources.

**Key Concepts**:
- **Users**: People or applications
- **Groups**: Collections of users
- **Roles**: Temporary credentials for services/resources
- **Policies**: Permissions (JSON documents)

### 2.2 IAM Components

**Users**:
```yaml
Example: Application User
  Name: myapp-service-user
  Access Type: Programmatic (Access Key ID + Secret)
  Purpose: Application to access AWS services
```

**Groups**:
```yaml
Example: Developers Group
  Name: developers
  Users: [dev1, dev2, dev3]
  Policies: [ReadOnlyAccess, S3FullAccess]
```

**Roles**:
```yaml
Example: EC2 Role
  Name: myapp-ec2-role
  Trust Policy: EC2 service can assume this role
  Policies: [S3ReadAccess, DynamoDBWriteAccess]
  Use Case: EC2 instance accesses S3 and DynamoDB
```

**Policies**:
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "s3:GetObject",
        "s3:PutObject"
      ],
      "Resource": "arn:aws:s3:::my-bucket/*"
    }
  ]
}
```

### 2.3 IAM Best Practices

1. **Least Privilege**: Grant minimum required permissions
2. **Use Roles**: Prefer roles over users for applications
3. **MFA**: Enable Multi-Factor Authentication for users
4. **Rotate Credentials**: Regularly rotate access keys
5. **Separate Accounts**: Use separate accounts for dev/staging/prod

### 2.4 Java Integration: AWS SDK

**Maven Dependency**:
```xml
<dependency>
    <groupId>software.amazon.awssdk</groupId>
    <artifactId>bom</artifactId>
    <version>2.20.0</version>
    <type>pom</type>
    <scope>import</scope>
</dependency>

<dependency>
    <groupId>software.amazon.awssdk</groupId>
    <artifactId>s3</artifactId>
</dependency>
```

**Credentials Configuration**:
```java
// Option 1: Default credential provider chain
// Checks: Environment variables → AWS credentials file → IAM role
S3Client s3Client = S3Client.builder()
    .region(Region.US_EAST_1)
    .build();

// Option 2: Explicit credentials (not recommended for production)
AwsBasicCredentials credentials = AwsBasicCredentials.create(
    "ACCESS_KEY_ID",
    "SECRET_ACCESS_KEY"
);

S3Client s3Client = S3Client.builder()
    .region(Region.US_EAST_1)
    .credentialsProvider(StaticCredentialsProvider.create(credentials))
    .build();

// Option 3: IAM Role (recommended for EC2/ECS)
// No credentials needed - automatically uses instance role
S3Client s3Client = S3Client.builder()
    .region(Region.US_EAST_1)
    .build();
```

---

## 3. Virtual Private Cloud (VPC)

### 3.1 VPC Overview

**VPC** is your isolated network in AWS, similar to a traditional data center network.

**Key Concepts**:
- **VPC**: Isolated network (e.g., `10.0.0.0/16`)
- **Subnets**: Network segments within VPC (e.g., `10.0.1.0/24`)
- **Route Tables**: Define network routing
- **Internet Gateway**: Connect VPC to internet
- **NAT Gateway**: Allow private subnets to access internet

### 3.2 VPC Architecture

```
VPC (10.0.0.0/16)
├── Public Subnet (10.0.1.0/24) - AZ-1
│   ├── Internet Gateway
│   ├── EC2 Instance (Public IP)
│   └── Load Balancer
├── Private Subnet (10.0.2.0/24) - AZ-1
│   ├── NAT Gateway
│   ├── EC2 Instance (No Public IP)
│   └── RDS Database
└── Private Subnet (10.0.3.0/24) - AZ-2
    ├── NAT Gateway
    ├── EC2 Instance (No Public IP)
    └── RDS Database (Multi-AZ)
```

### 3.3 VPC Components

**Subnets**:
```yaml
Public Subnet:
  - Has route to Internet Gateway
  - Resources can have public IPs
  - Use for: Load balancers, bastion hosts

Private Subnet:
  - No direct internet access
  - Uses NAT Gateway for outbound
  - Use for: Application servers, databases
```

**Security Groups** (Firewall):
```yaml
Example: Application Security Group
  Inbound Rules:
    - Port 8080 from ALB Security Group
    - Port 22 from Bastion Security Group
  Outbound Rules:
    - All traffic to 0.0.0.0/0
```

**Network ACLs** (Subnet-level firewall):
```yaml
Example: Private Subnet NACL
  Inbound Rules:
    - Allow 10.0.0.0/16 (VPC traffic)
    - Deny all
  Outbound Rules:
    - Allow all
```

### 3.4 VPC Best Practices

1. **Multi-AZ**: Deploy across multiple AZs for HA
2. **Private Subnets**: Keep databases in private subnets
3. **Security Groups**: Use security groups (stateful) over NACLs
4. **VPC Endpoints**: Use VPC endpoints for AWS services (no internet needed)
5. **CIDR Planning**: Plan CIDR blocks carefully (avoid overlaps)

### 3.5 Java Application: VPC Configuration

**Application Configuration**:
```yaml
# application.yml
aws:
  vpc:
    region: us-east-1
    subnet-ids:
      - subnet-12345678  # Private subnet
      - subnet-87654321  # Private subnet (different AZ)
```

**Java Code**:
```java
@Configuration
public class VpcConfiguration {
    
    @Value("${aws.vpc.region}")
    private String region;
    
    @Bean
    public Region awsRegion() {
        return Region.of(region);
    }
    
    // AWS SDK automatically uses VPC endpoints if configured
    // No special code needed - just configure VPC endpoints in AWS
}
```

---

## 4. Elastic Compute Cloud (EC2)

### 4.1 EC2 Overview

**EC2** provides virtual servers in the cloud.

**Key Concepts**:
- **Instance**: Virtual server
- **AMI**: Amazon Machine Image (template for instances)
- **Instance Types**: Different CPU, memory, storage combinations
- **Security Groups**: Firewall rules

### 4.2 EC2 Instance Types

```
Instance Families:
├── General Purpose (t3, m5, m6i)
│   └── Balanced CPU, memory, networking
├── Compute Optimized (c5, c6i)
│   └── High CPU performance
├── Memory Optimized (r5, r6i)
│   └── High memory
├── Storage Optimized (i3, i4i)
│   └── High IOPS storage
└── GPU Instances (g4, p3)
    └── GPU computing
```

**Example Instance Types**:
- **t3.micro**: 1 vCPU, 1 GB RAM (free tier)
- **t3.medium**: 2 vCPU, 4 GB RAM
- **m5.large**: 2 vCPU, 8 GB RAM
- **c5.xlarge**: 4 vCPU, 8 GB RAM (compute optimized)

### 4.3 EC2 Pricing Models

**On-Demand**: Pay per hour, no commitment
- **Use Case**: Short-term, unpredictable workloads

**Reserved Instances**: 1-3 year commitment, 30-75% savings
- **Use Case**: Steady-state workloads

**Spot Instances**: Up to 90% savings, can be interrupted
- **Use Case**: Flexible, fault-tolerant workloads

**Savings Plans**: Flexible pricing, 1-3 year commitment
- **Use Case**: Consistent usage

### 4.4 EC2 Best Practices

1. **Right-Sizing**: Choose appropriate instance type
2. **Auto Scaling**: Scale based on demand
3. **Use IAM Roles**: Don't store credentials on instances
4. **Security Groups**: Restrict access (least privilege)
5. **Monitoring**: Use CloudWatch for metrics

### 4.5 Java Application on EC2

**Deploying Spring Boot Application**:

**Step 1: Create EC2 Instance**
```bash
# Launch EC2 instance
# - AMI: Amazon Linux 2
# - Instance Type: t3.medium
# - Security Group: Allow port 8080
# - IAM Role: Attach role with S3 access
```

**Step 2: Install Java**
```bash
# SSH into instance
sudo yum update -y
sudo yum install java-11-amazon-corretto -y
java -version
```

**Step 3: Deploy Application**
```bash
# Copy JAR file
scp myapp.jar ec2-user@ec2-instance:/home/ec2-user/

# Run application
java -jar myapp.jar

# Or use systemd service
sudo nano /etc/systemd/system/myapp.service
```

**Systemd Service**:
```ini
[Unit]
Description=My Spring Boot Application
After=network.target

[Service]
Type=simple
User=ec2-user
WorkingDirectory=/home/ec2-user
ExecStart=/usr/bin/java -jar /home/ec2-user/myapp.jar
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
```

**Step 4: Enable Service**
```bash
sudo systemctl daemon-reload
sudo systemctl enable myapp
sudo systemctl start myapp
sudo systemctl status myapp
```

**Java Code: Using IAM Role**:
```java
// Application automatically uses EC2 instance role
// No credentials needed in code

@Service
public class S3Service {
    
    private final S3Client s3Client;
    
    public S3Service() {
        // Automatically uses instance role credentials
        this.s3Client = S3Client.builder()
            .region(Region.US_EAST_1)
            .build();
    }
    
    public void uploadFile(String bucket, String key, byte[] data) {
        s3Client.putObject(PutObjectRequest.builder()
            .bucket(bucket)
            .key(key)
            .build(),
            RequestBody.fromBytes(data)
        );
    }
}
```

---

## 5. Simple Storage Service (S3)

### 5.1 S3 Overview

**S3** is object storage for files, images, videos, backups, etc.

**Key Concepts**:
- **Bucket**: Container for objects (globally unique name)
- **Object**: File with key (path) and data
- **Region**: Bucket location
- **Storage Classes**: Different performance/cost options

### 5.2 S3 Storage Classes

```
S3 Storage Classes:
├── Standard
│   └── General purpose, 99.99% durability
├── Intelligent-Tiering
│   └── Automatically moves between tiers
├── Standard-IA (Infrequent Access)
│   └── Lower cost, retrieval fee
├── One Zone-IA
│   └── Single AZ, lower cost
├── Glacier Instant Retrieval
│   └── Archive, instant access
├── Glacier Flexible Retrieval
│   └── Archive, 1-5 minute retrieval
└── Glacier Deep Archive
    └── Lowest cost, 12-hour retrieval
```

### 5.3 S3 Features

**Versioning**: Keep multiple versions of objects
**Lifecycle Policies**: Automatically transition/delete objects
**Encryption**: Server-side encryption (SSE-S3, SSE-KMS, SSE-C)
**Access Control**: Bucket policies, ACLs
**CORS**: Cross-Origin Resource Sharing

### 5.4 S3 Best Practices

1. **Bucket Naming**: Use unique, DNS-compliant names
2. **Versioning**: Enable for production buckets
3. **Lifecycle Policies**: Automate transitions to cheaper storage
4. **Encryption**: Enable encryption at rest
5. **Access Control**: Use bucket policies, not public access

### 5.5 Java Integration: S3

**Maven Dependency**:
```xml
<dependency>
    <groupId>software.amazon.awssdk</groupId>
    <artifactId>s3</artifactId>
</dependency>
```

**S3 Service Example**:
```java
@Service
@Slf4j
public class S3Service {
    
    private final S3Client s3Client;
    private final String bucketName;
    
    public S3Service(S3Client s3Client, 
                     @Value("${aws.s3.bucket-name}") String bucketName) {
        this.s3Client = s3Client;
        this.bucketName = bucketName;
    }
    
    /**
     * Upload file to S3
     */
    public String uploadFile(String key, byte[] data, String contentType) {
        try {
            PutObjectRequest request = PutObjectRequest.builder()
                .bucket(bucketName)
                .key(key)
                .contentType(contentType)
                .serverSideEncryption(ServerSideEncryption.AES256)
                .build();
            
            s3Client.putObject(request, RequestBody.fromBytes(data));
            
            log.info("File uploaded to S3: {}", key);
            return key;
            
        } catch (S3Exception e) {
            log.error("Error uploading file to S3", e);
            throw new S3UploadException("Failed to upload file", e);
        }
    }
    
    /**
     * Download file from S3
     */
    public byte[] downloadFile(String key) {
        try {
            GetObjectRequest request = GetObjectRequest.builder()
                .bucket(bucketName)
                .key(key)
                .build();
            
            ResponseInputStream<GetObjectResponse> response = 
                s3Client.getObject(request);
            
            return response.readAllBytes();
            
        } catch (S3Exception | IOException e) {
            log.error("Error downloading file from S3", e);
            throw new S3DownloadException("Failed to download file", e);
        }
    }
    
    /**
     * Generate pre-signed URL for temporary access
     */
    public String generatePresignedUrl(String key, Duration expiration) {
        S3Presigner presigner = S3Presigner.builder()
            .region(Region.US_EAST_1)
            .build();
        
        GetObjectPresignRequest presignRequest = GetObjectPresignRequest.builder()
            .signatureDuration(expiration)
            .getObjectRequest(GetObjectRequest.builder()
                .bucket(bucketName)
                .key(key)
                .build())
            .build();
        
        PresignedGetObjectRequest presignedRequest = 
            presigner.presignGetObject(presignRequest);
        
        return presignedRequest.url().toString();
    }
    
    /**
     * Delete file from S3
     */
    public void deleteFile(String key) {
        try {
            DeleteObjectRequest request = DeleteObjectRequest.builder()
                .bucket(bucketName)
                .key(key)
                .build();
            
            s3Client.deleteObject(request);
            log.info("File deleted from S3: {}", key);
            
        } catch (S3Exception e) {
            log.error("Error deleting file from S3", e);
            throw new S3DeleteException("Failed to delete file", e);
        }
    }
    
    /**
     * List objects in bucket
     */
    public List<String> listObjects(String prefix) {
        try {
            ListObjectsV2Request request = ListObjectsV2Request.builder()
                .bucket(bucketName)
                .prefix(prefix)
                .build();
            
            ListObjectsV2Response response = s3Client.listObjectsV2(request);
            
            return response.contents().stream()
                .map(S3Object::key)
                .collect(Collectors.toList());
            
        } catch (S3Exception e) {
            log.error("Error listing objects in S3", e);
            throw new S3ListException("Failed to list objects", e);
        }
    }
}
```

**Configuration**:
```java
@Configuration
public class S3Configuration {
    
    @Bean
    public S3Client s3Client(@Value("${aws.region}") String region) {
        return S3Client.builder()
            .region(Region.of(region))
            .build();
    }
}
```

**REST Controller**:
```java
@RestController
@RequestMapping("/api/files")
public class FileController {
    
    private final S3Service s3Service;
    
    @PostMapping("/upload")
    public ResponseEntity<FileUploadResponse> uploadFile(
            @RequestParam("file") MultipartFile file) {
        
        try {
            String key = "uploads/" + UUID.randomUUID() + "/" + file.getOriginalFilename();
            String contentType = file.getContentType();
            byte[] data = file.getBytes();
            
            String uploadedKey = s3Service.uploadFile(key, data, contentType);
            
            return ResponseEntity.ok(FileUploadResponse.builder()
                .key(uploadedKey)
                .url(s3Service.generatePresignedUrl(uploadedKey, Duration.ofHours(1)))
                .build());
                
        } catch (IOException e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    @GetMapping("/download/{key}")
    public ResponseEntity<byte[]> downloadFile(@PathVariable String key) {
        byte[] data = s3Service.downloadFile(key);
        return ResponseEntity.ok()
            .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + key + "\"")
            .body(data);
    }
    
    @DeleteMapping("/{key}")
    public ResponseEntity<Void> deleteFile(@PathVariable String key) {
        s3Service.deleteFile(key);
        return ResponseEntity.noContent().build();
    }
}
```

---

## 6. Elastic Block Store (EBS)

### 6.1 EBS Overview

**EBS** provides persistent block storage for EC2 instances.

**Key Concepts**:
- **Volume**: Virtual hard disk
- **Snapshot**: Backup of volume
- **Volume Types**: Different performance characteristics
- **Attach/Detach**: Can attach to EC2 instances

### 6.2 EBS Volume Types

```
EBS Volume Types:
├── gp3 (General Purpose SSD)
│   └── Balanced performance, 3,000 IOPS baseline
├── gp2 (General Purpose SSD)
│   └── 3 IOPS per GB, up to 16,000 IOPS
├── io1/io2 (Provisioned IOPS SSD)
│   └── Up to 64,000 IOPS, high performance
├── st1 (Throughput Optimized HDD)
│   └── High throughput, low cost
└── sc1 (Cold HDD)
    └── Lowest cost, infrequent access
```

### 6.3 EBS Features

**Snapshots**: Point-in-time backups
**Encryption**: Encrypt volumes at rest
**Multi-Attach**: Attach to multiple instances (io1/io2)
**Resize**: Increase volume size without downtime

### 6.4 EBS Best Practices

1. **Right Type**: Choose appropriate volume type
2. **Snapshots**: Regular snapshots for backups
3. **Encryption**: Enable encryption for sensitive data
4. **Monitoring**: Monitor IOPS and throughput
5. **Resize**: Start small, resize as needed

### 6.5 Java Application: EBS Usage

**Application Configuration**:
```yaml
# application.yml
spring:
  datasource:
    url: jdbc:postgresql://${DB_HOST}:5432/${DB_NAME}
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
    
# Database on EBS volume
# - Volume attached to RDS instance
# - Automatic backups (snapshots)
# - Multi-AZ for HA
```

**Note**: For Java applications, EBS is typically used indirectly through RDS (managed database service). Direct EBS usage is rare for application code.

---

## 7. Java Integration Examples

### 7.1 Complete Spring Boot Configuration

**Maven Dependencies**:
```xml
<dependencies>
    <!-- Spring Boot -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    
    <!-- AWS SDK BOM -->
    <dependency>
        <groupId>software.amazon.awssdk</groupId>
        <artifactId>bom</artifactId>
        <version>2.20.0</version>
        <type>pom</type>
        <scope>import</scope>
    </dependency>
    
    <!-- AWS SDK Services -->
    <dependency>
        <groupId>software.amazon.awssdk</groupId>
        <artifactId>s3</artifactId>
    </dependency>
    
    <dependency>
        <groupId>software.amazon.awssdk</groupId>
        <artifactId>dynamodb</artifactId>
    </dependency>
    
    <dependency>
        <groupId>software.amazon.awssdk</groupId>
        <artifactId>sqs</artifactId>
    </dependency>
</dependencies>
```

**Application Properties**:
```yaml
# application.yml
aws:
  region: us-east-1
  s3:
    bucket-name: myapp-uploads
  dynamodb:
    table-name: myapp-users
  sqs:
    queue-url: https://sqs.us-east-1.amazonaws.com/123456789/myapp-queue

spring:
  application:
    name: myapp
```

**AWS Configuration**:
```java
@Configuration
@EnableConfigurationProperties(AwsProperties.class)
public class AwsConfiguration {
    
    @Bean
    public Region awsRegion(@Value("${aws.region}") String region) {
        return Region.of(region);
    }
    
    @Bean
    public S3Client s3Client(Region region) {
        return S3Client.builder()
            .region(region)
            .build();
    }
    
    @Bean
    public DynamoDbClient dynamoDbClient(Region region) {
        return DynamoDbClient.builder()
            .region(region)
            .build();
    }
    
    @Bean
    public SqsClient sqsClient(Region region) {
        return SqsClient.builder()
            .region(region)
            .build();
    }
}
```

### 7.2 Error Handling

```java
@ControllerAdvice
public class AwsExceptionHandler {
    
    @ExceptionHandler(S3Exception.class)
    public ResponseEntity<ErrorResponse> handleS3Exception(S3Exception e) {
        log.error("S3 error: {}", e.getMessage(), e);
        return ResponseEntity.status(e.statusCode())
            .body(ErrorResponse.builder()
                .code("S3_ERROR")
                .message("S3 operation failed: " + e.getMessage())
                .build());
    }
    
    @ExceptionHandler(DynamoDbException.class)
    public ResponseEntity<ErrorResponse> handleDynamoDbException(DynamoDbException e) {
        log.error("DynamoDB error: {}", e.getMessage(), e);
        return ResponseEntity.status(e.statusCode())
            .body(ErrorResponse.builder()
                .code("DYNAMODB_ERROR")
                .message("DynamoDB operation failed: " + e.getMessage())
                .build());
    }
}
```

---

## Summary of Part 1

### Key Takeaways

1. **AWS Fundamentals**: Regions, AZs, service categories
2. **IAM**: Users, roles, policies, best practices
3. **VPC**: Networking, subnets, security groups
4. **EC2**: Virtual servers, instance types, pricing
5. **S3**: Object storage, storage classes, Java integration
6. **EBS**: Block storage for EC2

### Next Steps

**Part 2** will cover:
- Application Services (RDS, DynamoDB, ElastiCache)
- Messaging (SQS, SNS, EventBridge)
- Serverless (Lambda)
- API Gateway

---

**Ready for Part 2?** These fundamentals form the foundation for building production-ready Java applications on AWS.

