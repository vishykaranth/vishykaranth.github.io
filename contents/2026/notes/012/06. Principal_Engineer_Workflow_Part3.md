# Principal Engineer Workflow: Deep Examples

## Part 3: Implementation

---

## Table of Contents

1. [Principal Engineer Implements](#principal-engineer-implements)
   - [Creates Detailed Design](#1-creates-detailed-design)
   - [Defines Interfaces](#2-defines-interfaces)
   - [Plans Implementation](#3-plans-implementation)
   - [Documents Decisions](#4-documents-decisions)

---

## Principal Engineer Implements

### Overview

After validation, the Principal Engineer creates the detailed implementation design, defines interfaces, plans the implementation, and documents all decisions. This transforms the validated design into an actionable implementation plan.

---

## 1. Creates Detailed Design

### Example 1: Service Detailed Design

**Context**: Order Service in microservices architecture

**Principal Engineer Detailed Design**:

**Step 1: Service Architecture**
```yaml
Order Service Architecture:
  Components:
    1. API Layer (REST Controllers)
       - OrderController: Order CRUD operations
       - OrderItemController: Order item operations
       - OrderStatusController: Status updates
    
    2. Service Layer (Business Logic)
       - OrderService: Core order business logic
       - OrderValidationService: Order validation
       - OrderCalculationService: Price calculations
       - OrderNotificationService: Notifications
    
    3. Repository Layer (Data Access)
       - OrderRepository: Order data access
       - OrderItemRepository: Order item data access
       - OrderStatusRepository: Status history
    
    4. Integration Layer (External Services)
       - ProductServiceClient: Product information
       - InventoryServiceClient: Inventory checks
       - PaymentServiceClient: Payment processing
       - NotificationServiceClient: Notifications
    
    5. Infrastructure Layer
       - Database: PostgreSQL
       - Cache: Redis
       - Message Queue: RabbitMQ
       - Monitoring: CloudWatch, Datadog
```

**Step 2: Database Schema Design**
```sql
-- Orders table
CREATE TABLE orders (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    order_number VARCHAR(50) UNIQUE NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'pending',
    total_amount DECIMAL(10,2) NOT NULL,
    currency VARCHAR(3) NOT NULL DEFAULT 'USD',
    shipping_address JSONB NOT NULL,
    billing_address JSONB NOT NULL,
    payment_method_id BIGINT,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
    version INTEGER NOT NULL DEFAULT 1,
    
    CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(id),
    CONSTRAINT fk_payment_method FOREIGN KEY (payment_method_id) REFERENCES payment_methods(id),
    CONSTRAINT chk_status CHECK (status IN ('pending', 'confirmed', 'processing', 'shipped', 'delivered', 'cancelled'))
);

-- Indexes
CREATE INDEX idx_orders_user_id ON orders(user_id);
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_orders_created_at ON orders(created_at DESC);
CREATE INDEX idx_orders_order_number ON orders(order_number);

-- Order items table
CREATE TABLE order_items (
    id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    quantity INTEGER NOT NULL,
    unit_price DECIMAL(10,2) NOT NULL,
    total_price DECIMAL(10,2) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    
    CONSTRAINT fk_order FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE,
    CONSTRAINT chk_quantity CHECK (quantity > 0),
    CONSTRAINT chk_price CHECK (unit_price >= 0 AND total_price >= 0)
);

-- Indexes
CREATE INDEX idx_order_items_order_id ON order_items(order_id);
CREATE INDEX idx_order_items_product_id ON order_items(product_id);

-- Order status history table
CREATE TABLE order_status_history (
    id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL,
    status VARCHAR(20) NOT NULL,
    changed_by BIGINT,
    changed_at TIMESTAMP NOT NULL DEFAULT NOW(),
    notes TEXT,
    
    CONSTRAINT fk_order FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE,
    CONSTRAINT fk_changed_by FOREIGN KEY (changed_by) REFERENCES users(id)
);

-- Indexes
CREATE INDEX idx_order_status_history_order_id ON order_status_history(order_id);
CREATE INDEX idx_order_status_history_changed_at ON order_status_history(changed_at DESC);
```

**Step 3: API Design**
```yaml
Order Service API:

  POST /api/v1/orders
    Request:
      {
        "user_id": 123,
        "items": [
          {
            "product_id": 456,
            "quantity": 2
          }
        ],
        "shipping_address": {
          "street": "123 Main St",
          "city": "New York",
          "state": "NY",
          "zip": "10001",
          "country": "US"
        },
        "billing_address": { ... },
        "payment_method_id": 789
      }
    
    Response (201):
      {
        "id": 1001,
        "order_number": "ORD-2024-001",
        "status": "pending",
        "total_amount": 199.98,
        "items": [ ... ],
        "created_at": "2024-01-15T10:30:00Z"
      }
    
    Errors:
      - 400: Validation error
      - 404: Product not found
      - 409: Inventory insufficient
      - 500: Server error

  GET /api/v1/orders/{id}
    Response (200):
      {
        "id": 1001,
        "order_number": "ORD-2024-001",
        "status": "confirmed",
        "total_amount": 199.98,
        "items": [ ... ],
        "status_history": [ ... ],
        "created_at": "2024-01-15T10:30:00Z",
        "updated_at": "2024-01-15T10:35:00Z"
      }
    
    Errors:
      - 404: Order not found
      - 500: Server error

  PUT /api/v1/orders/{id}/status
    Request:
      {
        "status": "shipped",
        "notes": "Shipped via FedEx"
      }
    
    Response (200):
      {
        "id": 1001,
        "status": "shipped",
        "updated_at": "2024-01-15T11:00:00Z"
      }
    
    Errors:
      - 400: Invalid status transition
      - 404: Order not found
      - 409: Concurrent modification
      - 500: Server error

  GET /api/v1/orders?user_id=123&status=pending&page=1&size=20
    Response (200):
      {
        "data": [ ... ],
        "pagination": {
          "page": 1,
          "size": 20,
          "total": 45,
          "total_pages": 3
        }
      }
```

**Step 4: Business Logic Design**
```java
// OrderService detailed design
@Service
@Transactional
public class OrderService {
    
    /**
     * Create a new order
     * 
     * Business Rules:
     * 1. Validate user exists and is active
     * 2. Validate all products exist and are available
     * 3. Check inventory for all items
     * 4. Calculate total (including tax, shipping)
     * 5. Reserve inventory
     * 6. Create order with status 'pending'
     * 7. Publish OrderCreated event
     * 8. Send confirmation email
     * 
     * @param request Order creation request
     * @return Created order
     * @throws OrderValidationException if validation fails
     * @throws InventoryException if inventory insufficient
     */
    public Order createOrder(CreateOrderRequest request) {
        // 1. Validate user
        User user = userServiceClient.getUser(request.getUserId());
        if (user == null || !user.isActive()) {
            throw new OrderValidationException("Invalid or inactive user");
        }
        
        // 2. Validate products and check inventory
        List<OrderItem> items = new ArrayList<>();
        BigDecimal totalAmount = BigDecimal.ZERO;
        
        for (OrderItemRequest itemRequest : request.getItems()) {
            // Get product information
            Product product = productServiceClient.getProduct(itemRequest.getProductId());
            if (product == null || !product.isAvailable()) {
                throw new OrderValidationException("Product not available: " + itemRequest.getProductId());
            }
            
            // Check inventory
            Inventory inventory = inventoryServiceClient.checkInventory(
                itemRequest.getProductId(), 
                itemRequest.getQuantity()
            );
            if (!inventory.isAvailable()) {
                throw new InventoryException("Insufficient inventory for product: " + itemRequest.getProductId());
            }
            
            // Calculate item total
            BigDecimal itemTotal = product.getPrice()
                .multiply(BigDecimal.valueOf(itemRequest.getQuantity()));
            totalAmount = totalAmount.add(itemTotal);
            
            items.add(OrderItem.builder()
                .productId(itemRequest.getProductId())
                .quantity(itemRequest.getQuantity())
                .unitPrice(product.getPrice())
                .totalPrice(itemTotal)
                .build());
        }
        
        // 3. Calculate tax and shipping
        BigDecimal tax = calculateTax(totalAmount, request.getShippingAddress());
        BigDecimal shipping = calculateShipping(totalAmount, request.getShippingAddress());
        BigDecimal finalTotal = totalAmount.add(tax).add(shipping);
        
        // 4. Reserve inventory
        inventoryServiceClient.reserveInventory(request.getItems());
        
        // 5. Create order
        Order order = Order.builder()
            .userId(request.getUserId())
            .orderNumber(generateOrderNumber())
            .status(OrderStatus.PENDING)
            .totalAmount(finalTotal)
            .items(items)
            .shippingAddress(request.getShippingAddress())
            .billingAddress(request.getBillingAddress())
            .paymentMethodId(request.getPaymentMethodId())
            .build();
        
        Order savedOrder = orderRepository.save(order);
        
        // 6. Publish event
        eventPublisher.publish(new OrderCreatedEvent(savedOrder));
        
        // 7. Send notification (async)
        notificationService.sendOrderConfirmation(savedOrder);
        
        return savedOrder;
    }
    
    /**
     * Update order status
     * 
     * Business Rules:
     * 1. Validate status transition (state machine)
     * 2. Check concurrent modifications (optimistic locking)
     * 3. Update status
     * 4. Record status history
     * 5. Publish OrderStatusChanged event
     * 6. Trigger side effects (e.g., ship order, cancel inventory)
     * 
     * Valid Transitions:
     * - pending → confirmed
     * - confirmed → processing
     * - processing → shipped
     * - shipped → delivered
     * - * → cancelled (from any state except delivered)
     */
    public Order updateStatus(Long orderId, OrderStatus newStatus, String notes) {
        Order order = orderRepository.findById(orderId)
            .orElseThrow(() -> new OrderNotFoundException("Order not found: " + orderId));
        
        // Validate status transition
        if (!isValidStatusTransition(order.getStatus(), newStatus)) {
            throw new InvalidStatusTransitionException(
                "Cannot transition from " + order.getStatus() + " to " + newStatus
            );
        }
        
        // Optimistic locking check
        int currentVersion = order.getVersion();
        order.setStatus(newStatus);
        order.setVersion(currentVersion + 1);
        
        try {
            Order updatedOrder = orderRepository.save(order);
            
            // Record status history
            orderStatusHistoryRepository.save(OrderStatusHistory.builder()
                .orderId(orderId)
                .status(newStatus)
                .changedBy(getCurrentUserId())
                .notes(notes)
                .build());
            
            // Publish event
            eventPublisher.publish(new OrderStatusChangedEvent(updatedOrder));
            
            // Trigger side effects
            handleStatusChangeSideEffects(updatedOrder, newStatus);
            
            return updatedOrder;
            
        } catch (OptimisticLockingFailureException e) {
            throw new ConcurrentModificationException("Order was modified by another process");
        }
    }
    
    private void handleStatusChangeSideEffects(Order order, OrderStatus newStatus) {
        switch (newStatus) {
            case CONFIRMED:
                // Trigger payment processing
                paymentServiceClient.processPayment(order);
                break;
                
            case SHIPPED:
                // Update inventory (reduce stock)
                inventoryServiceClient.fulfillInventory(order.getItems());
                // Send shipping notification
                notificationService.sendShippingNotification(order);
                break;
                
            case CANCELLED:
                // Release inventory
                inventoryServiceClient.releaseInventory(order.getItems());
                // Send cancellation notification
                notificationService.sendCancellationNotification(order);
                break;
                
            case DELIVERED:
                // Complete order
                completeOrder(order);
                break;
        }
    }
}
```

**Step 5: Error Handling Design**
```java
// Error handling strategy
@ControllerAdvice
public class OrderExceptionHandler {
    
    @ExceptionHandler(OrderValidationException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(OrderValidationException e) {
        return ResponseEntity
            .status(HttpStatus.BAD_REQUEST)
            .body(ErrorResponse.builder()
                .code("VALIDATION_ERROR")
                .message(e.getMessage())
                .timestamp(Instant.now())
                .build());
    }
    
    @ExceptionHandler(InventoryException.class)
    public ResponseEntity<ErrorResponse> handleInventoryException(InventoryException e) {
        return ResponseEntity
            .status(HttpStatus.CONFLICT)
            .body(ErrorResponse.builder()
                .code("INVENTORY_INSUFFICIENT")
                .message(e.getMessage())
                .timestamp(Instant.now())
                .build());
    }
    
    @ExceptionHandler(ConcurrentModificationException.class)
    public ResponseEntity<ErrorResponse> handleConcurrentModification(ConcurrentModificationException e) {
        return ResponseEntity
            .status(HttpStatus.CONFLICT)
            .body(ErrorResponse.builder()
                .code("CONCURRENT_MODIFICATION")
                .message("Order was modified by another process. Please refresh and try again.")
                .timestamp(Instant.now())
                .build());
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception e) {
        log.error("Unexpected error", e);
        return ResponseEntity
            .status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(ErrorResponse.builder()
                .code("INTERNAL_ERROR")
                .message("An unexpected error occurred")
                .timestamp(Instant.now())
                .build());
    }
}
```

---

### Example 2: Integration Design

**Context**: Integration between Order Service and Payment Service

**Principal Engineer Integration Design**:

**Step 1: Communication Pattern**
```yaml
Integration Pattern: Request-Response (Synchronous) + Event (Asynchronous)

Synchronous (Request-Response):
  - Payment processing (need immediate response)
  - Payment status check (need current status)
  - Payment validation (need validation result)

Asynchronous (Events):
  - Payment completed (fire and forget)
  - Payment failed (fire and forget)
  - Payment refunded (fire and forget)
```

**Step 2: API Contract Design**
```yaml
Payment Service API Contract:

  POST /api/v1/payments
    Request:
      {
        "order_id": 1001,
        "amount": 199.98,
        "currency": "USD",
        "payment_method_id": 789,
        "metadata": {
          "order_number": "ORD-2024-001",
          "user_id": 123
        }
      }
    
    Response (200):
      {
        "payment_id": "pay_123456",
        "order_id": 1001,
        "status": "processing",
        "amount": 199.98,
        "currency": "USD",
        "created_at": "2024-01-15T10:30:00Z"
      }
    
    Response (400):
      {
        "code": "INVALID_PAYMENT_METHOD",
        "message": "Payment method not found or invalid"
      }
    
    Response (402):
      {
        "code": "PAYMENT_DECLINED",
        "message": "Payment was declined by payment processor"
      }

  GET /api/v1/payments/{payment_id}
    Response (200):
      {
        "payment_id": "pay_123456",
        "order_id": 1001,
        "status": "completed",
        "amount": 199.98,
        "currency": "USD",
        "transaction_id": "txn_789012",
        "completed_at": "2024-01-15T10:31:00Z"
      }
```

**Step 3: Event Contract Design**
```yaml
Event Contracts:

  PaymentCompletedEvent:
    Topic: payments.completed
    Schema:
      {
        "event_id": "evt_123456",
        "event_type": "payment.completed",
        "timestamp": "2024-01-15T10:31:00Z",
        "data": {
          "payment_id": "pay_123456",
          "order_id": 1001,
          "amount": 199.98,
          "transaction_id": "txn_789012"
        }
      }
    
    Consumers:
      - Order Service: Update order status to confirmed
      - Notification Service: Send payment confirmation email
      - Analytics Service: Record payment event

  PaymentFailedEvent:
    Topic: payments.failed
    Schema:
      {
        "event_id": "evt_123457",
        "event_type": "payment.failed",
        "timestamp": "2024-01-15T10:31:00Z",
        "data": {
          "payment_id": "pay_123456",
          "order_id": 1001,
          "amount": 199.98,
          "failure_reason": "INSUFFICIENT_FUNDS"
        }
      }
    
    Consumers:
      - Order Service: Update order status to payment_failed
      - Notification Service: Send payment failure email
      - Analytics Service: Record payment failure
```

**Step 4: Resilience Design**
```java
// Resilience patterns for integration
@Service
public class PaymentServiceClient {
    
    @Autowired
    private RestTemplate restTemplate;
    
    @Autowired
    private CircuitBreakerRegistry circuitBreakerRegistry;
    
    @Autowired
    private RetryRegistry retryRegistry;
    
    /**
     * Process payment with resilience patterns
     * 
     * Resilience:
     * 1. Circuit breaker (prevent cascading failures)
     * 2. Retry with exponential backoff (handle transient failures)
     * 3. Timeout (prevent hanging requests)
     * 4. Fallback (graceful degradation)
     */
    public PaymentResponse processPayment(PaymentRequest request) {
        CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker("payment-service");
        Retry retry = retryRegistry.retry("payment-service");
        
        return circuitBreaker.executeSupplier(() ->
            retry.executeSupplier(() -> {
                try {
                    // Set timeout
                    HttpHeaders headers = new HttpHeaders();
                    headers.setContentType(MediaType.APPLICATION_JSON);
                    HttpEntity<PaymentRequest> entity = new HttpEntity<>(request, headers);
                    
                    ResponseEntity<PaymentResponse> response = restTemplate.exchange(
                        "http://payment-service/api/v1/payments",
                        HttpMethod.POST,
                        entity,
                        PaymentResponse.class
                    );
                    
                    return response.getBody();
                    
                } catch (ResourceAccessException e) {
                    // Timeout or connection error
                    throw new PaymentServiceException("Payment service unavailable", e);
                } catch (HttpServerErrorException e) {
                    // Server error (5xx) - retry
                    throw new PaymentServiceException("Payment service error", e);
                } catch (HttpClientErrorException e) {
                    // Client error (4xx) - don't retry
                    throw new PaymentException("Payment failed: " + e.getResponseBodyAsString());
                }
            })
        );
    }
    
    /**
     * Fallback for payment processing
     */
    @CircuitBreaker(name = "payment-service", fallbackMethod = "processPaymentFallback")
    public PaymentResponse processPaymentWithFallback(PaymentRequest request) {
        return processPayment(request);
    }
    
    private PaymentResponse processPaymentFallback(PaymentRequest request, Exception e) {
        log.error("Payment service unavailable, using fallback", e);
        
        // Queue payment for later processing
        paymentQueue.enqueue(request);
        
        // Return pending status
        return PaymentResponse.builder()
            .status(PaymentStatus.PENDING)
            .message("Payment queued for processing")
            .build();
    }
}
```

---

## 2. Defines Interfaces

### Example 1: Service Interface Definition

**Context**: Order Service interfaces

**Principal Engineer Interface Definition**:

**Step 1: Service Interface**
```java
/**
 * Order Service Interface
 * 
 * Defines the contract for order management operations
 */
public interface OrderService {
    
    /**
     * Create a new order
     * 
     * @param request Order creation request
     * @return Created order
     * @throws OrderValidationException if validation fails
     * @throws InventoryException if inventory insufficient
     */
    Order createOrder(CreateOrderRequest request);
    
    /**
     * Get order by ID
     * 
     * @param orderId Order ID
     * @return Order
     * @throws OrderNotFoundException if order not found
     */
    Order getOrder(Long orderId);
    
    /**
     * Get orders by user ID
     * 
     * @param userId User ID
     * @param status Optional status filter
     * @param pageable Pagination parameters
     * @return Page of orders
     */
    Page<Order> getOrdersByUserId(Long userId, OrderStatus status, Pageable pageable);
    
    /**
     * Update order status
     * 
     * @param orderId Order ID
     * @param newStatus New status
     * @param notes Optional notes
     * @return Updated order
     * @throws OrderNotFoundException if order not found
     * @throws InvalidStatusTransitionException if invalid transition
     * @throws ConcurrentModificationException if concurrent modification
     */
    Order updateStatus(Long orderId, OrderStatus newStatus, String notes);
    
    /**
     * Cancel order
     * 
     * @param orderId Order ID
     * @param reason Cancellation reason
     * @return Cancelled order
     * @throws OrderNotFoundException if order not found
     * @throws InvalidStatusTransitionException if cannot cancel
     */
    Order cancelOrder(Long orderId, String reason);
}
```

**Step 2: Repository Interface**
```java
/**
 * Order Repository Interface
 * 
 * Defines data access operations for orders
 */
public interface OrderRepository extends JpaRepository<Order, Long> {
    
    /**
     * Find orders by user ID
     * 
     * @param userId User ID
     * @param pageable Pagination parameters
     * @return Page of orders
     */
    Page<Order> findByUserId(Long userId, Pageable pageable);
    
    /**
     * Find orders by user ID and status
     * 
     * @param userId User ID
     * @param status Order status
     * @param pageable Pagination parameters
     * @return Page of orders
     */
    Page<Order> findByUserIdAndStatus(Long userId, OrderStatus status, Pageable pageable);
    
    /**
     * Find order by order number
     * 
     * @param orderNumber Order number
     * @return Optional order
     */
    Optional<Order> findByOrderNumber(String orderNumber);
    
    /**
     * Find orders by status
     * 
     * @param status Order status
     * @param pageable Pagination parameters
     * @return Page of orders
     */
    Page<Order> findByStatus(OrderStatus status, Pageable pageable);
    
    /**
     * Find orders created between dates
     * 
     * @param startDate Start date
     * @param endDate End date
     * @param pageable Pagination parameters
     * @return Page of orders
     */
    Page<Order> findByCreatedAtBetween(LocalDateTime startDate, LocalDateTime endDate, Pageable pageable);
    
    /**
     * Count orders by status
     * 
     * @param status Order status
     * @return Count
     */
    long countByStatus(OrderStatus status);
}
```

**Step 3: Client Interface (External Service)**
```java
/**
 * Payment Service Client Interface
 * 
 * Defines contract for payment service integration
 */
public interface PaymentServiceClient {
    
    /**
     * Process payment
     * 
     * @param request Payment request
     * @return Payment response
     * @throws PaymentServiceException if service unavailable
     * @throws PaymentException if payment fails
     */
    PaymentResponse processPayment(PaymentRequest request);
    
    /**
     * Get payment status
     * 
     * @param paymentId Payment ID
     * @return Payment response
     * @throws PaymentServiceException if service unavailable
     * @throws PaymentNotFoundException if payment not found
     */
    PaymentResponse getPaymentStatus(String paymentId);
    
    /**
     * Refund payment
     * 
     * @param paymentId Payment ID
     * @param amount Refund amount (null for full refund)
     * @return Refund response
     * @throws PaymentServiceException if service unavailable
     * @throws PaymentException if refund fails
     */
    RefundResponse refundPayment(String paymentId, BigDecimal amount);
}
```

**Step 4: Event Interface**
```java
/**
 * Event Publisher Interface
 * 
 * Defines contract for publishing events
 */
public interface EventPublisher {
    
    /**
     * Publish event
     * 
     * @param event Event to publish
     * @param <T> Event type
     */
    <T extends Event> void publish(T event);
    
    /**
     * Publish event asynchronously
     * 
     * @param event Event to publish
     * @param <T> Event type
     */
    <T extends Event> void publishAsync(T event);
}

/**
 * Event Consumer Interface
 * 
 * Defines contract for consuming events
 */
public interface EventConsumer {
    
    /**
     * Handle event
     * 
     * @param event Event to handle
     * @param <T> Event type
     */
    <T extends Event> void handle(T event);
}
```

---

### Example 2: API Contract Definition

**Context**: REST API contract for Order Service

**Principal Engineer API Contract**:

**Step 1: OpenAPI Specification**
```yaml
openapi: 3.0.0
info:
  title: Order Service API
  version: 1.0.0
  description: API for managing orders

servers:
  - url: https://api.example.com
    description: Production server
  - url: https://api-staging.example.com
    description: Staging server

paths:
  /api/v1/orders:
    post:
      summary: Create a new order
      operationId: createOrder
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateOrderRequest'
      responses:
        '201':
          description: Order created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Order'
        '400':
          description: Validation error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'
        '409':
          description: Conflict (e.g., inventory insufficient)
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'
    
    get:
      summary: List orders
      operationId: listOrders
      parameters:
        - name: user_id
          in: query
          schema:
            type: integer
        - name: status
          in: query
          schema:
            $ref: '#/components/schemas/OrderStatus'
        - name: page
          in: query
          schema:
            type: integer
            default: 1
        - name: size
          in: query
          schema:
            type: integer
            default: 20
      responses:
        '200':
          description: List of orders
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/OrderPage'

  /api/v1/orders/{id}:
    get:
      summary: Get order by ID
      operationId: getOrder
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        '200':
          description: Order details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Order'
        '404':
          description: Order not found
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'

components:
  schemas:
    CreateOrderRequest:
      type: object
      required:
        - user_id
        - items
        - shipping_address
        - billing_address
      properties:
        user_id:
          type: integer
        items:
          type: array
          items:
            $ref: '#/components/schemas/OrderItemRequest'
        shipping_address:
          $ref: '#/components/schemas/Address'
        billing_address:
          $ref: '#/components/schemas/Address'
        payment_method_id:
          type: integer
    
    Order:
      type: object
      properties:
        id:
          type: integer
        order_number:
          type: string
        user_id:
          type: integer
        status:
          $ref: '#/components/schemas/OrderStatus'
        total_amount:
          type: number
          format: decimal
        items:
          type: array
          items:
            $ref: '#/components/schemas/OrderItem'
        created_at:
          type: string
          format: date-time
        updated_at:
          type: string
          format: date-time
    
    OrderStatus:
      type: string
      enum:
        - pending
        - confirmed
        - processing
        - shipped
        - delivered
        - cancelled
    
    ErrorResponse:
      type: object
      properties:
        code:
          type: string
        message:
          type: string
        timestamp:
          type: string
          format: date-time
```

---

## 3. Plans Implementation

### Example 1: Implementation Plan

**Context**: Order Service implementation

**Principal Engineer Implementation Plan**:

**Step 1: Implementation Phases**
```yaml
Implementation Plan:

  Phase 1: Foundation (Week 1-2)
    Tasks:
      1. Set up project structure
         - Spring Boot project
         - Dependencies (JPA, PostgreSQL, RabbitMQ, etc.)
         - Configuration files
         - Docker setup
      
      2. Database setup
         - Create database schema
         - Run migrations (Flyway)
         - Set up connection pooling
      
      3. Basic infrastructure
         - Health checks
         - Logging configuration
         - Monitoring setup
         - Error handling
    
    Deliverables:
      - Project skeleton
      - Database schema
      - Basic API endpoints (health, metrics)
    
    Success Criteria:
      - Project builds and runs
      - Database connection works
      - Health checks pass

  Phase 2: Core Functionality (Week 3-5)
    Tasks:
      1. Repository layer
         - OrderRepository implementation
         - OrderItemRepository implementation
         - OrderStatusHistoryRepository implementation
         - Unit tests
      
      2. Service layer
         - OrderService implementation
         - OrderValidationService implementation
         - OrderCalculationService implementation
         - Unit tests
      
      3. API layer
         - OrderController implementation
         - Request/response DTOs
         - Exception handling
         - Integration tests
    
    Deliverables:
      - Complete CRUD operations
      - Business logic implementation
      - API endpoints working
    
    Success Criteria:
      - All unit tests pass
      - All integration tests pass
      - API endpoints work correctly

  Phase 3: Integration (Week 6-7)
    Tasks:
      1. External service clients
         - ProductServiceClient implementation
         - InventoryServiceClient implementation
         - PaymentServiceClient implementation
         - NotificationServiceClient implementation
         - Resilience patterns (circuit breaker, retry)
      
      2. Event publishing
         - EventPublisher implementation
         - Event schemas
         - RabbitMQ integration
         - Event tests
      
      3. End-to-end tests
         - Full order flow tests
         - Integration with other services
         - Error scenarios
    
    Deliverables:
      - Service clients working
      - Events publishing correctly
      - End-to-end tests passing
    
    Success Criteria:
      - All service clients work
      - Events published correctly
      - End-to-end tests pass

  Phase 4: Optimization and Polish (Week 8)
    Tasks:
      1. Performance optimization
         - Query optimization
         - Caching implementation
         - Connection pooling tuning
      
      2. Monitoring and observability
         - Custom metrics
         - Distributed tracing
         - Logging improvements
      
      3. Documentation
         - API documentation
         - Architecture documentation
         - Runbooks
      
      4. Security hardening
         - Security review
         - Vulnerability scanning
         - Penetration testing
    
    Deliverables:
      - Optimized service
      - Comprehensive monitoring
      - Complete documentation
      - Security validated
    
    Success Criteria:
      - Performance meets requirements
      - Monitoring works correctly
      - Documentation complete
      - Security validated
```

**Step 2: Task Breakdown**
```yaml
Detailed Task Breakdown:

  Task: Implement OrderService.createOrder()
    Estimated Time: 2 days
    Dependencies:
      - OrderRepository implemented
      - ProductServiceClient implemented
      - InventoryServiceClient implemented
      - EventPublisher implemented
    
    Subtasks:
      1. Implement user validation (2 hours)
      2. Implement product validation (2 hours)
      3. Implement inventory check (2 hours)
      4. Implement price calculation (2 hours)
      5. Implement inventory reservation (2 hours)
      6. Implement order creation (2 hours)
      7. Implement event publishing (1 hour)
      8. Implement notification (1 hour)
      9. Write unit tests (4 hours)
      10. Write integration tests (4 hours)
    
    Acceptance Criteria:
      - Order created successfully
      - All validations pass
      - Inventory reserved
      - Event published
      - Notification sent
      - All tests pass

  Task: Implement PaymentServiceClient
    Estimated Time: 3 days
    Dependencies:
      - Payment Service API contract defined
      - Resilience library (Resilience4j) configured
    
    Subtasks:
      1. Implement REST client (4 hours)
      2. Implement circuit breaker (2 hours)
      3. Implement retry logic (2 hours)
      4. Implement timeout (1 hour)
      5. Implement fallback (2 hours)
      6. Write unit tests (4 hours)
      7. Write integration tests (4 hours)
      8. Test resilience scenarios (4 hours)
    
    Acceptance Criteria:
      - Payment processing works
      - Circuit breaker works
      - Retry works
      - Timeout works
      - Fallback works
      - All tests pass
```

**Step 3: Resource Allocation**
```yaml
Resource Allocation:

  Team: 4 engineers
  Timeline: 8 weeks

  Engineer 1 (Senior):
    - Phase 1: Project setup, database
    - Phase 2: Service layer, business logic
    - Phase 3: Integration, events
    - Phase 4: Optimization, security
  
  Engineer 2 (Mid-level):
    - Phase 1: Infrastructure, monitoring
    - Phase 2: Repository layer, API layer
    - Phase 3: Service clients
    - Phase 4: Documentation, testing
  
  Engineer 3 (Mid-level):
    - Phase 1: Configuration, Docker
    - Phase 2: API layer, DTOs
    - Phase 3: Event publishing, testing
    - Phase 4: Performance testing, monitoring
  
  Engineer 4 (Junior):
    - Phase 1: Testing setup, basic tests
    - Phase 2: Unit tests, integration tests
    - Phase 3: End-to-end tests
    - Phase 4: Test automation, documentation
```

**Step 4: Risk Mitigation in Implementation**
```yaml
Implementation Risks:

  Risk 1: External service dependencies not ready
    Probability: Medium
    Impact: High
    Mitigation:
      - Create mock services for development
      - Use contract testing
      - Plan for delayed dependencies
      - Have fallback plan
  
  Risk 2: Performance issues discovered late
    Probability: Medium
    Impact: Medium
    Mitigation:
      - Performance testing from Phase 2
      - Load testing in Phase 3
      - Performance monitoring from start
      - Buffer time in Phase 4
  
  Risk 3: Integration issues with other services
    Probability: High
    Impact: Medium
    Mitigation:
      - Integration testing early (Phase 3)
      - Contract testing
      - Staging environment setup
      - Regular integration checkpoints
  
  Risk 4: Team member unavailability
    Probability: Low
    Impact: High
    Mitigation:
      - Knowledge sharing sessions
      - Pair programming
      - Documentation
      - Code reviews
      - Cross-training
```

---

## 4. Documents Decisions

### Example 1: Architecture Decision Records (ADRs)

**Context**: Documenting architectural decisions

**Principal Engineer ADR Documentation**:

**ADR 1: Database Choice**
```markdown
# ADR-001: Use PostgreSQL for All Services

## Status
Accepted

## Context
We need to choose a database for the Order Service. Options considered:
- PostgreSQL (relational, ACID)
- MongoDB (NoSQL, flexible schema)
- Cassandra (NoSQL, high write throughput)

## Decision
Use PostgreSQL for all services (Order, Product, User services).

## Rationale
1. **Team Expertise**: Team has strong PostgreSQL experience (8/12 engineers)
2. **ACID Requirements**: Orders require ACID transactions for data consistency
3. **Current Scale**: 10K orders/day easily handled by PostgreSQL
4. **Cost**: PostgreSQL RDS is cost-effective ($1K/month)
5. **Simplicity**: One database technology reduces operational complexity
6. **Future-Proof**: Can handle growth to 100K+ orders/day with proper optimization

## Consequences
### Positive
- Faster development (team knows PostgreSQL)
- Lower operational complexity
- Lower cost
- Strong data consistency
- Rich ecosystem and tooling

### Negative
- Less flexible schema (compared to MongoDB)
- Vertical scaling limits (but sufficient for our scale)
- May need to revisit if we hit 1M+ orders/day

## Alternatives Considered
1. **MongoDB for Product Catalog**: Rejected - team doesn't know it, adds complexity
2. **Cassandra for High Write**: Rejected - overkill for current scale, team doesn't know it
3. **Hybrid Approach**: Rejected - adds complexity without clear benefit at current scale

## Notes
- Revisit if we hit 500K+ orders/day
- Consider MongoDB for product catalog if schema flexibility becomes critical
- Consider read replicas if read load becomes high
```

**ADR 2: Communication Pattern**
```markdown
# ADR-002: Hybrid Communication Pattern (REST + Events)

## Status
Accepted

## Context
We need to choose communication patterns between microservices:
- Synchronous (REST APIs)
- Asynchronous (Message Queue/Events)
- Hybrid (both)

## Decision
Use hybrid approach:
- **Synchronous (REST)**: For critical path operations requiring immediate response
  - Order → Payment (need immediate confirmation)
  - Order → Inventory (need immediate availability check)
- **Asynchronous (Events)**: For non-critical operations
  - Order → Notification (can be async)
  - Order → Analytics (can be async)
  - Order → Inventory update (can be async after reservation)

## Rationale
1. **Critical Path**: Payment and inventory checks need immediate response for user experience
2. **Resilience**: Non-critical operations can be async for better resilience
3. **Performance**: Async operations don't block user-facing requests
4. **Scalability**: Event-driven architecture scales better for high-volume operations

## Consequences
### Positive
- Better user experience (fast critical path)
- Better resilience (async operations don't fail critical path)
- Better scalability (async operations can scale independently)
- Loose coupling (events)

### Negative
- More complex (two communication patterns)
- Eventual consistency for async operations
- Need to handle event failures and retries

## Implementation
- REST APIs: Spring WebClient with resilience patterns
- Events: RabbitMQ with event schemas
- Event handlers: Idempotent, with retry logic

## Alternatives Considered
1. **All Synchronous**: Rejected - slower, less resilient
2. **All Asynchronous**: Rejected - poor user experience for critical operations
3. **gRPC**: Considered but rejected - team doesn't know it, REST is sufficient
```

**ADR 3: Caching Strategy**
```markdown
# ADR-003: Multi-Layer Caching Strategy

## Status
Accepted

## Context
We need to optimize API response times. Current performance:
- Average: 150ms
- Target: < 100ms (p95)

## Decision
Implement multi-layer caching:
1. **L1 Cache (Application Memory)**: Top 100 products, 5-minute TTL
2. **L2 Cache (Redis)**: Top 1,000 products, 1-hour TTL
3. **L3 Cache (CDN)**: Static product images, 24-hour TTL
4. **No Caching**: Search results (low hit rate, not worth it)

## Rationale
1. **Usage Analysis**: 80% of requests are for top 100 products
2. **Cost Optimization**: Smaller Redis instance (only cache what matters)
3. **Performance**: Multi-layer provides best performance (L1 < 1ms, L2 < 5ms)
4. **Hit Rate**: Expected 75% overall cache hit rate

## Consequences
### Positive
- 75% cache hit rate
- 80% reduction in database load
- API response time: 150ms → 50ms (67% improvement)
- Cost: $200/month (vs $500 for generic caching)

### Negative
- More complex caching logic
- Need cache invalidation strategy
- Need cache warming on startup

## Implementation
- L1: Caffeine cache (in-memory)
- L2: Redis with Spring Cache abstraction
- L3: CloudFront CDN
- Cache invalidation: Event-driven on product updates

## Alternatives Considered
1. **Single Layer (Redis only)**: Rejected - higher cost, slower (network latency)
2. **No Caching**: Rejected - doesn't meet performance requirements
3. **Cache Everything**: Rejected - too expensive, low hit rate for some data
```

---

### Example 2: API Documentation

**Context**: Complete API documentation

**Principal Engineer API Documentation**:

```markdown
# Order Service API Documentation

## Overview
The Order Service API provides endpoints for managing orders in the e-commerce platform.

**Base URL**: `https://api.example.com/api/v1`

**Authentication**: OAuth2 Bearer Token

**Rate Limiting**: 100 requests/minute per user

## Endpoints

### Create Order

**POST** `/orders`

Creates a new order.

**Request Body**:
```json
{
  "user_id": 123,
  "items": [
    {
      "product_id": 456,
      "quantity": 2
    }
  ],
  "shipping_address": {
    "street": "123 Main St",
    "city": "New York",
    "state": "NY",
    "zip": "10001",
    "country": "US"
  },
  "billing_address": {
    "street": "123 Main St",
    "city": "New York",
    "state": "NY",
    "zip": "10001",
    "country": "US"
  },
  "payment_method_id": 789
}
```

**Response** (201 Created):
```json
{
  "id": 1001,
  "order_number": "ORD-2024-001",
  "user_id": 123,
  "status": "pending",
  "total_amount": 199.98,
  "currency": "USD",
  "items": [
    {
      "id": 2001,
      "product_id": 456,
      "quantity": 2,
      "unit_price": 99.99,
      "total_price": 199.98
    }
  ],
  "shipping_address": { ... },
  "billing_address": { ... },
  "created_at": "2024-01-15T10:30:00Z",
  "updated_at": "2024-01-15T10:30:00Z"
}
```

**Error Responses**:
- `400 Bad Request`: Validation error
- `404 Not Found`: Product not found
- `409 Conflict`: Inventory insufficient
- `500 Internal Server Error`: Server error

**Example Error Response**:
```json
{
  "code": "INVENTORY_INSUFFICIENT",
  "message": "Insufficient inventory for product: 456",
  "timestamp": "2024-01-15T10:30:00Z"
}
```

### Get Order

**GET** `/orders/{id}`

Retrieves order details by ID.

**Path Parameters**:
- `id` (integer, required): Order ID

**Response** (200 OK):
```json
{
  "id": 1001,
  "order_number": "ORD-2024-001",
  "user_id": 123,
  "status": "confirmed",
  "total_amount": 199.98,
  "currency": "USD",
  "items": [ ... ],
  "status_history": [
    {
      "status": "pending",
      "changed_at": "2024-01-15T10:30:00Z",
      "changed_by": 123,
      "notes": "Order created"
    },
    {
      "status": "confirmed",
      "changed_at": "2024-01-15T10:35:00Z",
      "changed_by": 123,
      "notes": "Payment confirmed"
    }
  ],
  "created_at": "2024-01-15T10:30:00Z",
  "updated_at": "2024-01-15T10:35:00Z"
}
```

**Error Responses**:
- `404 Not Found`: Order not found
- `500 Internal Server Error`: Server error

## Error Handling

All errors follow this format:
```json
{
  "code": "ERROR_CODE",
  "message": "Human-readable error message",
  "timestamp": "2024-01-15T10:30:00Z"
}
```

**Error Codes**:
- `VALIDATION_ERROR`: Request validation failed
- `INVENTORY_INSUFFICIENT`: Not enough inventory
- `ORDER_NOT_FOUND`: Order not found
- `INVALID_STATUS_TRANSITION`: Invalid status change
- `CONCURRENT_MODIFICATION`: Order modified by another process
- `INTERNAL_ERROR`: Unexpected server error

## Rate Limiting

- **Limit**: 100 requests/minute per user
- **Headers**: 
  - `X-RateLimit-Limit`: Request limit
  - `X-RateLimit-Remaining`: Remaining requests
  - `X-RateLimit-Reset`: Reset time (Unix timestamp)
- **Response** (429 Too Many Requests): When limit exceeded

## Versioning

API versioning via URL path: `/api/v1/orders`

**Deprecation Policy**:
- Old versions supported for 6 months after new version release
- Deprecation notice sent 3 months before removal
- Migration guide provided

## Examples

### cURL Examples

```bash
# Create order
curl -X POST https://api.example.com/api/v1/orders \
  -H "Authorization: Bearer {token}" \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": 123,
    "items": [{"product_id": 456, "quantity": 2}],
    "shipping_address": {...},
    "billing_address": {...},
    "payment_method_id": 789
  }'

# Get order
curl -X GET https://api.example.com/api/v1/orders/1001 \
  -H "Authorization: Bearer {token}"
```
```

---

## Summary of Part 3

### Key Takeaways

**Implementation Phase**:
1. **Create Detailed Design**: Database schemas, APIs, business logic, error handling
2. **Define Interfaces**: Service interfaces, repository interfaces, client interfaces, event interfaces
3. **Plan Implementation**: Phases, tasks, resources, risk mitigation
4. **Document Decisions**: ADRs, API docs, architecture docs, runbooks

**The Result**: Complete implementation plan with detailed design, clear interfaces, actionable plan, and comprehensive documentation.

---

## Complete Workflow Summary

**The Principal Engineer Workflow**:

1. **Evaluates**: Reviews AI suggestions, assesses business fit, identifies gaps, considers constraints
2. **Refines**: Adapts to business context, makes trade-offs, integrates with existing, optimizes
3. **Validates**: Tests assumptions, validates performance, assesses risks, confirms feasibility
4. **Implements**: Creates detailed design, defines interfaces, plans implementation, documents decisions

**The Result**: Production-ready system that works for YOUR business, not a generic solution.

