# AWS for Java Principal Engineers

## Part 3: DevOps, Containers, and Infrastructure

---

## Table of Contents

1. [Elastic Container Service (ECS)](#1-elastic-container-service-ecs)
2. [Elastic Kubernetes Service (EKS)](#2-elastic-kubernetes-service-eks)
3. [AWS Fargate](#3-aws-fargate)
4. [Elastic Container Registry (ECR)](#4-elastic-container-registry-ecr)
5. [CI/CD with AWS CodePipeline](#5-cicd-with-aws-codepipeline)
6. [Infrastructure as Code (CloudFormation)](#6-infrastructure-as-code-cloudformation)
7. [CloudWatch and Monitoring](#7-cloudwatch-and-monitoring)
8. [X-Ray Distributed Tracing](#8-x-ray-distributed-tracing)

---

## 1. Elastic Container Service (ECS)

### 1.1 ECS Overview

**ECS** is a fully managed container orchestration service.

**Key Concepts**:
- **Cluster**: Group of EC2 instances or Fargate capacity
- **Task Definition**: Blueprint for containers
- **Task**: Running instance of a task definition
- **Service**: Maintains desired number of tasks

### 1.2 ECS Launch Types

**EC2 Launch Type**:
- Run containers on EC2 instances you manage
- More control, cost-effective for steady workloads
- You manage EC2 instances, scaling, patching

**Fargate Launch Type**:
- Serverless, no EC2 to manage
- Pay per task
- AWS manages infrastructure

### 1.3 Java Application: Dockerfile

**Dockerfile for Spring Boot**:
```dockerfile
# Multi-stage build
FROM maven:3.8.6-openjdk-17 AS build
WORKDIR /app

# Copy pom.xml and download dependencies
COPY pom.xml .
RUN mvn dependency:go-offline -B

# Copy source and build
COPY src ./src
RUN mvn clean package -DskipTests

# Runtime stage
FROM openjdk:17-jre-slim
WORKDIR /app

# Copy JAR from build stage
COPY --from=build /app/target/myapp.jar app.jar

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD curl -f http://localhost:8080/actuator/health || exit 1

# Run application
ENTRYPOINT ["java", "-jar", "app.jar"]
```

**Docker Compose (Local Development)**:
```yaml
version: '3.8'
services:
  app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=local
      - DB_HOST=db
      - REDIS_HOST=redis
    depends_on:
      - db
      - redis
  
  db:
    image: postgres:14
    environment:
      - POSTGRES_DB=myapp
      - POSTGRES_USER=myapp
      - POSTGRES_PASSWORD=password
    ports:
      - "5432:5432"
  
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
```

### 1.4 ECS Task Definition

**Task Definition JSON**:
```json
{
  "family": "myapp-task",
  "networkMode": "awsvpc",
  "requiresCompatibilities": ["FARGATE"],
  "cpu": "512",
  "memory": "1024",
  "executionRoleArn": "arn:aws:iam::123456789:role/ecsTaskExecutionRole",
  "taskRoleArn": "arn:aws:iam::123456789:role/ecsTaskRole",
  "containerDefinitions": [
    {
      "name": "myapp",
      "image": "123456789.dkr.ecr.us-east-1.amazonaws.com/myapp:latest",
      "essential": true,
      "portMappings": [
        {
          "containerPort": 8080,
          "protocol": "tcp"
        }
      ],
      "environment": [
        {
          "name": "SPRING_PROFILES_ACTIVE",
          "value": "production"
        },
        {
          "name": "DB_HOST",
          "value": "myapp-db.cluster-xyz.us-east-1.rds.amazonaws.com"
        }
      ],
      "secrets": [
        {
          "name": "DB_PASSWORD",
          "valueFrom": "arn:aws:secretsmanager:us-east-1:123456789:secret:myapp/db/password"
        }
      ],
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "/ecs/myapp",
          "awslogs-region": "us-east-1",
          "awslogs-stream-prefix": "ecs"
        }
      },
      "healthCheck": {
        "command": ["CMD-SHELL", "curl -f http://localhost:8080/actuator/health || exit 1"],
        "interval": 30,
        "timeout": 5,
        "retries": 3,
        "startPeriod": 60
      }
    }
  ]
}
```

### 1.5 ECS Service Configuration

**Service Configuration**:
```yaml
Service Configuration:
  Service Name: myapp-service
  Cluster: myapp-cluster
  Task Definition: myapp-task:1
  Desired Count: 3
  Launch Type: Fargate
  
  Network Configuration:
    Subnets: [subnet-123, subnet-456]  # Private subnets
    Security Groups: [sg-789]
    Assign Public IP: false
  
  Load Balancer:
    Type: Application Load Balancer
    Target Group: myapp-target-group
    Container Port: 8080
  
  Auto Scaling:
    Min Capacity: 3
    Max Capacity: 10
    Target CPU: 70%
    Target Memory: 80%
  
  Deployment:
    Type: Rolling Update
    Minimum Healthy Percent: 50%
    Maximum Percent: 200%
```

---

## 2. Elastic Kubernetes Service (EKS)

### 2.1 EKS Overview

**EKS** is a managed Kubernetes service.

**Key Benefits**:
- **Kubernetes**: Industry-standard container orchestration
- **Managed Control Plane**: AWS manages Kubernetes control plane
- **Integration**: Integrates with AWS services
- **Compatibility**: Standard Kubernetes APIs

### 2.2 EKS Architecture

```
EKS Architecture:
├── EKS Control Plane (Managed by AWS)
│   ├── API Server
│   ├── etcd
│   └── Scheduler
├── Worker Nodes (EC2 or Fargate)
│   ├── Node 1 (us-east-1a)
│   ├── Node 2 (us-east-1b)
│   └── Node 3 (us-east-1c)
└── Add-ons
    ├── CoreDNS
    ├── kube-proxy
    └── VPC CNI
```

### 2.3 Java Application: Kubernetes Deployment

**Deployment YAML**:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
  namespace: production
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp
        image: 123456789.dkr.ecr.us-east-1.amazonaws.com/myapp:latest
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "production"
        - name: DB_HOST
          valueFrom:
            secretKeyRef:
              name: myapp-secrets
              key: db-host
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: myapp-secrets
              key: db-password
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /actuator/health/liveness
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /actuator/health/readiness
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
---
apiVersion: v1
kind: Service
metadata:
  name: myapp-service
  namespace: production
spec:
  type: ClusterIP
  selector:
    app: myapp
  ports:
  - port: 80
    targetPort: 8080
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: myapp-hpa
  namespace: production
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: myapp
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

**Spring Boot Kubernetes Configuration**:
```yaml
# application.yml
spring:
  application:
    name: myapp
  kubernetes:
    discovery:
      enabled: true
    config:
      enabled: true
      sources:
        - name: myapp-config
          namespace: production
```

**Java Code: Kubernetes Discovery**:
```java
@Configuration
@EnableDiscoveryClient
public class KubernetesConfiguration {
    // Spring Cloud Kubernetes automatically discovers services
    // No special code needed
}
```

---

## 3. AWS Fargate

### 3.1 Fargate Overview

**Fargate** is a serverless compute engine for containers.

**Key Benefits**:
- **No EC2 Management**: AWS manages infrastructure
- **Pay per Task**: Pay only for running tasks
- **Auto-scaling**: Scales automatically
- **Security**: Task-level isolation

### 3.2 Fargate vs EC2 Launch Type

**Fargate**:
- No EC2 instances to manage
- Pay per task (vCPU + memory)
- Simpler, less control
- Good for: Variable workloads, small teams

**EC2 Launch Type**:
- Manage EC2 instances
- Pay per instance
- More control, cost-effective for steady workloads
- Good for: Predictable workloads, cost optimization

### 3.3 Fargate Task Configuration

**Task Definition (Fargate)**:
```json
{
  "family": "myapp-fargate",
  "networkMode": "awsvpc",
  "requiresCompatibilities": ["FARGATE"],
  "cpu": "512",
  "memory": "1024",
  "containerDefinitions": [
    {
      "name": "myapp",
      "image": "123456789.dkr.ecr.us-east-1.amazonaws.com/myapp:latest",
      "essential": true,
      "portMappings": [
        {
          "containerPort": 8080,
          "protocol": "tcp"
        }
      ],
      "environment": [
        {
          "name": "SPRING_PROFILES_ACTIVE",
          "value": "production"
        }
      ],
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "/ecs/myapp",
          "awslogs-region": "us-east-1",
          "awslogs-stream-prefix": "ecs"
        }
      }
    }
  ]
}
```

---

## 4. Elastic Container Registry (ECR)

### 4.1 ECR Overview

**ECR** is a fully managed Docker container registry.

**Key Features**:
- **Docker Registry**: Store and manage Docker images
- **Integration**: Works with ECS, EKS, Lambda
- **Security**: Encryption, access control
- **Lifecycle Policies**: Automatically clean up old images

### 4.2 Java Application: Building and Pushing to ECR

**Maven Plugin for Docker**:
```xml
<plugin>
    <groupId>com.spotify</groupId>
    <artifactId>dockerfile-maven-plugin</artifactId>
    <version>1.4.13</version>
    <configuration>
        <repository>123456789.dkr.ecr.us-east-1.amazonaws.com/myapp</repository>
        <tag>${project.version}</tag>
    </configuration>
</plugin>
```

**Build and Push Script**:
```bash
#!/bin/bash

# Variables
AWS_REGION=us-east-1
AWS_ACCOUNT_ID=123456789
ECR_REPOSITORY=myapp
IMAGE_TAG=latest

# Login to ECR
aws ecr get-login-password --region $AWS_REGION | \
  docker login --username AWS --password-stdin \
  $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com

# Build image
docker build -t $ECR_REPOSITORY:$IMAGE_TAG .

# Tag image
docker tag $ECR_REPOSITORY:$IMAGE_TAG \
  $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPOSITORY:$IMAGE_TAG

# Push image
docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPOSITORY:$IMAGE_TAG
```

**Java Code: ECR Integration**:
```java
// No direct Java code needed
// ECR is used during build/deploy process
// Applications pull images from ECR at runtime
```

---

## 5. CI/CD with AWS CodePipeline

### 5.1 CodePipeline Overview

**CodePipeline** is a fully managed CI/CD service.

**Pipeline Stages**:
1. **Source**: Get code from repository
2. **Build**: Build and test code
3. **Deploy**: Deploy to environments

### 5.2 CodePipeline Configuration

**Pipeline YAML (CloudFormation)**:
```yaml
Resources:
  Pipeline:
    Type: AWS::CodePipeline::Pipeline
    Properties:
      Name: myapp-pipeline
      RoleArn: !GetAtt PipelineRole.Arn
      ArtifactStore:
        Type: S3
        Location: myapp-pipeline-artifacts
      Stages:
        - Name: Source
          Actions:
            - Name: SourceAction
              ActionTypeId:
                Category: Source
                Owner: AWS
                Provider: CodeCommit
                Version: 1
              Configuration:
                RepositoryName: myapp-repo
                BranchName: main
              OutputArtifacts:
                - Name: SourceOutput
        
        - Name: Build
          Actions:
            - Name: BuildAction
              ActionTypeId:
                Category: Build
                Owner: AWS
                Provider: CodeBuild
                Version: 1
              Configuration:
                ProjectName: !Ref BuildProject
              InputArtifacts:
                - Name: SourceOutput
              OutputArtifacts:
                - Name: BuildOutput
        
        - Name: Deploy
          Actions:
            - Name: DeployAction
              ActionTypeId:
                Category: Deploy
                Owner: AWS
                Provider: ECS
                Version: 1
              Configuration:
                ClusterName: myapp-cluster
                ServiceName: myapp-service
              InputArtifacts:
                - Name: BuildOutput
```

### 5.3 CodeBuild Configuration

**buildspec.yml**:
```yaml
version: 0.2

phases:
  pre_build:
    commands:
      - echo Logging in to Amazon ECR...
      - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com
      - REPOSITORY_URI=$AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME
      - COMMIT_HASH=$(echo $CODEBUILD_RESOLVED_SOURCE_VERSION | cut -c 1-7)
      - IMAGE_TAG=${COMMIT_HASH:=latest}
  
  build:
    commands:
      - echo Build started on `date`
      - echo Building the Docker image...
      - docker build -t $REPOSITORY_URI:latest .
      - docker tag $REPOSITORY_URI:latest $REPOSITORY_URI:$IMAGE_TAG
  
  post_build:
    commands:
      - echo Build completed on `date`
      - echo Pushing the Docker images...
      - docker push $REPOSITORY_URI:latest
      - docker push $REPOSITORY_URI:$IMAGE_TAG
      - echo Writing image definitions file...
      - printf '[{"name":"myapp","imageUri":"%s"}]' $REPOSITORY_URI:latest > imagedefinitions.json
artifacts:
  files:
    - imagedefinitions.json
```

**Java Application: Build Configuration**:
```xml
<!-- Maven configuration for CI/CD -->
<profiles>
    <profile>
        <id>ci</id>
        <build>
            <plugins>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-surefire-plugin</artifactId>
                    <configuration>
                        <skipTests>false</skipTests>
                    </configuration>
                </plugin>
            </plugins>
        </build>
    </profile>
</profiles>
```

---

## 6. Infrastructure as Code (CloudFormation)

### 6.1 CloudFormation Overview

**CloudFormation** is Infrastructure as Code (IaC) for AWS.

**Key Concepts**:
- **Template**: JSON or YAML file describing infrastructure
- **Stack**: Collection of resources created from template
- **Parameters**: Input values for template
- **Outputs**: Values returned after stack creation

### 6.2 CloudFormation Template Example

**Complete Stack Template**:
```yaml
AWSTemplateFormatVersion: '2010-09-09'
Description: 'ECS Fargate Service with RDS and ElastiCache'

Parameters:
  Environment:
    Type: String
    Default: production
    AllowedValues: [development, staging, production]
  
  VpcId:
    Type: AWS::EC2::VPC::Id
    Description: VPC ID
  
  SubnetIds:
    Type: List<AWS::EC2::Subnet::Id>
    Description: Private subnet IDs

Resources:
  # ECS Cluster
  ECSCluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: !Sub '${Environment}-myapp-cluster'
      CapacityProviders:
        - FARGATE
        - FARGATE_SPOT
  
  # ECR Repository
  ECRRepository:
    Type: AWS::ECR::Repository
    Properties:
      RepositoryName: !Sub '${Environment}-myapp'
      ImageScanningConfiguration:
        ScanOnPush: true
      LifecyclePolicy:
        LifecyclePolicyText: |
          {
            "rules": [
              {
                "rulePriority": 1,
                "description": "Keep last 10 images",
                "selection": {
                  "tagStatus": "any",
                  "countType": "imageCountMoreThan",
                  "countNumber": 10
                },
                "action": {
                  "type": "expire"
                }
              }
            ]
          }
  
  # RDS Database
  RDSDatabase:
    Type: AWS::RDS::DBInstance
    Properties:
      DBInstanceIdentifier: !Sub '${Environment}-myapp-db'
      Engine: postgres
      EngineVersion: '14.5'
      DBInstanceClass: db.t3.medium
      AllocatedStorage: 100
      StorageType: gp3
      MasterUsername: admin
      MasterUserPassword: !Ref DatabasePassword
      VPCSecurityGroups:
        - !Ref DatabaseSecurityGroup
      DBSubnetGroupName: !Ref DBSubnetGroup
      BackupRetentionPeriod: 7
      MultiAZ: true
      StorageEncrypted: true
  
  # ElastiCache Redis
  ElastiCacheCluster:
    Type: AWS::ElastiCache::ReplicationGroup
    Properties:
      ReplicationGroupId: !Sub '${Environment}-myapp-redis'
      Description: Redis cluster for myapp
      Engine: redis
      CacheNodeType: cache.t3.micro
      NumCacheClusters: 2
      AutomaticFailoverEnabled: true
      MultiAZEnabled: true
      SubnetGroupName: !Ref CacheSubnetGroup
      SecurityGroupIds:
        - !Ref CacheSecurityGroup
  
  # ECS Task Definition
  ECSTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: !Sub '${Environment}-myapp-task'
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      Cpu: '512'
      Memory: '1024'
      ExecutionRoleArn: !GetAtt ECSTaskExecutionRole.Arn
      TaskRoleArn: !GetAtt ECSTaskRole.Arn
      ContainerDefinitions:
        - Name: myapp
          Image: !Sub '${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${ECRRepository}:latest'
          Essential: true
          PortMappings:
            - ContainerPort: 8080
              Protocol: tcp
          Environment:
            - Name: SPRING_PROFILES_ACTIVE
              Value: !Ref Environment
            - Name: DB_HOST
              Value: !GetAtt RDSDatabase.Endpoint.Address
            - Name: REDIS_HOST
              Value: !GetAtt ElastiCacheCluster.RedisEndpoint.Address
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref LogGroup
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: ecs
          HealthCheck:
            Command:
              - CMD-SHELL
              - curl -f http://localhost:8080/actuator/health || exit 1
            Interval: 30
            Timeout: 5
            Retries: 3
            StartPeriod: 60
  
  # ECS Service
  ECSService:
    Type: AWS::ECS::Service
    Properties:
      Cluster: !Ref ECSCluster
      ServiceName: !Sub '${Environment}-myapp-service'
      TaskDefinition: !Ref ECSTaskDefinition
      DesiredCount: 3
      LaunchType: FARGATE
      NetworkConfiguration:
        AwsvpcConfiguration:
          Subnets: !Ref SubnetIds
          SecurityGroups:
            - !Ref ECSServiceSecurityGroup
          AssignPublicIp: DISABLED
      LoadBalancers:
        - ContainerName: myapp
          ContainerPort: 8080
          TargetGroupArn: !Ref TargetGroup
      DeploymentConfiguration:
        MinimumHealthyPercent: 50
        MaximumPercent: 200
      HealthCheckGracePeriodSeconds: 60
  
  # Application Load Balancer
  ApplicationLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub '${Environment}-myapp-alb'
      Type: application
      Scheme: internal
      Subnets: !Ref SubnetIds
      SecurityGroups:
        - !Ref ALBSecurityGroup
  
  # Target Group
  TargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub '${Environment}-myapp-tg'
      Port: 8080
      Protocol: HTTP
      VpcId: !Ref VpcId
      TargetType: ip
      HealthCheckPath: /actuator/health
      HealthCheckIntervalSeconds: 30
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 2
      UnhealthyThresholdCount: 3
  
  # Auto Scaling
  ECSServiceAutoScaling:
    Type: AWS::ApplicationAutoScaling::ScalableTarget
    Properties:
      MaxCapacity: 10
      MinCapacity: 3
      ResourceId: !Sub 'service/${ECSCluster}/${ECSService}'
      RoleARN: !GetAtt AutoScalingRole.Arn
      ScalableDimension: ecs:service:DesiredCount
      ServiceNamespace: ecs
  
  ECSServiceScalingPolicy:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    Properties:
      PolicyName: !Sub '${Environment}-myapp-scaling-policy'
      PolicyType: TargetTrackingScaling
      ScalingTargetId: !Ref ECSServiceAutoScaling
      TargetTrackingScalingPolicyConfiguration:
        TargetValue: 70.0
        PredefinedMetricSpecification:
          PredefinedMetricType: ECSServiceAverageCPUUtilization
        ScaleInCooldown: 60
        ScaleOutCooldown: 60

Outputs:
  ClusterName:
    Description: ECS Cluster Name
    Value: !Ref ECSCluster
    Export:
      Name: !Sub '${Environment}-ClusterName'
  
  ServiceName:
    Description: ECS Service Name
    Value: !Ref ECSService
    Export:
      Name: !Sub '${Environment}-ServiceName'
  
  LoadBalancerDNS:
    Description: Load Balancer DNS
    Value: !GetAtt ApplicationLoadBalancer.DNSName
    Export:
      Name: !Sub '${Environment}-LoadBalancerDNS'
```

---

## 7. CloudWatch and Monitoring

### 7.1 CloudWatch Overview

**CloudWatch** is a monitoring and observability service.

**Key Features**:
- **Metrics**: Collect and track metrics
- **Logs**: Centralized logging
- **Alarms**: Automated actions based on metrics
- **Dashboards**: Visualize metrics and logs

### 7.2 Java Application: CloudWatch Integration

**Maven Dependencies**:
```xml
<dependency>
    <groupId>software.amazon.awssdk</groupId>
    <artifactId>cloudwatch</artifactId>
</dependency>
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-cloudwatch2</artifactId>
</dependency>
```

**Spring Boot Configuration**:
```yaml
# application.yml
management:
  metrics:
    export:
      cloudwatch:
        namespace: myapp
        batch-size: 20
        enabled: true
  endpoints:
    web:
      exposure:
        include: health,metrics,prometheus
  endpoint:
    health:
      show-details: always
```

**Custom Metrics**:
```java
@Service
public class OrderService {
    
    private final MeterRegistry meterRegistry;
    private final Counter orderCreatedCounter;
    private final Timer orderProcessingTimer;
    private final Gauge activeOrdersGauge;
    
    public OrderService(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.orderCreatedCounter = Counter.builder("orders.created")
            .description("Number of orders created")
            .tag("environment", "production")
            .register(meterRegistry);
        
        this.orderProcessingTimer = Timer.builder("orders.processing.time")
            .description("Order processing time")
            .register(meterRegistry);
        
        this.activeOrdersGauge = Gauge.builder("orders.active", 
            this, OrderService::getActiveOrdersCount)
            .description("Number of active orders")
            .register(meterRegistry);
    }
    
    public Order createOrder(OrderRequest request) {
        return orderProcessingTimer.recordCallable(() -> {
            Order order = processOrder(request);
            orderCreatedCounter.increment();
            return order;
        });
    }
    
    private int getActiveOrdersCount() {
        // Return count of active orders
        return orderRepository.countByStatus(OrderStatus.PROCESSING);
    }
}
```

**CloudWatch Logs**:
```java
@Configuration
public class LoggingConfiguration {
    
    @Bean
    public CloudWatchLogsAppender cloudWatchLogsAppender() {
        // Logback configuration for CloudWatch
        // Configure in logback-spring.xml
        return new CloudWatchLogsAppender();
    }
}
```

**logback-spring.xml**:
```xml
<configuration>
    <appender name="CLOUDWATCH" class="ca.pjer.logback.AwsLogsAppender">
        <logGroupName>/aws/ecs/myapp</logGroupName>
        <logStreamName>myapp-${HOSTNAME}</logStreamName>
        <region>us-east-1</region>
    </appender>
    
    <root level="INFO">
        <appender-ref ref="CLOUDWATCH" />
    </root>
</configuration>
```

---

## 8. X-Ray Distributed Tracing

### 8.1 X-Ray Overview

**X-Ray** provides distributed tracing for applications.

**Key Features**:
- **Request Tracing**: Trace requests across services
- **Service Map**: Visualize service dependencies
- **Performance Analysis**: Identify bottlenecks
- **Error Analysis**: Track errors and exceptions

### 8.2 Java Application: X-Ray Integration

**Maven Dependencies**:
```xml
<dependency>
    <groupId>com.amazonaws</groupId>
    <artifactId>aws-xray-recorder-sdk-core</artifactId>
</dependency>
<dependency>
    <groupId>com.amazonaws</groupId>
    <artifactId>aws-xray-recorder-sdk-spring</artifactId>
</dependency>
```

**Spring Boot Configuration**:
```java
@Configuration
@EnableXRay
public class XRayConfiguration {
    
    @Bean
    public FilterRegistrationBean<XRayServletFilter> xRayFilter() {
        FilterRegistrationBean<XRayServletFilter> registration = 
            new FilterRegistrationBean<>(new XRayServletFilter("myapp"));
        registration.addUrlPatterns("/*");
        return registration;
    }
}
```

**X-Ray Tracing in Code**:
```java
@Service
public class OrderService {
    
    @XRayEnabled
    public Order createOrder(OrderRequest request) {
        return AWSXRay.beginSubsegment("createOrder", subsegment -> {
            try {
                subsegment.putMetadata("orderId", request.getOrderId());
                subsegment.putMetadata("userId", request.getUserId());
                
                Order order = processOrder(request);
                
                subsegment.putMetadata("orderTotal", order.getTotalAmount());
                return order;
                
            } catch (Exception e) {
                subsegment.addException(e);
                throw e;
            }
        });
    }
    
    private Order processOrder(OrderRequest request) {
        return AWSXRay.beginSubsegment("processOrder", subsegment -> {
            // Order processing logic
            return order;
        });
    }
}
```

**X-Ray Annotations**:
```java
@RestController
@RequestMapping("/api/orders")
@XRayEnabled
public class OrderController {
    
    @Autowired
    private OrderService orderService;
    
    @PostMapping
    @XRayEnabled
    public ResponseEntity<Order> createOrder(@RequestBody OrderRequest request) {
        Order order = orderService.createOrder(request);
        return ResponseEntity.ok(order);
    }
}
```

---

## Summary of Part 3

### Key Takeaways

1. **ECS**: Container orchestration, Fargate/EC2 launch types
2. **EKS**: Managed Kubernetes, container orchestration
3. **Fargate**: Serverless containers, no EC2 management
4. **ECR**: Docker registry, image storage
5. **CodePipeline**: CI/CD automation
6. **CloudFormation**: Infrastructure as Code
7. **CloudWatch**: Monitoring, metrics, logs
8. **X-Ray**: Distributed tracing

### Next Steps

**Part 4** will cover:
- Production-Ready Architecture Patterns
- Security Best Practices
- High Availability and Disaster Recovery
- Cost Optimization
- Performance Optimization
- Real-World Production Deployment

---

**Ready for Part 4?** These DevOps and infrastructure concepts are essential for deploying production Java applications on AWS.

