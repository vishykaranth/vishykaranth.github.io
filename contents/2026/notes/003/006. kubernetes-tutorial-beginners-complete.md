# Kubernetes Tutorial for Beginners - Complete 4-Hour Course Guide

## Table of Contents
1. [Kubernetes Basics](#kubernetes-basics)
2. [Installation & Setup](#installation--setup)
3. [Core Concepts](#core-concepts)
4. [Kubernetes Objects](#kubernetes-objects)
5. [kubectl Commands](#kubectl-commands)
6. [Pods](#pods)
7. [Services](#services)
8. [Deployments](#deployments)
9. [ConfigMaps & Secrets](#configmaps--secrets)
10. [Volumes & Storage](#volumes--storage)
11. [Namespaces](#namespaces)
12. [Networking](#networking)
13. [Scaling & Autoscaling](#scaling--autoscaling)
14. [Rolling Updates & Rollbacks](#rolling-updates--rollbacks)
15. [Monitoring & Logging](#monitoring--logging)
16. [Best Practices](#best-practices)
17. [Common Use Cases](#common-use-cases)
18. [Troubleshooting](#troubleshooting)
19. [Interview Questions & Answers](#interview-questions--answers)

---

## Kubernetes Basics

### What is Kubernetes?

**Kubernetes (K8s)** is:
- **Container Orchestration**: Automates container deployment, scaling, and management
- **Open Source**: Open-source container orchestration platform
- **Portable**: Works across cloud providers and on-premises
- **Scalable**: Handles scaling from single node to thousands
- **Self-Healing**: Automatically restarts failed containers

### Why Kubernetes?

**Benefits:**
1. **Automation**: Automates deployment and scaling
2. **High Availability**: Ensures application availability
3. **Resource Efficiency**: Optimizes resource usage
4. **Portability**: Run anywhere (cloud, on-prem, hybrid)
5. **Self-Healing**: Automatically recovers from failures
6. **Rolling Updates**: Zero-downtime deployments

### Kubernetes vs Docker Swarm

| Feature | Kubernetes | Docker Swarm |
|---------|------------|--------------|
| **Complexity** | High | Low |
| **Scalability** | Very High | High |
| **Features** | Rich | Basic |
| **Learning Curve** | Steep | Gentle |
| **Enterprise** | Yes | Limited |

### Kubernetes Architecture

```
┌─────────────────────────────────────────┐
│         Control Plane (Master)          │
│  ┌──────────┐  ┌──────────┐  ┌────────┐│
│  │ API      │  │ etcd     │  │Scheduler││
│  │ Server   │  │          │  │        ││
│  └──────────┘  └──────────┘  └────────┘│
│  ┌──────────┐  ┌──────────┐            │
│  │Controller│  │Cloud     │            │
│  │ Manager  │  │Controller│            │
│  └──────────┘  └──────────┘            │
└─────────────────────────────────────────┘
              │
    ┌─────────┼─────────┐
    ↓         ↓         ↓
┌────────┐ ┌────────┐ ┌────────┐
│ Worker │ │ Worker │ │ Worker │
│ Node   │ │ Node   │ │ Node   │
└────────┘ └────────┘ └────────┘
```

**Components:**

**Control Plane (Master):**
- **API Server**: Entry point for all operations
- **etcd**: Distributed key-value store
- **Scheduler**: Assigns pods to nodes
- **Controller Manager**: Manages controllers
- **Cloud Controller Manager**: Cloud-specific logic

**Worker Nodes:**
- **kubelet**: Agent running on each node
- **kube-proxy**: Network proxy
- **Container Runtime**: Docker, containerd, etc.

---

## Installation & Setup

### Local Development: Minikube

**Installation (macOS):**
```bash
# Using Homebrew
brew install minikube

# Start Minikube
minikube start

# Check status
minikube status

# Stop Minikube
minikube stop

# Delete cluster
minikube delete
```

**Installation (Linux):**
```bash
# Download Minikube
curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
sudo install minikube-linux-amd64 /usr/local/bin/minikube

# Start Minikube
minikube start

# With specific driver
minikube start --driver=docker
```

**Installation (Windows):**
```powershell
# Using Chocolatey
choco install minikube

# Start Minikube
minikube start
```

### Install kubectl

**macOS:**
```bash
# Using Homebrew
brew install kubectl

# Or using curl
curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/darwin/amd64/kubectl"
chmod +x kubectl
sudo mv kubectl /usr/local/bin/
```

**Linux:**
```bash
# Download kubectl
curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
chmod +x kubectl
sudo mv kubectl /usr/local/bin/
```

**Windows:**
```powershell
# Using Chocolatey
choco install kubernetes-cli

# Or download from GitHub
# https://github.com/kubernetes/kubernetes/releases
```

### Verify Installation

```bash
# Check kubectl version
kubectl version --client

# Check cluster connection
kubectl cluster-info

# Get nodes
kubectl get nodes
```

### Cloud Kubernetes Services

**AWS EKS:**
```bash
# Install eksctl
brew install eksctl

# Create cluster
eksctl create cluster --name my-cluster --region us-west-2
```

**Google GKE:**
```bash
# Install gcloud CLI
# Create cluster
gcloud container clusters create my-cluster --zone us-central1-a
```

**Azure AKS:**
```bash
# Install Azure CLI
# Create cluster
az aks create --resource-group myResourceGroup --name myAKSCluster
```

---

## Core Concepts

### Pods

**What is a Pod?**
- **Smallest Unit**: Smallest deployable unit in Kubernetes
- **One or More Containers**: Can contain one or more containers
- **Shared Resources**: Containers share network and storage
- **Ephemeral**: Pods are created and destroyed

**Pod Characteristics:**
- **IP Address**: Each pod gets its own IP
- **Shared Storage**: Containers share volumes
- **Shared Network**: Containers share network namespace
- **Lifecycle**: Pods have lifecycle (Pending, Running, Succeeded, Failed)

### Services

**What is a Service?**
- **Network Abstraction**: Provides stable network endpoint
- **Load Balancing**: Distributes traffic to pods
- **Service Discovery**: Enables service discovery
- **Types**: ClusterIP, NodePort, LoadBalancer, ExternalName

### Deployments

**What is a Deployment?**
- **Pod Management**: Manages pod replicas
- **Rolling Updates**: Handles rolling updates
- **Rollbacks**: Supports rollbacks
- **Scaling**: Handles scaling

### Namespaces

**What is a Namespace?**
- **Resource Isolation**: Logical separation of resources
- **Default Namespaces**: default, kube-system, kube-public
- **Resource Quotas**: Can set resource limits per namespace

---

## Kubernetes Objects

### Object Structure

**YAML Structure:**
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-pod
  labels:
    app: my-app
spec:
  containers:
  - name: my-container
    image: nginx:1.21
    ports:
    - containerPort: 80
```

**Key Fields:**
- **apiVersion**: API version
- **kind**: Object type (Pod, Service, Deployment, etc.)
- **metadata**: Object metadata (name, labels, annotations)
- **spec**: Desired state specification
- **status**: Current state (read-only)

### Labels and Selectors

**Labels:**
```yaml
metadata:
  labels:
    app: my-app
    version: v1
    environment: production
```

**Selectors:**
```yaml
selector:
  matchLabels:
    app: my-app
  matchExpressions:
    - {key: version, operator: In, values: [v1, v2]}
```

### Annotations

**Annotations:**
```yaml
metadata:
  annotations:
    description: "My application"
    build-date: "2024-01-01"
```

---

## kubectl Commands

### Basic Commands

**Get Resources:**
```bash
# Get pods
kubectl get pods

# Get all resources
kubectl get all

# Get with namespace
kubectl get pods -n namespace-name

# Get with output format
kubectl get pods -o wide
kubectl get pods -o yaml
kubectl get pods -o json

# Watch resources
kubectl get pods -w
```

**Describe Resources:**
```bash
# Describe pod
kubectl describe pod pod-name

# Describe service
kubectl describe service service-name

# Describe deployment
kubectl describe deployment deployment-name
```

**Create Resources:**
```bash
# Create from YAML
kubectl create -f pod.yaml

# Create from URL
kubectl create -f https://example.com/pod.yaml

# Create with dry-run
kubectl create -f pod.yaml --dry-run=client -o yaml
```

**Apply Resources:**
```bash
# Apply YAML (create or update)
kubectl apply -f pod.yaml

# Apply directory
kubectl apply -f ./manifests/

# Apply with force
kubectl apply -f pod.yaml --force
```

**Delete Resources:**
```bash
# Delete pod
kubectl delete pod pod-name

# Delete from YAML
kubectl delete -f pod.yaml

# Delete all pods
kubectl delete pods --all

# Delete with label selector
kubectl delete pods -l app=my-app
```

### Exec and Logs

**Execute Commands:**
```bash
# Execute command in pod
kubectl exec pod-name -- ls

# Interactive shell
kubectl exec -it pod-name -- /bin/bash

# Execute in specific container
kubectl exec -it pod-name -c container-name -- /bin/bash
```

**View Logs:**
```bash
# View logs
kubectl logs pod-name

# Follow logs
kubectl logs -f pod-name

# Logs from specific container
kubectl logs pod-name -c container-name

# Previous container logs
kubectl logs pod-name --previous

# Logs with timestamps
kubectl logs pod-name --timestamps
```

### Port Forwarding

```bash
# Port forward
kubectl port-forward pod-name 8080:80

# Port forward service
kubectl port-forward service/service-name 8080:80

# Port forward deployment
kubectl port-forward deployment/deployment-name 8080:80
```

### Other Useful Commands

```bash
# Get cluster info
kubectl cluster-info

# Get nodes
kubectl get nodes

# Get namespaces
kubectl get namespaces

# Get events
kubectl get events

# Get resource usage
kubectl top nodes
kubectl top pods

# Explain resource
kubectl explain pod
kubectl explain pod.spec
```

---

## Pods

### Pod Definition

**Basic Pod:**
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
  labels:
    app: nginx
spec:
  containers:
  - name: nginx
    image: nginx:1.21
    ports:
    - containerPort: 80
```

**Multi-Container Pod:**
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: multi-container-pod
spec:
  containers:
  - name: nginx
    image: nginx:1.21
    ports:
    - containerPort: 80
  - name: redis
    image: redis:6-alpine
    ports:
    - containerPort: 6379
```

### Pod Lifecycle

**States:**
- **Pending**: Pod accepted, containers not created
- **Running**: Pod bound to node, containers running
- **Succeeded**: All containers terminated successfully
- **Failed**: At least one container failed
- **Unknown**: Pod state cannot be determined

### Pod Spec

**Resource Limits:**
```yaml
spec:
  containers:
  - name: nginx
    image: nginx:1.21
    resources:
      requests:
        memory: "64Mi"
        cpu: "250m"
      limits:
        memory: "128Mi"
        cpu: "500m"
```

**Environment Variables:**
```yaml
spec:
  containers:
  - name: nginx
    image: nginx:1.21
    env:
    - name: ENV_VAR
      value: "value"
    - name: ENV_VAR_FROM_SECRET
      valueFrom:
        secretKeyRef:
          name: my-secret
          key: password
```

**Volume Mounts:**
```yaml
spec:
  containers:
  - name: nginx
    image: nginx:1.21
    volumeMounts:
    - name: config-volume
      mountPath: /etc/nginx
  volumes:
  - name: config-volume
    configMap:
      name: nginx-config
```

**Health Checks:**
```yaml
spec:
  containers:
  - name: nginx
    image: nginx:1.21
    livenessProbe:
      httpGet:
        path: /health
        port: 80
      initialDelaySeconds: 30
      periodSeconds: 10
    readinessProbe:
      httpGet:
        path: /ready
        port: 80
      initialDelaySeconds: 5
      periodSeconds: 5
```

---

## Services

### Service Types

**1. ClusterIP (Default):**
```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  type: ClusterIP
  selector:
    app: my-app
  ports:
  - port: 80
    targetPort: 8080
```

**2. NodePort:**
```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  type: NodePort
  selector:
    app: my-app
  ports:
  - port: 80
    targetPort: 8080
    nodePort: 30080
```

**3. LoadBalancer:**
```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  type: LoadBalancer
  selector:
    app: my-app
  ports:
  - port: 80
    targetPort: 8080
```

**4. ExternalName:**
```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  type: ExternalName
  externalName: external-service.example.com
```

### Service Examples

**Basic Service:**
```yaml
apiVersion: v1
kind: Service
metadata:
  name: web-service
spec:
  selector:
    app: web
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080
```

**Service with Multiple Ports:**
```yaml
apiVersion: v1
kind: Service
metadata:
  name: multi-port-service
spec:
  selector:
    app: my-app
  ports:
  - name: http
    port: 80
    targetPort: 8080
  - name: https
    port: 443
    targetPort: 8443
```

---

## Deployments

### Deployment Definition

**Basic Deployment:**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.21
        ports:
        - containerPort: 80
```

### Deployment Strategies

**Rolling Update (Default):**
```yaml
spec:
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
```

**Recreate:**
```yaml
spec:
  strategy:
    type: Recreate
```

### Deployment Commands

```bash
# Create deployment
kubectl create deployment nginx --image=nginx:1.21

# Scale deployment
kubectl scale deployment nginx-deployment --replicas=5

# Update deployment
kubectl set image deployment/nginx-deployment nginx=nginx:1.22

# Rollout status
kubectl rollout status deployment/nginx-deployment

# Rollout history
kubectl rollout history deployment/nginx-deployment

# Rollback
kubectl rollout undo deployment/nginx-deployment

# Rollback to specific revision
kubectl rollout undo deployment/nginx-deployment --to-revision=2
```

---

## ConfigMaps & Secrets

### ConfigMaps

**Create ConfigMap:**
```bash
# From literal
kubectl create configmap my-config --from-literal=key1=value1 --from-literal=key2=value2

# From file
kubectl create configmap my-config --from-file=config.properties

# From directory
kubectl create configmap my-config --from-file=./config/

# From YAML
kubectl create -f configmap.yaml
```

**ConfigMap YAML:**
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-config
data:
  key1: value1
  key2: value2
  config.properties: |
    property1=value1
    property2=value2
```

**Use ConfigMap in Pod:**
```yaml
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: nginx
    image: nginx:1.21
    envFrom:
    - configMapRef:
        name: my-config
    # Or
    env:
    - name: KEY1
      valueFrom:
        configMapKeyRef:
          name: my-config
          key: key1
    volumeMounts:
    - name: config-volume
      mountPath: /etc/config
  volumes:
  - name: config-volume
    configMap:
      name: my-config
```

### Secrets

**Create Secret:**
```bash
# From literal
kubectl create secret generic my-secret --from-literal=username=admin --from-literal=password=secret

# From file
kubectl create secret generic my-secret --from-file=username.txt --from-file=password.txt

# TLS secret
kubectl create secret tls my-tls-secret --cert=cert.pem --key=key.pem

# From YAML (base64 encoded)
kubectl create -f secret.yaml
```

**Secret YAML:**
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: my-secret
type: Opaque
data:
  username: YWRtaW4=  # base64 encoded
  password: c2VjcmV0  # base64 encoded
```

**Use Secret in Pod:**
```yaml
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: nginx
    image: nginx:1.21
    envFrom:
    - secretRef:
        name: my-secret
    # Or
    env:
    - name: PASSWORD
      valueFrom:
        secretKeyRef:
          name: my-secret
          key: password
    volumeMounts:
    - name: secret-volume
      mountPath: /etc/secret
  volumes:
  - name: secret-volume
    secret:
      secretName: my-secret
```

---

## Volumes & Storage

### Volume Types

**1. emptyDir:**
```yaml
spec:
  containers:
  - name: nginx
    image: nginx:1.21
    volumeMounts:
    - name: cache-volume
      mountPath: /cache
  volumes:
  - name: cache-volume
    emptyDir: {}
```

**2. hostPath:**
```yaml
volumes:
- name: host-volume
  hostPath:
    path: /data
    type: Directory
```

**3. PersistentVolumeClaim:**
```yaml
volumes:
- name: pvc-volume
  persistentVolumeClaim:
    claimName: my-pvc
```

### PersistentVolumes and PersistentVolumeClaims

**PersistentVolume:**
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: my-pv
spec:
  capacity:
    storage: 10Gi
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: slow
  hostPath:
    path: /data
```

**PersistentVolumeClaim:**
```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: my-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
  storageClassName: slow
```

**Use PVC in Pod:**
```yaml
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: nginx
    image: nginx:1.21
    volumeMounts:
    - name: pvc-volume
      mountPath: /data
  volumes:
  - name: pvc-volume
    persistentVolumeClaim:
      claimName: my-pvc
```

---

## Namespaces

### Working with Namespaces

**Create Namespace:**
```bash
# Create namespace
kubectl create namespace my-namespace

# Or from YAML
kubectl create -f namespace.yaml
```

**Namespace YAML:**
```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: my-namespace
  labels:
    name: my-namespace
```

**Use Namespace:**
```bash
# Get pods in namespace
kubectl get pods -n my-namespace

# Create resource in namespace
kubectl create -f pod.yaml -n my-namespace

# Set default namespace
kubectl config set-context --current --namespace=my-namespace
```

**Resource Quotas:**
```yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: my-quota
  namespace: my-namespace
spec:
  hard:
    requests.cpu: "4"
    requests.memory: 8Gi
    limits.cpu: "8"
    limits.memory: 16Gi
    persistentvolumeclaims: "4"
    pods: "10"
```

---

## Networking

### Network Policies

**NetworkPolicy:**
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: my-network-policy
spec:
  podSelector:
    matchLabels:
      app: my-app
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: allowed-app
    ports:
    - protocol: TCP
      port: 80
  egress:
  - to:
    - podSelector:
        matchLabels:
          app: database
    ports:
    - protocol: TCP
      port: 5432
```

### Ingress

**Ingress:**
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-ingress
spec:
  rules:
  - host: example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: web-service
            port:
              number: 80
  - host: api.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: api-service
            port:
              number: 8080
```

**Ingress with TLS:**
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-ingress
spec:
  tls:
  - hosts:
    - example.com
    secretName: tls-secret
  rules:
  - host: example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: web-service
            port:
              number: 80
```

---

## Scaling & Autoscaling

### Manual Scaling

```bash
# Scale deployment
kubectl scale deployment nginx-deployment --replicas=5

# Scale with file
kubectl scale --replicas=5 -f deployment.yaml
```

### Horizontal Pod Autoscaler (HPA)

**HPA YAML:**
```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: nginx-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: nginx-deployment
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

**Create HPA:**
```bash
# Create HPA
kubectl autoscale deployment nginx-deployment --cpu-percent=70 --min=2 --max=10

# Get HPA
kubectl get hpa

# Describe HPA
kubectl describe hpa nginx-hpa
```

### Vertical Pod Autoscaler (VPA)

**VPA YAML:**
```yaml
apiVersion: autoscaling.k8s.io/v1
kind: VerticalPodAutoscaler
metadata:
  name: nginx-vpa
spec:
  targetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: nginx-deployment
  updatePolicy:
    updateMode: "Auto"
```

---

## Rolling Updates & Rollbacks

### Rolling Update

**Update Deployment:**
```bash
# Update image
kubectl set image deployment/nginx-deployment nginx=nginx:1.22

# Update with edit
kubectl edit deployment nginx-deployment

# Update with apply
kubectl apply -f deployment.yaml
```

**Rollout Status:**
```bash
# Check rollout status
kubectl rollout status deployment/nginx-deployment

# Pause rollout
kubectl rollout pause deployment/nginx-deployment

# Resume rollout
kubectl rollout resume deployment/nginx-deployment
```

### Rollback

**Rollback Commands:**
```bash
# Rollback to previous version
kubectl rollout undo deployment/nginx-deployment

# Rollback to specific revision
kubectl rollout undo deployment/nginx-deployment --to-revision=2

# View rollout history
kubectl rollout history deployment/nginx-deployment

# View specific revision
kubectl rollout history deployment/nginx-deployment --revision=2
```

---

## Monitoring & Logging

### Monitoring

**Resource Usage:**
```bash
# Node resource usage
kubectl top nodes

# Pod resource usage
kubectl top pods

# Pod resource usage in namespace
kubectl top pods -n my-namespace
```

**Metrics Server:**
```bash
# Install metrics server
kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
```

### Logging

**View Logs:**
```bash
# Pod logs
kubectl logs pod-name

# Follow logs
kubectl logs -f pod-name

# Previous container logs
kubectl logs pod-name --previous

# Logs from all containers
kubectl logs pod-name --all-containers=true
```

**Centralized Logging:**
- **ELK Stack**: Elasticsearch, Logstash, Kibana
- **Loki**: Grafana Loki
- **Fluentd**: Log aggregator

---

## Best Practices

### 1. Use Deployments, Not Pods

**Bad:**
```yaml
apiVersion: v1
kind: Pod
```

**Good:**
```yaml
apiVersion: apps/v1
kind: Deployment
```

### 2. Set Resource Limits

```yaml
resources:
  requests:
    memory: "64Mi"
    cpu: "250m"
  limits:
    memory: "128Mi"
    cpu: "500m"
```

### 3. Use Health Checks

```yaml
livenessProbe:
  httpGet:
    path: /health
    port: 8080
  initialDelaySeconds: 30
  periodSeconds: 10

readinessProbe:
  httpGet:
    path: /ready
    port: 8080
  initialDelaySeconds: 5
  periodSeconds: 5
```

### 4. Use Namespaces

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: production
```

### 5. Use ConfigMaps and Secrets

```yaml
# Don't hardcode configuration
env:
- name: CONFIG
  valueFrom:
    configMapKeyRef:
      name: my-config
      key: config-key
```

### 6. Use Labels and Selectors

```yaml
metadata:
  labels:
    app: my-app
    version: v1
    environment: production
```

### 7. Use PersistentVolumes for Data

```yaml
volumes:
- name: data-volume
  persistentVolumeClaim:
    claimName: my-pvc
```

---

## Common Use Cases

### 1. Web Application

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: web-app
  template:
    metadata:
      labels:
        app: web-app
    spec:
      containers:
      - name: web
        image: myapp:1.0
        ports:
        - containerPort: 8080
        resources:
          requests:
            memory: "128Mi"
            cpu: "250m"
          limits:
            memory: "256Mi"
            cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: web-service
spec:
  selector:
    app: web-app
  ports:
  - port: 80
    targetPort: 8080
  type: LoadBalancer
```

### 2. Database with Persistent Storage

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: db-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
      - name: postgres
        image: postgres:13
        env:
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: password
        volumeMounts:
        - name: db-storage
          mountPath: /var/lib/postgresql/data
      volumes:
      - name: db-storage
        persistentVolumeClaim:
          claimName: db-pvc
```

### 3. Multi-Tier Application

```yaml
# Frontend
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
spec:
  replicas: 3
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: frontend
        image: frontend:1.0
---
# Backend
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
spec:
  replicas: 3
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: backend:1.0
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: url
---
# Database
apiVersion: apps/v1
kind: Deployment
metadata:
  name: database
spec:
  replicas: 1
  selector:
    matchLabels:
      app: database
  template:
    metadata:
      labels:
        app: database
    spec:
      containers:
      - name: postgres
        image: postgres:13
```

---

## Troubleshooting

### Common Issues

**1. Pod Not Starting:**
```bash
# Check pod status
kubectl get pods

# Describe pod
kubectl describe pod pod-name

# Check logs
kubectl logs pod-name

# Check events
kubectl get events
```

**2. Service Not Working:**
```bash
# Check service
kubectl get svc

# Describe service
kubectl describe svc service-name

# Check endpoints
kubectl get endpoints service-name

# Test service
kubectl port-forward svc/service-name 8080:80
```

**3. Deployment Issues:**
```bash
# Check deployment
kubectl get deployment

# Describe deployment
kubectl describe deployment deployment-name

# Check rollout status
kubectl rollout status deployment/deployment-name

# View rollout history
kubectl rollout history deployment/deployment-name
```

**4. Resource Issues:**
```bash
# Check node resources
kubectl top nodes

# Check pod resources
kubectl top pods

# Describe node
kubectl describe node node-name
```

**5. Network Issues:**
```bash
# Check network policies
kubectl get networkpolicies

# Test connectivity
kubectl exec pod-name -- ping other-pod-ip

# Check DNS
kubectl exec pod-name -- nslookup service-name
```

---

## Interview Questions & Answers

### Q1: What is Kubernetes?

**Answer:**
- **Container Orchestration**: Automates container deployment, scaling, and management
- **Open Source**: Open-source platform for container orchestration
- **Portable**: Works across cloud providers and on-premises
- **Scalable**: Handles scaling from single node to thousands
- **Self-Healing**: Automatically restarts failed containers

### Q2: What is a Pod?

**Answer:**
- **Smallest Unit**: Smallest deployable unit in Kubernetes
- **One or More Containers**: Can contain one or more containers
- **Shared Resources**: Containers share network and storage
- **Ephemeral**: Pods are created and destroyed
- **IP Address**: Each pod gets its own IP

### Q3: What is a Service?

**Answer:**
- **Network Abstraction**: Provides stable network endpoint
- **Load Balancing**: Distributes traffic to pods
- **Service Discovery**: Enables service discovery
- **Types**: ClusterIP, NodePort, LoadBalancer, ExternalName
- **Selector**: Uses labels to select pods

### Q4: What is a Deployment?

**Answer:**
- **Pod Management**: Manages pod replicas
- **Rolling Updates**: Handles rolling updates
- **Rollbacks**: Supports rollbacks
- **Scaling**: Handles scaling
- **Desired State**: Maintains desired state

### Q5: What is the difference between Deployment and ReplicaSet?

**Answer:**
- **Deployment**: Higher-level abstraction, manages ReplicaSets
- **ReplicaSet**: Lower-level, ensures pod replicas
- **Deployment**: Handles updates and rollbacks
- **ReplicaSet**: Just maintains replica count
- **Use Deployment**: Always use Deployment, not ReplicaSet directly

### Q6: What are ConfigMaps and Secrets?

**Answer:**
- **ConfigMaps**: Store non-sensitive configuration data
- **Secrets**: Store sensitive data (passwords, keys)
- **Decouple**: Decouple configuration from container images
- **Mount**: Can be mounted as volumes or environment variables
- **Base64**: Secrets are base64 encoded

### Q7: What is a Namespace?

**Answer:**
- **Resource Isolation**: Logical separation of resources
- **Default Namespaces**: default, kube-system, kube-public
- **Resource Quotas**: Can set resource limits per namespace
- **Access Control**: Can control access per namespace
- **Organization**: Organize resources

### Q8: What is Horizontal Pod Autoscaler (HPA)?

**Answer:**
- **Automatic Scaling**: Automatically scales pods based on metrics
- **Metrics**: CPU, memory, custom metrics
- **Min/Max**: Set minimum and maximum replicas
- **Target**: Set target utilization
- **Dynamic**: Adjusts based on load

### Q9: How do you perform rolling updates?

**Answer:**
- **Update Image**: `kubectl set image deployment/name container=new-image`
- **Rolling Strategy**: Default strategy is RollingUpdate
- **Zero Downtime**: Updates pods one at a time
- **Rollback**: Can rollback with `kubectl rollout undo`
- **Status**: Check with `kubectl rollout status`

### Q10: What are the best practices for Kubernetes?

**Answer:**
1. **Use Deployments**: Not Pods directly
2. **Resource Limits**: Set requests and limits
3. **Health Checks**: Use liveness and readiness probes
4. **Namespaces**: Use namespaces for organization
5. **ConfigMaps/Secrets**: Don't hardcode configuration
6. **Labels**: Use labels and selectors
7. **PersistentVolumes**: Use for data persistence
8. **Security**: Don't run as root, use RBAC

---

## Summary

### Key Takeaways

1. **Kubernetes Basics**: Pods, Services, Deployments
2. **kubectl Commands**: Essential commands for managing K8s
3. **Configuration**: ConfigMaps, Secrets, Volumes
4. **Networking**: Services, Ingress, Network Policies
5. **Scaling**: Manual scaling, HPA, VPA
6. **Updates**: Rolling updates and rollbacks
7. **Best Practices**: Security, resource management, organization

### Learning Path

**Week 1: Basics**
- Install Minikube/kubectl
- Understand Pods, Services, Deployments
- Learn basic kubectl commands

**Week 2: Configuration**
- ConfigMaps and Secrets
- Volumes and PersistentVolumes
- Namespaces

**Week 3: Advanced**
- Networking and Ingress
- Scaling and Autoscaling
- Rolling updates

**Week 4: Production**
- Best practices
- Monitoring and logging
- Troubleshooting

---

**Course Complete** - You now have a comprehensive understanding of Kubernetes!

