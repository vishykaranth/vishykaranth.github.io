# Garbage Collection: GC Algorithms (G1, ZGC, Shenandoah) - Part 1

## Overview

Garbage Collection (GC) is the automatic memory management mechanism in Java that reclaims memory occupied by objects that are no longer in use. Modern JVMs offer several GC algorithms, each optimized for different use cases. This document covers G1, ZGC, and Shenandoah GC algorithms in detail.

---

## 1. Fundamentals of Garbage Collection

### 1.1 Memory Regions in JVM

```
┌─────────────────────────────────────────────────────────────┐
│                    JVM Heap Memory                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐  │
│  │              Young Generation                        │  │
│  │  ┌──────────────┐  ┌──────────────┐                 │  │
│  │  │    Eden      │  │   Survivor  │                 │  │
│  │  │              │  │   (S0/S1)    │                 │  │
│  │  └──────────────┘  └──────────────┘                 │  │
│  └─────────────────────────────────────────────────────┘  │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐  │
│  │              Old Generation (Tenured)                │  │
│  │                                                       │  │
│  └─────────────────────────────────────────────────────┘  │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐  │
│  │              Metaspace (Class Metadata)              │  │
│  └─────────────────────────────────────────────────────┘  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**Key Memory Regions**:

1. **Young Generation**:
   - **Eden Space**: New objects are allocated here
   - **Survivor Spaces (S0, S1)**: Objects that survive minor GCs
   - Small, fast collections

2. **Old Generation (Tenured)**:
   - Long-lived objects
   - Larger, slower collections
   - Major GC operations

3. **Metaspace**:
   - Class metadata, method information
   - Replaced PermGen in Java 8+

### 1.2 GC Types

**Minor GC (Young Generation Collection)**:
- Collects Eden and Survivor spaces
- Fast (typically < 100ms)
- Frequent (every few seconds to minutes)
- Stop-the-world pauses

**Major GC (Full GC)**:
- Collects entire heap (Young + Old)
- Slow (can be seconds)
- Less frequent
- Longer stop-the-world pauses

**Concurrent GC**:
- Runs concurrently with application threads
- Minimal pause times
- Used by ZGC and Shenandoah

---

## 2. G1 Garbage Collector (Garbage First)

### 2.1 Overview

G1 (Garbage First) is a low-latency, server-style GC introduced in Java 7 and made default in Java 9+. It's designed for applications with large heaps (6GB+) and low pause time requirements.

**Key Features**:
- **Concurrent Marking**: Marks live objects while application runs
- **Incremental Compaction**: Compacts incrementally to avoid long pauses
- **Predictable Pause Times**: Configurable pause time goals
- **Region-Based**: Divides heap into equal-sized regions

### 2.2 G1 Heap Layout

```
┌─────────────────────────────────────────────────────────────┐
│                    G1 Heap (Region-Based)                   │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐           │
│  │ Eden │ │ Eden │ │ Old  │ │ Old  │ │ Hum  │  ...      │
│  │ Reg  │ │ Reg  │ │ Reg  │ │ Reg  │ │ Reg  │           │
│  └──────┘ └──────┘ └──────┘ └──────┘ └──────┘           │
│                                                             │
│  Each region: 1MB to 32MB (default: heap_size / 2048)     │
│                                                             │
│  Region Types:                                             │
│  - Eden Regions: New object allocation                    │
│  - Survivor Regions: Surviving objects from minor GC      │
│  - Old Regions: Long-lived objects                       │
│  - Humongous Regions: Objects > 50% of region size       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2.3 G1 Collection Phases

#### Phase 1: Young Collection (Minor GC)

```java
/**
 * G1 Young Collection Process
 * 
 * 1. Stop-the-world: Mark roots
 * 2. Evacuate live objects from Eden and Survivor regions
 * 3. Copy survivors to new Survivor regions or promote to Old
 * 4. Update references
 * 5. Resume application
 */
```

**Example Young Collection**:

```
Before Young Collection:
┌─────────────────────────────────────────┐
│ Eden Regions: [E1, E2, E3]             │
│   E1: [obj1, obj2, obj3] (live)        │
│   E2: [obj4, obj5] (dead)              │
│   E3: [obj6] (live)                    │
│                                         │
│ Survivor: [S1]                         │
│   S1: [obj7, obj8] (live)              │
└─────────────────────────────────────────┘

After Young Collection:
┌─────────────────────────────────────────┐
│ Eden Regions: [E1, E2, E3] (cleared)   │
│                                         │
│ Survivor: [S2] (new)                    │
│   S2: [obj1, obj2, obj3, obj6, obj7, obj8]
│                                         │
│ Old Regions: [O1] (if age threshold)   │
│   O1: [obj9] (promoted)                │
└─────────────────────────────────────────┘
```

#### Phase 2: Concurrent Marking

```java
/**
 * G1 Concurrent Marking Cycle
 * 
 * 1. Initial Mark (STW): Mark roots
 * 2. Root Region Scanning: Scan survivor regions
 * 3. Concurrent Marking: Mark live objects (concurrent)
 * 4. Remark (STW): Finalize marking
 * 5. Cleanup (STW): Identify empty regions
 * 6. Concurrent Cleanup: Reclaim empty regions
 */
```

**Concurrent Marking Timeline**:

```
Time →
┌─────────────────────────────────────────────────────────────┐
│ Application Running                                          │
│                                                             │
│  [STW] Initial Mark (10ms)                                   │
│    │                                                         │
│    ├─> Root Region Scanning (concurrent)                    │
│    │                                                         │
│    ├─> Concurrent Marking (concurrent, ~100-200ms)          │
│    │                                                         │
│  [STW] Remark (20ms)                                        │
│    │                                                         │
│  [STW] Cleanup (5ms)                                        │
│    │                                                         │
│    └─> Concurrent Cleanup (concurrent)                    │
│                                                             │
│ Application Running                                          │
└─────────────────────────────────────────────────────────────┘
```

#### Phase 3: Mixed Collection

```java
/**
 * G1 Mixed Collection
 * 
 * After concurrent marking, G1 performs mixed collections:
 * - Collects both Young and Old regions
 * - Prioritizes regions with most garbage (garbage-first)
 * - Stops when pause time goal is reached
 */
```

**Mixed Collection Example**:

```
Regions sorted by garbage amount:
┌─────────────────────────────────────────┐
│ Region 1: 90% garbage (collected first)│
│ Region 2: 80% garbage                  │
│ Region 3: 70% garbage                  │
│ Region 4: 30% garbage (skipped)       │
│ Region 5: 20% garbage (skipped)        │
└─────────────────────────────────────────┘

Mixed Collection collects top regions until pause time goal.
```

### 2.4 G1 Configuration and Tuning

#### Basic G1 Flags

```bash
# Enable G1 GC
-XX:+UseG1GC

# Set heap size
-Xms4g -Xmx4g

# Set pause time goal (default: 200ms)
-XX:MaxGCPauseMillis=200

# Set number of GC threads (default: number of CPUs)
-XX:ParallelGCThreads=8

# Set concurrent marking threads (default: ParallelGCThreads / 4)
-XX:ConcGCThreads=2
```

#### Advanced G1 Tuning

```bash
# Region size (1MB to 32MB, must be power of 2)
-XX:G1HeapRegionSize=16m

# Percentage of heap to use as minimum for young generation (default: 5%)
-XX:G1NewSizePercent=5

# Maximum percentage of heap for young generation (default: 60%)
-XX:G1MaxNewSizePercent=60

# Percentage of heap to reserve for old generation (default: 25%)
-XX:G1ReservePercent=25

# Threshold for initiating concurrent marking cycle (default: 45%)
-XX:InitiatingHeapOccupancyPercent=45

# Enable string deduplication
-XX:+UseStringDeduplication

# Enable parallel reference processing
-XX:+ParallelRefProcEnabled
```

#### G1 Tuning Example

```bash
# Production G1 Configuration for 8GB heap, low latency
java -Xms8g -Xmx8g \
     -XX:+UseG1GC \
     -XX:MaxGCPauseMillis=100 \
     -XX:G1HeapRegionSize=16m \
     -XX:G1NewSizePercent=20 \
     -XX:G1MaxNewSizePercent=40 \
     -XX:InitiatingHeapOccupancyPercent=35 \
     -XX:ConcGCThreads=4 \
     -XX:ParallelGCThreads=8 \
     -XX:+UseStringDeduplication \
     -XX:+ParallelRefProcEnabled \
     -jar application.jar
```

### 2.5 G1 GC Logs

#### Enable GC Logging

```bash
# Java 8 style
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
-Xloggc:/var/log/gc.log

# Java 9+ unified logging (recommended)
-Xlog:gc*:file=/var/log/gc.log:time,level,tags
```

#### G1 GC Log Example

```
[2024-01-15T10:30:00.123+0000][info][gc,start] GC(0) Pause Young (Normal) (G1 Evacuation Pause)
[2024-01-15T10:30:00.123+0000][info][gc,task] GC(0) Using 8 workers of 8 for evacuation
[2024-01-15T10:30:00.145+0000][info][gc,phases] GC(0)   Pre Evacuate Collection Set: 0.1ms
[2024-01-15T10:30:00.145+0000][info][gc,phases] GC(0)   Evacuate Collection Set: 20.5ms
[2024-01-15T10:30:00.145+0000][info][gc,phases] GC(0)   Post Evacuate Collection Set: 0.3ms
[2024-01-15T10:30:00.145+0000][info][gc,phases] GC(0)   Other: 0.8ms
[2024-01-15T10:30:00.145+0000][info][gc,heap] GC(0) Eden regions: 24->0(30)
[2024-01-15T10:30:00.145+0000][info][gc,heap] GC(0) Survivor regions: 0->3(3)
[2024-01-15T10:30:00.145+0000][info][gc,heap] GC(0) Old regions: 10->15
[2024-01-15T10:30:00.145+0000][info][gc,heap] GC(0) Humongous regions: 0->0
[2024-01-15T10:30:00.145+0000][info][gc,metaspace] GC(0) Metaspace: 5120K->5120K(1056768K)
[2024-01-15T10:30:00.145+0000][info][gc] GC(0) Pause Young (Normal) (G1 Evacuation Pause) 768M->256M(2G) 21.7ms
[2024-01-15T10:30:00.145+0000][info][gc,cpu] GC(0) User=0.16s Sys=0.01s Real=0.02s
```

**Log Analysis**:
- **Pause Young (Normal)**: Minor GC
- **768M->256M**: Heap before and after
- **21.7ms**: Pause time
- **Eden regions: 24->0**: Cleared 24 Eden regions
- **Survivor regions: 0->3**: Created 3 Survivor regions

#### Concurrent Marking Log

```
[2024-01-15T10:35:00.123+0000][info][gc,start] GC(1) Pause Initial Mark (G1 Evacuation Pause)
[2024-01-15T10:35:00.145+0000][info][gc] GC(1) Pause Initial Mark (G1 Evacuation Pause) 768M->256M(2G) 22.0ms
[2024-01-15T10:35:00.145+0000][info][gc,marking] GC(1) Concurrent Mark Cycle
[2024-01-15T10:35:00.200+0000][info][gc,marking] GC(1) Concurrent Clear Claimed Marks
[2024-01-15T10:35:00.250+0000][info][gc,marking] GC(1) Concurrent Scan Root Regions
[2024-01-15T10:35:00.400+0000][info][gc,marking] GC(1) Concurrent Mark (150ms)
[2024-01-15T10:35:00.420+0000][info][gc,marking] GC(1) Concurrent Mark From Roots
[2024-01-15T10:35:00.450+0000][info][gc,marking] GC(1) Concurrent Preclean
[2024-01-15T10:35:00.470+0000][info][gc,marking] GC(1) Concurrent Mark (continue)
[2024-01-15T10:35:00.500+0000][info][gc,start] GC(1) Pause Remark
[2024-01-15T10:35:00.520+0000][info][gc] GC(1) Pause Remark 512M->512M(2G) 20.0ms
[2024-01-15T10:35:00.520+0000][info][gc,marking] GC(1) Concurrent Mark (continue)
[2024-01-15T10:35:00.550+0000][info][gc,marking] GC(1) Concurrent Rebuild Remembered Sets
[2024-01-15T10:35:00.600+0000][info][gc,start] GC(1) Pause Cleanup
[2024-01-15T10:35:00.610+0000][info][gc] GC(1) Pause Cleanup 512M->512M(2G) 10.0ms
[2024-01-15T10:35:00.610+0000][info][gc,marking] GC(1) Concurrent Mark Cycle 485.0ms
```

---

## 3. Z Garbage Collector (ZGC)

### 3.1 Overview

ZGC is an ultra-low-latency GC designed for applications requiring very low pause times (< 10ms) regardless of heap size. It was introduced as an experimental feature in Java 11 and became production-ready in Java 15.

**Key Features**:
- **Sub-10ms Pause Times**: Even with multi-terabyte heaps
- **Concurrent Operations**: Marking, relocation, and reference processing
- **NUMA-Aware**: Optimized for Non-Uniform Memory Access
- **Scalable**: Handles heaps from 8MB to 16TB

### 3.2 ZGC Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                    ZGC Heap Layout                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐  │
│  │              Small Pages (2MB)                      │  │
│  │  For objects < 256KB                                │  │
│  └─────────────────────────────────────────────────────┘  │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐  │
│  │              Medium Pages (32MB)                    │  │
│  │  For objects 256KB - 4MB                             │  │
│  └─────────────────────────────────────────────────────┘  │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐  │
│  │              Large Pages (Variable)                 │  │
│  │  For objects > 4MB                                   │  │
│  └─────────────────────────────────────────────────────┘  │
│                                                             │
│  Key: Colored Pointers (4 bits for metadata)              │
│  - Marked0, Marked1: Mark bits                            │
│  - Remapped: Relocation state                             │
│  - Finalizable: Finalization state                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 3.3 ZGC Collection Phases

#### Phase 1: Marking

```java
/**
 * ZGC Concurrent Marking
 * 
 * 1. Mark Start (STW): Mark roots, typically < 1ms
 * 2. Concurrent Mark: Mark all reachable objects (concurrent)
 * 3. Mark End (STW): Finalize marking, typically < 1ms
 * 4. Concurrent Non-Strong References: Process weak/soft/phantom refs
 * 5. Concurrent Relocate Start: Begin relocation preparation
 */
```

**ZGC Marking Timeline**:

```
Time →
┌─────────────────────────────────────────────────────────────┐
│ Application Running                                          │
│                                                             │
│  [STW] Mark Start (0.5ms)                                   │
│    │                                                         │
│    ├─> Concurrent Mark (concurrent, ~50-200ms)            │
│    │   - Traverse object graph                              │
│    │   - Mark live objects                                 │
│    │   - Update colored pointers                           │
│    │                                                         │
│  [STW] Mark End (0.5ms)                                     │
│    │                                                         │
│    ├─> Concurrent Non-Strong References (concurrent)        │
│    │                                                         │
│    └─> Concurrent Relocate Start (concurrent)               │
│                                                             │
│ Application Running                                          │
└─────────────────────────────────────────────────────────────┘
```

#### Phase 2: Relocation

```java
/**
 * ZGC Concurrent Relocation
 * 
 * 1. Select relocation set (regions with most garbage)
 * 2. Concurrent Relocate: Move objects to new locations
 * 3. Update references concurrently
 * 4. Relocate Start (STW): Begin new relocation cycle
 */
```

**ZGC Relocation Process**:

```
Before Relocation:
┌─────────────────────────────────────────┐
│ Page 1: [obj1, obj2, obj3] (50% live) │
│ Page 2: [obj4, obj5] (30% live)       │
│ Page 3: [obj6, obj7, obj8] (80% live) │
└─────────────────────────────────────────┘

Relocation Set: [Page 1, Page 2] (most garbage)

After Relocation:
┌─────────────────────────────────────────┐
│ Page 1: [freed]                        │
│ Page 2: [freed]                        │
│ Page 3: [obj6, obj7, obj8] (unchanged) │
│ Page 4: [obj1, obj2] (moved from P1)   │
│ Page 5: [obj4] (moved from P2)        │
└─────────────────────────────────────────┘
```

### 3.4 ZGC Configuration

#### Basic ZGC Flags

```bash
# Enable ZGC
-XX:+UseZGC

# Set heap size
-Xms4g -Xmx4g

# Enable NUMA support (if available)
-XX:+UseNUMA

# Set number of GC threads (default: number of CPUs)
-XX:ConcGCThreads=4
```

#### Advanced ZGC Tuning

```bash
# Maximum number of concurrent GC threads (default: 12.5% of CPUs)
-XX:ConcGCThreads=4

# Enable large pages (requires OS configuration)
-XX:+UseLargePages

# Enable transparent huge pages
-XX:+UseTransparentHugePages

# Set allocation spike tolerance (default: 2.0)
-XX:ZAllocationSpikeTolerance=2.0

# Enable uncommit unused memory (default: enabled)
-XX:+UnlockExperimentalVMOptions
-XX:+UseZGCUncommit
```

#### ZGC Tuning Example

```bash
# Production ZGC Configuration for 16GB heap, ultra-low latency
java -Xms16g -Xmx16g \
     -XX:+UseZGC \
     -XX:+UseNUMA \
     -XX:ConcGCThreads=4 \
     -XX:+UseLargePages \
     -XX:+UnlockExperimentalVMOptions \
     -XX:+UseZGCUncommit \
     -jar application.jar
```

### 3.5 ZGC GC Logs

#### Enable ZGC Logging

```bash
# Java 11+ unified logging
-Xlog:gc*:file=/var/log/zgc.log:time,level,tags
```

#### ZGC GC Log Example

```
[2024-01-15T10:30:00.123+0000][info][gc,start] GC(0) G1(0) Pause Mark Start
[2024-01-15T10:30:00.123+0000][info][gc,phases] GC(0) G1(0) Pause Mark Start 0.234ms
[2024-01-15T10:30:00.200+0000][info][gc,marking] GC(0) G1(0) Concurrent Mark 76.543ms
[2024-01-15T10:30:00.201+0000][info][gc,phases] GC(0) G1(0) Pause Mark End 0.456ms
[2024-01-15T10:30:00.201+0000][info][gc,reloc] GC(0) G1(0) Concurrent Relocate Start
[2024-01-15T10:30:00.250+0000][info][gc,reloc] GC(0) G1(0) Concurrent Relocate 48.234ms
[2024-01-15T10:30:00.251+0000][info][gc,heap] GC(0) G1(0) Heap: 8192M(100%)->4096M(50%)
[2024-01-15T10:30:00.251+0000][info][gc,stats] GC(0) G1(0) Pause Mark Start: 0.234ms
[2024-01-15T10:30:00.251+0000][info][gc,stats] GC(0) G1(0) Pause Mark End: 0.456ms
[2024-01-15T10:30:00.251+0000][info][gc,stats] GC(0) G1(0) Concurrent Mark: 76.543ms
[2024-01-15T10:30:00.251+0000][info][gc,stats] GC(0) G1(0) Concurrent Relocate: 48.234ms
```

**Log Analysis**:
- **Pause Mark Start: 0.234ms**: Very short pause
- **Concurrent Mark: 76.543ms**: Concurrent marking time
- **Pause Mark End: 0.456ms**: Very short pause
- **Concurrent Relocate: 48.234ms**: Concurrent relocation time
- **Total STW Time: < 1ms**: Ultra-low latency

---

## 4. Shenandoah GC

### 4.1 Overview

Shenandoah is a low-pause-time GC that performs most work concurrently, including concurrent evacuation (moving objects). It was introduced as an experimental feature in Java 12 and became production-ready in Java 15.

**Key Features**:
- **Concurrent Evacuation**: Moves objects while application runs
- **Low Pause Times**: Typically < 10ms, independent of heap size
- **Forwarding Pointers**: Uses indirection for concurrent moves
- **Brooks Pointer**: Additional pointer for concurrent updates

### 4.2 Shenandoah Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                Shenandoah Heap Layout                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐  │
│  │              Young Generation                        │  │
│  │  - Fast allocation                                   │  │
│  │  - Frequent minor collections                       │  │
│  └─────────────────────────────────────────────────────┘  │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐  │
│  │              Old Generation                           │  │
│  │  - Concurrent marking                                │  │
│  │  - Concurrent evacuation                             │  │
│  │  - Forwarding pointers                              │  │
│  └─────────────────────────────────────────────────────┘  │
│                                                             │
│  Key Mechanism:                                            │
│  - Brooks Pointer: Points to forwarding pointer           │
│  - Forwarding Pointer: Points to new object location      │
│  - Enables concurrent evacuation                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 4.3 Shenandoah Collection Phases

#### Phase 1: Concurrent Marking

```java
/**
 * Shenandoah Concurrent Marking
 * 
 * 1. Initial Mark (STW): Mark roots, typically < 10ms
 * 2. Concurrent Root Scanning: Scan roots concurrently
 * 3. Concurrent Marking: Mark all reachable objects
 * 4. Final Mark (STW): Finalize marking, typically < 10ms
 * 5. Concurrent Cleanup: Identify garbage regions
 */
```

#### Phase 2: Concurrent Evacuation

```java
/**
 * Shenandoah Concurrent Evacuation
 * 
 * 1. Select evacuation set (regions to evacuate)
 * 2. Concurrent Evacuation: Move objects to new regions
 * 3. Update references using forwarding pointers
 * 4. Concurrent Update Refs: Update all references
 * 5. Init Update Refs (STW): Begin reference update, < 10ms
 * 6. Final Update Refs (STW): Finalize updates, < 10ms
 */
```

**Shenandoah Evacuation Process**:

```
Before Evacuation:
┌─────────────────────────────────────────┐
│ Region 1: [obj1, obj2] (live)          │
│   obj1 -> forwarding -> new location   │
│                                         │
│ Region 2: [obj3] (dead)                │
│                                         │
│ Application reads obj1:                 │
│   1. Check forwarding pointer           │
│   2. If forwarded, follow to new loc    │
│   3. Update reference                   │
└─────────────────────────────────────────┘

During Concurrent Evacuation:
┌─────────────────────────────────────────┐
│ Region 1: [obj1*, obj2]                │
│   * forwarding pointer set              │
│                                         │
│ Region 3: [obj1_new] (new location)    │
│                                         │
│ Application continues running           │
│ References updated on access            │
└─────────────────────────────────────────┘
```

### 4.4 Shenandoah Configuration

#### Basic Shenandoah Flags

```bash
# Enable Shenandoah GC
-XX:+UseShenandoahGC

# Set heap size
-Xms4g -Xmx4g

# Set number of GC threads (default: number of CPUs)
-XX:ParallelGCThreads=8

# Set concurrent GC threads (default: ParallelGCThreads / 4)
-XX:ConcGCThreads=2
```

#### Advanced Shenandoah Tuning

```bash
# Set allocation spike threshold (default: 1.0)
-XX:ShenandoahAllocationSpikeThreshold=1.0

# Enable concurrent string deduplication
-XX:+UseStringDeduplication

# Set evacuation reserve (default: 5%)
-XX:ShenandoahEvacReserve=5

# Enable uncommit unused memory
-XX:+UnlockExperimentalVMOptions
-XX:+UseShenandoahUncommit

# Set target pause time (default: 10ms)
-XX:ShenandoahGCPauseInterval=10
```

#### Shenandoah Tuning Example

```bash
# Production Shenandoah Configuration for 8GB heap
java -Xms8g -Xmx8g \
     -XX:+UseShenandoahGC \
     -XX:ParallelGCThreads=8 \
     -XX:ConcGCThreads=2 \
     -XX:ShenandoahGCPauseInterval=10 \
     -XX:+UseStringDeduplication \
     -XX:+UnlockExperimentalVMOptions \
     -XX:+UseShenandoahUncommit \
     -jar application.jar
```

### 4.5 Shenandoah GC Logs

#### Enable Shenandoah Logging

```bash
# Java 9+ unified logging
-Xlog:gc*:file=/var/log/shenandoah.log:time,level,tags
```

#### Shenandoah GC Log Example

```
[2024-01-15T10:30:00.123+0000][info][gc,start] GC(0) Pause Init Mark
[2024-01-15T10:30:00.133+0000][info][gc] GC(0) Pause Init Mark 8192M->8192M(8192M) 10.234ms
[2024-01-15T10:30:00.200+0000][info][gc,marking] GC(0) Concurrent marking 66.543ms
[2024-01-15T10:30:00.201+0000][info][gc,start] GC(0) Pause Final Mark
[2024-01-15T10:30:00.211+0000][info][gc] GC(0) Pause Final Mark 8192M->4096M(8192M) 10.456ms
[2024-01-15T10:30:00.211+0000][info][gc,start] GC(0) Concurrent evacuation
[2024-01-15T10:30:00.300+0000][info][gc,evacuation] GC(0) Concurrent evacuation 88.234ms
[2024-01-15T10:30:00.301+0000][info][gc,start] GC(0) Pause Init Update Refs
[2024-01-15T10:30:00.311+0000][info][gc] GC(0) Pause Init Update Refs 4096M->4096M(8192M) 10.123ms
[2024-01-15T10:30:00.400+0000][info][gc,refs] GC(0) Concurrent update references 88.456ms
[2024-01-15T10:30:00.401+0000][info][gc,start] GC(0) Pause Final Update Refs
[2024-01-15T10:30:00.411+0000][info][gc] GC(0) Pause Final Update Refs 4096M->4096M(8192M) 10.234ms
[2024-01-15T10:30:00.411+0000][info][gc,heap] GC(0) Heap: 8192M(100%)->4096M(50%)
```

**Log Analysis**:
- **Pause Init Mark: 10.234ms**: Initial marking pause
- **Concurrent marking: 66.543ms**: Concurrent marking time
- **Pause Final Mark: 10.456ms**: Final marking pause
- **Concurrent evacuation: 88.234ms**: Concurrent evacuation time
- **Pause Init Update Refs: 10.123ms**: Reference update initiation
- **Concurrent update references: 88.456ms**: Concurrent reference updates
- **Pause Final Update Refs: 10.234ms**: Final reference update
- **Total STW Time: ~40ms**: Low pause time

---

## 5. Comparison of GC Algorithms

### 5.1 Feature Comparison

| Feature | G1 | ZGC | Shenandoah |
|---------|----|-----|------------|
| **Pause Time** | 10-200ms | < 10ms | < 10ms |
| **Heap Size** | 6GB+ | 8MB-16TB | Any size |
| **Concurrent Marking** | Yes | Yes | Yes |
| **Concurrent Evacuation** | No | Yes | Yes |
| **NUMA Support** | Limited | Yes | Limited |
| **Java Version** | 7+ | 11+ | 12+ |
| **Production Ready** | Yes (Java 9+) | Yes (Java 15+) | Yes (Java 15+) |
| **Throughput Impact** | Low-Medium | Low | Low-Medium |

### 5.2 Use Case Recommendations

**G1 GC**:
- ✅ Large heaps (6GB+)
- ✅ Balanced pause times and throughput
- ✅ General-purpose applications
- ✅ Java 7-10 compatibility needed

**ZGC**:
- ✅ Ultra-low latency requirements (< 10ms)
- ✅ Very large heaps (multi-terabyte)
- ✅ NUMA-aware systems
- ✅ Java 11+ available

**Shenandoah**:
- ✅ Low latency requirements (< 10ms)
- ✅ Any heap size
- ✅ Concurrent evacuation needed
- ✅ Java 12+ available

### 5.3 Performance Characteristics

**Throughput Comparison** (Higher is better):
```
Parallel GC: ████████████████████ 100%
G1 GC:       ████████████████ 85%
ZGC:         ██████████████ 75%
Shenandoah:  █████████████ 70%
```

**Pause Time Comparison** (Lower is better):
```
Parallel GC: ████████████████████ 500ms+
G1 GC:       ████ 50ms
ZGC:         █ 1ms
Shenandoah:  ██ 5ms
```

---

## Summary

**G1 GC**:
- Region-based, incremental compaction
- Predictable pause times (10-200ms)
- Best for balanced workloads

**ZGC**:
- Ultra-low latency (< 10ms)
- Concurrent marking and relocation
- Best for large heaps with strict latency requirements

**Shenandoah**:
- Low latency (< 10ms)
- Concurrent evacuation
- Best for applications requiring concurrent object movement

Each GC algorithm has its strengths and should be chosen based on application requirements, heap size, and latency constraints.

