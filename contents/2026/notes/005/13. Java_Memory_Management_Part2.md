# Java Memory Management: Garbage Collection - Part 2

## Overview

Garbage Collection (GC) is Java's automatic memory management system that reclaims memory from objects that are no longer in use. Understanding GC is crucial for optimizing application performance and preventing memory-related issues.

---

## 1. Garbage Collection Fundamentals

### 1.1 What is Garbage Collection?

**Garbage Collection** is the process of automatically identifying and reclaiming memory occupied by objects that are no longer reachable or referenced by the application.

**Key Concepts**:
- **Reachable Objects**: Objects that can be accessed by the application through references
- **Unreachable Objects**: Objects that cannot be accessed (garbage)
- **GC Roots**: Starting points for reachability analysis (static variables, thread stacks, etc.)

### 1.2 Why Garbage Collection?

**Benefits**:
- **Automatic Memory Management**: Developers don't need to manually free memory
- **Prevents Memory Leaks**: Automatically reclaims unused memory
- **Type Safety**: Prevents dangling pointers and memory corruption
- **Simplified Development**: Focus on business logic, not memory management

**Trade-offs**:
- **Performance Overhead**: GC pauses can affect application responsiveness
- **Unpredictable Timing**: GC runs at JVM's discretion
- **Tuning Complexity**: Requires understanding of GC algorithms and application behavior

### 1.3 Object Lifecycle

```
┌─────────────────────────────────────────────────────────────┐
│                    Object Lifecycle                          │
└─────────────────────────────────────────────────────────────┘

1. Object Creation
   │
   ▼
   Allocated in Eden Space (Young Generation)
   │
   ▼
2. Object in Use
   │
   │ Referenced by application
   │ Survives Minor GC cycles
   │
   ▼
3. Object Promotion
   │
   ├─→ Survives Minor GC → Moved to Survivor Space
   │
   └─→ Survives multiple GCs → Promoted to Old Generation
   │
   ▼
4. Object Unreachable
   │
   │ No references from application
   │ Marked as garbage
   │
   ▼
5. Garbage Collection
   │
   │ Memory reclaimed
   │ Object destroyed
   │
   ▼
   Memory available for new objects
```

### 1.4 Reachability Analysis

```java
public class ReachabilityExample {
    
    private static Object staticRef;  // GC Root
    
    public static void main(String[] args) {
        // Local variable: GC Root (stack reference)
        Object obj1 = new Object();  // Reachable
        
        // Method parameter: GC Root
        processObject(obj1);
        
        // obj1 still reachable via local variable
        System.out.println(obj1);
        
        // obj1 becomes unreachable when method returns
        // (assuming no other references)
    }
    
    public static void processObject(Object param) {
        // param is reachable (stack reference)
        Object obj2 = new Object();  // Reachable
        
        // obj2 becomes unreachable when method returns
        // param becomes unreachable when method returns
    }
    
    public void instanceMethod() {
        // Instance method: 'this' is GC Root
        Object obj3 = new Object();  // Reachable
        
        // obj3 becomes unreachable when method returns
    }
}
```

**GC Roots** (Objects that are always reachable):
1. **Static variables**: Referenced from Method Area
2. **Local variables**: Referenced from stack frames
3. **Active threads**: Thread objects and their stacks
4. **JNI references**: Native code references
5. **Synchronized objects**: Objects used in synchronization

---

## 2. Generational Garbage Collection

### 2.1 Generational Hypothesis

The **Generational Hypothesis** states:
- **Most objects die young**: Most objects become garbage shortly after creation
- **Few objects survive**: Only a small percentage of objects live long

**Implications**:
- Separate objects by age into different generations
- Collect young objects more frequently (cheap)
- Collect old objects less frequently (expensive but rare)

### 2.2 Heap Generations

```
┌─────────────────────────────────────────────────────────────┐
│                    Heap Generations                          │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│              Young Generation                                │
│  ┌──────────────┐  ┌──────────┐  ┌──────────┐              │
│  │    Eden      │  │Survivor 0│  │Survivor 1│              │
│  │              │  │          │  │          │              │
│  │ New objects  │  │Promoted  │  │Promoted  │              │
│  │ allocated    │  │objects   │  │objects   │              │
│  │              │  │          │  │          │              │
│  │ 80% of Young │  │ 10% each │  │ 10% each │              │
│  └──────────────┘  └──────────┘  └──────────┘              │
│                                                               │
│  Minor GC: Collects Young Generation                         │
│  - Fast (small area)                                          │
│  - Frequent (many objects die young)                          │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│              Old Generation (Tenured)                        │
│                                                               │
│  Long-lived objects                                           │
│  Objects that survived multiple Minor GCs                     │
│                                                               │
│  Major GC / Full GC: Collects Old Generation                 │
│  - Slow (large area)                                          │
│  - Infrequent (few objects promoted)                         │
└─────────────────────────────────────────────────────────────┘
```

### 2.3 Object Promotion Process

```java
public class ObjectPromotionExample {
    
    public static void main(String[] args) {
        // Object 1: Short-lived (dies in first Minor GC)
        String temp = "Temporary";
        processTemp(temp);
        // temp becomes unreachable → Collected in next Minor GC
        
        // Object 2: Medium-lived (survives some Minor GCs)
        List<String> cache = new ArrayList<>();
        for (int i = 0; i < 100; i++) {
            cache.add("Item" + i);
        }
        // cache survives several Minor GCs → Moves to Survivor space
        
        // Object 3: Long-lived (promoted to Old Generation)
        static List<String> permanentCache = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            permanentCache.add("Permanent" + i);
        }
        // permanentCache survives many Minor GCs → Promoted to Old Generation
        
        // Object 4: Large object (directly allocated in Old Generation)
        byte[] largeArray = new byte[10 * 1024 * 1024];  // 10MB
        // Large objects (> threshold) allocated directly in Old Generation
    }
    
    public static void processTemp(String str) {
        // Process and discard
    }
    
    private static List<String> static;
}
```

**Promotion Process**:

```
1. Object created in Eden
   │
   ▼
2. Minor GC occurs
   │
   ├─→ Object unreachable → Collected (memory freed)
   │
   └─→ Object reachable → Moved to Survivor 0
   │
   ▼
3. Another Minor GC occurs
   │
   ├─→ Object unreachable → Collected
   │
   └─→ Object reachable → Moved to Survivor 1 (age++)
   │
   ▼
4. Multiple Minor GCs
   │
   ├─→ Object age < threshold → Stays in Survivor space
   │
   └─→ Object age >= threshold → Promoted to Old Generation
   │
   ▼
5. Major GC occurs
   │
   └─→ Object unreachable → Collected from Old Generation
```

---

## 3. Garbage Collection Algorithms

### 3.1 Mark-Sweep Algorithm

**Process**:
1. **Mark Phase**: Mark all reachable objects
2. **Sweep Phase**: Sweep through memory and free unmarked objects

```java
// Conceptual representation
public class MarkSweepGC {
    
    // Mark Phase: Mark all reachable objects
    public void mark(Object root) {
        if (root == null || root.isMarked()) {
            return;
        }
        
        root.mark();  // Mark as reachable
        
        // Recursively mark all referenced objects
        for (Object ref : root.getReferences()) {
            mark(ref);
        }
    }
    
    // Sweep Phase: Free unmarked objects
    public void sweep(Heap heap) {
        for (Object obj : heap.getAllObjects()) {
            if (!obj.isMarked()) {
                heap.free(obj);  // Free unreachable objects
            } else {
                obj.unmark();  // Reset mark for next GC
            }
        }
    }
}
```

**Pros**:
- Simple to implement
- No object movement (no copying overhead)

**Cons**:
- Memory fragmentation
- Requires stop-the-world pause
- Inefficient for large heaps

### 3.2 Mark-Compact Algorithm

**Process**:
1. **Mark Phase**: Mark all reachable objects
2. **Compact Phase**: Move marked objects to one end, freeing contiguous space

```java
// Conceptual representation
public class MarkCompactGC {
    
    public void markCompact(Heap heap) {
        // Phase 1: Mark
        markReachableObjects(heap);
        
        // Phase 2: Calculate new positions
        int newPosition = 0;
        for (Object obj : heap.getAllObjects()) {
            if (obj.isMarked()) {
                obj.setNewPosition(newPosition);
                newPosition += obj.getSize();
            }
        }
        
        // Phase 3: Update references
        updateReferences(heap);
        
        // Phase 4: Move objects
        moveObjects(heap);
        
        // Phase 5: Free remaining space
        heap.freeFrom(newPosition);
    }
}
```

**Pros**:
- Eliminates fragmentation
- Contiguous free space
- Better for allocation

**Cons**:
- More expensive (object movement)
- Longer pause times
- Requires updating all references

### 3.3 Copying Algorithm

**Process**:
1. Divide heap into two equal spaces: **From Space** and **To Space**
2. Allocate objects in From Space
3. During GC: Copy live objects from From Space to To Space
4. Swap From and To Space

```java
// Conceptual representation
public class CopyingGC {
    
    private Space fromSpace;
    private Space toSpace;
    
    public void collect() {
        // Copy all reachable objects from From Space to To Space
        for (Object root : getGCRoots()) {
            copyObject(root);
        }
        
        // Swap spaces
        Space temp = fromSpace;
        fromSpace = toSpace;
        toSpace = temp;
        
        // From Space is now empty and ready for new allocations
    }
    
    private Object copyObject(Object obj) {
        if (obj == null || obj.isCopied()) {
            return obj.getForwardingAddress();
        }
        
        // Copy object to To Space
        Object copy = toSpace.allocate(obj.getSize());
        copy.copyFrom(obj);
        obj.setForwardingAddress(copy);
        obj.markAsCopied();
        
        // Copy referenced objects
        for (Object ref : obj.getReferences()) {
            copy.addReference(copyObject(ref));
        }
        
        return copy;
    }
}
```

**Pros**:
- Fast allocation (sequential)
- No fragmentation
- Simple implementation

**Cons**:
- Uses only 50% of heap (other 50% reserved)
- Requires object copying
- Not suitable for large objects

### 3.4 Generational GC Algorithm

**Combines multiple algorithms**:
- **Young Generation**: Copying algorithm (fast, frequent)
- **Old Generation**: Mark-Sweep-Compact (slower, less frequent)

```
┌─────────────────────────────────────────────────────────────┐
│              Generational GC Strategy                       │
└─────────────────────────────────────────────────────────────┘

Young Generation (Eden + Survivor):
├─→ Minor GC (Copying Algorithm)
│   ├─→ Copy live objects from Eden to Survivor
│   ├─→ Copy surviving objects between Survivor spaces
│   └─→ Promote aged objects to Old Generation
│
└─→ Fast, frequent, low pause time

Old Generation:
├─→ Major GC / Full GC (Mark-Sweep-Compact)
│   ├─→ Mark all reachable objects
│   ├─→ Sweep unreachable objects
│   └─→ Compact to reduce fragmentation
│
└─→ Slow, infrequent, longer pause time
```

---

## 4. GC Types and Collectors

### 4.1 Serial GC

**Characteristics**:
- Single-threaded
- Stop-the-world pauses
- Suitable for small applications

**Use Case**: Small applications, client-side applications

```bash
# Enable Serial GC
java -XX:+UseSerialGC MyApplication
```

**Process**:
```
1. Stop all application threads
2. Single GC thread performs collection
3. Resume application threads
```

### 4.2 Parallel GC

**Characteristics**:
- Multi-threaded (multiple GC threads)
- Stop-the-world pauses
- Faster than Serial GC
- Suitable for throughput-oriented applications

**Use Case**: Batch processing, server applications with throughput priority

```bash
# Enable Parallel GC
java -XX:+UseParallelGC MyApplication

# Configure number of GC threads
java -XX:+UseParallelGC -XX:ParallelGCThreads=4 MyApplication
```

**Process**:
```
1. Stop all application threads
2. Multiple GC threads perform collection in parallel
3. Resume application threads
```

### 4.3 Concurrent Mark-Sweep (CMS) GC

**Characteristics**:
- Concurrent marking and sweeping
- Shorter pause times
- More CPU usage
- Deprecated in Java 9+, removed in Java 14+

**Use Case**: Low-latency applications (legacy)

```bash
# Enable CMS GC (Java 8 and earlier)
java -XX:+UseConcMarkSweepGC MyApplication
```

**Process**:
```
1. Initial Mark (stop-the-world, short)
2. Concurrent Mark (application running)
3. Remark (stop-the-world, short)
4. Concurrent Sweep (application running)
```

### 4.4 G1 GC (Garbage First)

**Characteristics**:
- Low pause times
- Predictable GC pauses
- Divides heap into regions
- Suitable for large heaps (>4GB)

**Use Case**: Large heap applications, low-latency requirements

```bash
# Enable G1 GC
java -XX:+UseG1GC MyApplication

# Configure target pause time
java -XX:+UseG1GC -XX:MaxGCPauseMillis=200 MyApplication

# Configure heap region size
java -XX:+UseG1GC -XX:G1HeapRegionSize=16m MyApplication
```

**Process**:
```
1. Concurrent Marking (application running)
2. Remark (stop-the-world, short)
3. Evacuation (stop-the-world, targeted regions)
4. Cleanup (concurrent)
```

**G1 Heap Layout**:
```
┌─────────────────────────────────────────────────────────────┐
│                    G1 Heap (Regions)                         │
├─────────────────────────────────────────────────────────────┤
│  ┌────┐ ┌────┐ ┌────┐ ┌────┐ ┌────┐ ┌────┐ ┌────┐        │
│  │ E  │ │ E  │ │ S  │ │ S  │ │ O  │ │ O  │ │ H  │        │
│  │ d  │ │ d  │ │ u  │ │ u  │ │ l  │ │ l  │ │ u  │        │
│  │ e  │ │ e  │ │ r  │ │ r  │ │ d  │ │ d  │ │ m  │        │
│  │ n  │ │ n  │ │ v  │ │ v  │ │    │ │    │ │    │        │
│  └────┘ └────┘ └────┘ └────┘ └────┘ └────┘ └────┘        │
│                                                               │
│  E = Eden, S = Survivor, O = Old, H = Humongous             │
│  Each region: 1MB to 32MB (configurable)                    │
└─────────────────────────────────────────────────────────────┘
```

### 4.5 ZGC (Z Garbage Collector)

**Characteristics**:
- Ultra-low pause times (<10ms)
- Scalable to multi-terabyte heaps
- Concurrent collection
- Available from Java 11+ (production in Java 15+)

**Use Case**: Very large heaps, ultra-low latency requirements

```bash
# Enable ZGC
java -XX:+UseZGC MyApplication

# Configure concurrent GC threads
java -XX:+UseZGC -XX:ConcGCThreads=4 MyApplication
```

### 4.6 Shenandoah GC

**Characteristics**:
- Low pause times
- Concurrent collection
- Available from Java 12+

**Use Case**: Low-latency applications, large heaps

```bash
# Enable Shenandoah GC
java -XX:+UseShenandoahGC MyApplication
```

---

## 5. GC Events and Monitoring

### 5.1 Minor GC (Young Generation Collection)

**Triggers**:
- Eden space is full
- Allocation request cannot be satisfied

**Process**:
1. Stop application threads (stop-the-world)
2. Mark reachable objects in Eden and Survivor
3. Copy live objects to Survivor space (or promote to Old)
4. Clear Eden space
5. Resume application threads

```java
public class MinorGCExample {
    
    public static void main(String[] args) {
        // Allocate objects in Eden
        List<String> list = new ArrayList<>();
        
        // Fill Eden space to trigger Minor GC
        for (int i = 0; i < 100000; i++) {
            list.add("String" + i);  // Each string allocated in Eden
            // When Eden is full → Minor GC triggered
        }
        
        // Objects that survive Minor GC move to Survivor space
        // After multiple survivals, promoted to Old Generation
    }
}
```

### 5.2 Major GC / Full GC (Old Generation Collection)

**Triggers**:
- Old generation is full
- Explicit System.gc() call
- Heap usage exceeds threshold

**Process**:
1. Stop application threads (stop-the-world, longer pause)
2. Mark all reachable objects in entire heap
3. Sweep unreachable objects
4. Compact heap (optional, depending on collector)
5. Resume application threads

```java
public class MajorGCExample {
    
    private static List<Object> longLivedObjects = new ArrayList<>();
    
    public static void main(String[] args) {
        // Create objects that survive Minor GCs
        for (int i = 0; i < 1000; i++) {
            Object obj = new Object();
            longLivedObjects.add(obj);
            
            // After multiple Minor GCs, objects promoted to Old Generation
            // When Old Generation is full → Major GC triggered
        }
        
        // Explicit GC (not recommended in production)
        // System.gc();  // Suggests Full GC
    }
}
```

### 5.3 GC Monitoring

**Enable GC Logging**:

```bash
# Basic GC logging
java -Xlog:gc MyApplication

# Detailed GC logging
java -Xlog:gc*:file=gc.log:time,tags,level:filecount=5,filesize=10M MyApplication

# GC logging with heap information
java -Xlog:gc+heap MyApplication
```

**Programmatic Monitoring**:

```java
import java.lang.management.GarbageCollectorMXBean;
import java.lang.management.ManagementFactory;
import java.lang.management.MemoryMXBean;
import java.lang.management.MemoryUsage;

public class GCMonitoringExample {
    
    public static void main(String[] args) {
        // Get GC beans
        List<GarbageCollectorMXBean> gcBeans = 
            ManagementFactory.getGarbageCollectorMXBeans();
        
        // Monitor each GC
        for (GarbageCollectorMXBean gcBean : gcBeans) {
            System.out.println("GC Name: " + gcBean.getName());
            System.out.println("Collection Count: " + gcBean.getCollectionCount());
            System.out.println("Collection Time: " + gcBean.getCollectionTime() + " ms");
        }
        
        // Get memory usage
        MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
        MemoryUsage heapUsage = memoryBean.getHeapMemoryUsage();
        
        System.out.println("Heap Used: " + (heapUsage.getUsed() / 1024 / 1024) + " MB");
        System.out.println("Heap Max: " + (heapUsage.getMax() / 1024 / 1024) + " MB");
        System.out.println("Heap Committed: " + (heapUsage.getCommitted() / 1024 / 1024) + " MB");
    }
}
```

**GC Log Output Example**:
```
[0.123s][info][gc] Using G1
[0.456s][info][gc] GC(0) Pause Young (Normal) (G1 Evacuation Pause)
[0.456s][info][gc] GC(0) Using 4 workers of 8 for evacuation
[0.467s][info][gc] GC(0) Young regions: 24->0(13)
[0.467s][info][gc] GC(0) Survivors: 0->3(4)
[0.467s][info][gc] GC(0) Old: 0->1(27)
[0.467s][info][gc] GC(0) Pause Young (Normal) 11.234ms
[0.467s][info][gc] GC(0) Eden: 24M->0M(24M)
[0.467s][info][gc] GC(0) Survivors: 0M->3M(4M)
[0.467s][info][gc] GC(0) Old: 0M->1M(27M)
```

---

## 6. GC Tuning and Optimization

### 6.1 Heap Size Tuning

```bash
# Set initial and maximum heap size
java -Xms2g -Xmx4g MyApplication

# For 64-bit JVM, typical recommendations:
# -Xms = -Xmx (avoid heap resizing)
# -Xmx = 50-75% of available RAM
# Leave room for OS and other processes
```

**Guidelines**:
- **Too small**: Frequent GC, performance degradation
- **Too large**: Longer GC pauses, more memory usage
- **Optimal**: Balance between GC frequency and pause time

### 6.2 Young Generation Tuning

```bash
# Set Young Generation size (with Serial/Parallel GC)
java -XX:NewSize=512m -XX:MaxNewSize=512m MyApplication

# Set ratio of Young to Old Generation
java -XX:NewRatio=2 MyApplication  # Young:Old = 1:2

# Set Survivor space ratio
java -XX:SurvivorRatio=8 MyApplication  # Eden:Survivor = 8:1:1
```

**Guidelines**:
- **Larger Young Generation**: Fewer Minor GCs, but longer pauses
- **Smaller Young Generation**: More frequent Minor GCs, but shorter pauses
- **Balance**: Based on object lifetime patterns

### 6.3 G1 GC Tuning

```bash
# Enable G1 GC
java -XX:+UseG1GC MyApplication

# Set target pause time (milliseconds)
java -XX:+UseG1GC -XX:MaxGCPauseMillis=200 MyApplication

# Set heap region size
java -XX:+UseG1GC -XX:G1HeapRegionSize=16m MyApplication

# Set concurrent GC threads
java -XX:+UseG1GC -XX:ConcGCThreads=4 MyApplication
```

**G1 Tuning Parameters**:
- `MaxGCPauseMillis`: Target maximum pause time
- `G1HeapRegionSize`: Size of each heap region
- `ConcGCThreads`: Number of concurrent GC threads
- `InitiatingHeapOccupancyPercent`: When to start concurrent marking

### 6.4 GC Selection Guide

| Application Type | Recommended GC | Reason |
|-----------------|---------------|---------|
| Small client apps | Serial GC | Low overhead |
| Throughput-focused | Parallel GC | Maximum throughput |
| Low latency, large heap | G1 GC | Predictable pauses |
| Very large heap (>32GB) | ZGC / Shenandoah | Ultra-low pauses |
| Batch processing | Parallel GC | Throughput priority |

---

## 7. Memory Leaks and Prevention

### 7.1 What is a Memory Leak?

A **memory leak** occurs when objects are no longer needed by the application but remain reachable, preventing garbage collection.

**Common Causes**:
1. **Static collections** growing unbounded
2. **Listeners** not removed
3. **Thread-local variables** not cleared
4. **Caches** without eviction policies
5. **Classloader leaks**

### 7.2 Memory Leak Examples

**Example 1: Static Collection Leak**

```java
public class StaticCollectionLeak {
    
    // Static collection holds references forever
    private static List<Object> cache = new ArrayList<>();
    
    public void addToCache(Object obj) {
        cache.add(obj);  // Objects never removed → Memory leak
    }
    
    // Fix: Use bounded cache with eviction
    private static final int MAX_SIZE = 1000;
    private static List<Object> fixedCache = new ArrayList<>();
    
    public void addToCacheFixed(Object obj) {
        fixedCache.add(obj);
        if (fixedCache.size() > MAX_SIZE) {
            fixedCache.remove(0);  // Remove oldest
        }
    }
}
```

**Example 2: Listener Leak**

```java
public class ListenerLeak {
    
    private List<EventListener> listeners = new ArrayList<>();
    
    public void addListener(EventListener listener) {
        listeners.add(listener);
        // If listener not removed → Memory leak
    }
    
    // Fix: Always remove listeners
    public void removeListener(EventListener listener) {
        listeners.remove(listener);
    }
    
    // Or use WeakReference
    private List<WeakReference<EventListener>> weakListeners = new ArrayList<>();
    
    public void addWeakListener(EventListener listener) {
        weakListeners.add(new WeakReference<>(listener));
        // WeakReference allows GC even if referenced
    }
}
```

**Example 3: ThreadLocal Leak**

```java
public class ThreadLocalLeak {
    
    private static ThreadLocal<Map<String, Object>> threadLocal = new ThreadLocal<>();
    
    public void setThreadData(Map<String, Object> data) {
        threadLocal.set(data);
        // If not removed → Memory leak (especially in thread pools)
    }
    
    // Fix: Always remove ThreadLocal
    public void cleanup() {
        threadLocal.remove();  // Important for thread pools!
    }
    
    // Better: Use try-finally
    public void processWithThreadLocal() {
        try {
            Map<String, Object> data = new HashMap<>();
            threadLocal.set(data);
            // Process data
        } finally {
            threadLocal.remove();  // Always cleanup
        }
    }
}
```

### 7.3 Detecting Memory Leaks

**Heap Dump Analysis**:

```bash
# Generate heap dump
jmap -dump:format=b,file=heap.hprof <pid>

# Or use JVM option
java -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/path/to/dump.hprof MyApplication
```

**Memory Profiling Tools**:
- **jvisualvm**: Visual monitoring and profiling
- **jmap**: Heap dump generation
- **jstat**: GC statistics
- **Eclipse MAT**: Heap dump analysis
- **YourKit**: Commercial profiler

**Programmatic Detection**:

```java
public class MemoryLeakDetection {
    
    public static void monitorMemory() {
        Runtime runtime = Runtime.getRuntime();
        long usedMemory = runtime.totalMemory() - runtime.freeMemory();
        long maxMemory = runtime.maxMemory();
        
        double usagePercent = (double) usedMemory / maxMemory * 100;
        
        if (usagePercent > 80) {
            System.err.println("WARNING: High memory usage: " + usagePercent + "%");
            // Trigger heap dump or alert
        }
        
        // Monitor growth over time
        // If memory continuously grows without GC reducing it → Potential leak
    }
}
```

---

## 8. Best Practices

### 8.1 Object Creation

✅ **Do**:
- Reuse objects when possible (object pooling for expensive objects)
- Use object builders for complex objects
- Prefer primitives over wrappers when possible
- Use appropriate collection sizes

❌ **Don't**:
- Create unnecessary temporary objects in loops
- Use autoboxing in performance-critical code
- Create objects in frequently called methods unnecessarily

### 8.2 Reference Management

✅ **Do**:
- Remove listeners and callbacks when done
- Clear collections when no longer needed
- Use WeakReference for cache-like structures
- Remove ThreadLocal variables

❌ **Don't**:
- Hold references to objects longer than needed
- Store large objects in static collections
- Forget to remove event listeners

### 8.3 GC Tuning

✅ **Do**:
- Monitor GC logs regularly
- Tune based on application behavior
- Use appropriate GC for your use case
- Set reasonable heap sizes

❌ **Don't**:
- Call System.gc() explicitly (let JVM decide)
- Set heap sizes too large or too small
- Ignore GC pause times
- Use deprecated GC algorithms

---

## Summary

**Part 2** covered:

1. **Garbage Collection Fundamentals**:
   - Automatic memory reclamation
   - Reachability analysis
   - GC Roots

2. **Generational GC**:
   - Young and Old generations
   - Object promotion process
   - Generational hypothesis

3. **GC Algorithms**:
   - Mark-Sweep
   - Mark-Compact
   - Copying
   - Generational (combination)

4. **GC Collectors**:
   - Serial GC
   - Parallel GC
   - G1 GC
   - ZGC / Shenandoah

5. **GC Monitoring and Tuning**:
   - GC logging
   - Heap size tuning
   - Collector selection

6. **Memory Leaks**:
   - Common causes
   - Detection methods
   - Prevention strategies

**Key Takeaways**:
- **GC is automatic** but requires understanding for optimization
- **Choose appropriate GC** based on application requirements
- **Monitor GC performance** regularly
- **Prevent memory leaks** through proper reference management
- **Tune heap sizes** based on application behavior

Understanding memory management is essential for writing efficient Java applications and diagnosing performance issues.

