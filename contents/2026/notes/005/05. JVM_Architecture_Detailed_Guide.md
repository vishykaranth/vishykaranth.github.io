# JVM Architecture: Class Loader, Memory Model, Execution Engine - Detailed Guide

## Table of Contents

1. [JVM Overview](#jvm-overview)
2. [Class Loader Subsystem](#class-loader-subsystem)
3. [Memory Model (Runtime Data Areas)](#memory-model-runtime-data-areas)
4. [Execution Engine](#execution-engine)
5. [Native Method Interface](#native-method-interface)
6. [Complete JVM Architecture Diagram](#complete-jvm-architecture-diagram)
7. [Real-World Examples](#real-world-examples)
8. [Performance Tuning](#performance-tuning)

---

## JVM Overview

The **Java Virtual Machine (JVM)** is an abstract computing machine that enables Java programs to run on any device or operating system. It provides a runtime environment in which Java bytecode can be executed.

### Key Characteristics

- **Platform Independence**: Write once, run anywhere (WORA)
- **Memory Management**: Automatic garbage collection
- **Security**: Sandboxed execution environment
- **Performance**: Just-In-Time (JIT) compilation
- **Multi-threading**: Built-in thread support

### JVM Components

```
┌─────────────────────────────────────────────────────────────┐
│                    JVM Architecture                          │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │         Class Loader Subsystem                       │   │
│  │  - Loading, Linking, Initialization                   │   │
│  └─────────────────────────────────────────────────────┘   │
│                          │                                   │
│                          ▼                                   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │         Runtime Data Areas (Memory Model)             │   │
│  │  - Method Area, Heap, Stack, PC Registers,            │   │
│  │    Native Method Stack                                 │   │
│  └─────────────────────────────────────────────────────┘   │
│                          │                                   │
│                          ▼                                   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │         Execution Engine                              │   │
│  │  - Interpreter, JIT Compiler, Garbage Collector      │   │
│  └─────────────────────────────────────────────────────┘   │
│                          │                                   │
│                          ▼                                   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │         Native Method Interface (JNI)                 │   │
│  │  - Native Libraries, Native Method Stack            │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

---

## Class Loader Subsystem

The Class Loader Subsystem is responsible for loading, linking, and initializing Java classes. It is one of the most critical components of the JVM.

### 1. Loading

**Purpose**: Loads `.class` files into memory.

**Process**:
1. Reads the binary data from `.class` file
2. Creates a `java.lang.Class` object in the method area
3. Stores class metadata (fields, methods, constructors, etc.)

**Example**:

```java
// When you write:
MyClass obj = new MyClass();

// Class Loader performs:
// 1. Locates MyClass.class file
// 2. Reads binary data
// 3. Creates Class object in Method Area
// 4. Returns Class reference
```

**Code Example**:

```java
public class ClassLoaderExample {
    public static void main(String[] args) {
        // Class is loaded when first referenced
        MyClass obj = new MyClass();
        
        // Get the Class object
        Class<?> clazz = obj.getClass();
        
        // Get the ClassLoader that loaded this class
        ClassLoader loader = clazz.getClassLoader();
        System.out.println("ClassLoader: " + loader);
        System.out.println("Parent ClassLoader: " + loader.getParent());
    }
}

class MyClass {
    // This class will be loaded by the ClassLoader
}
```

**Output**:
```
ClassLoader: jdk.internal.loader.ClassLoaders$AppClassLoader@2f0e140b
Parent ClassLoader: jdk.internal.loader.ClassLoaders$PlatformClassLoader@1b6d3586
```

### 2. Linking

Linking consists of three phases:

#### 2.1 Verification

**Purpose**: Ensures the correctness of the `.class` file.

**Checks**:
- File format verification
- Bytecode verification
- Symbolic reference verification

**Example**:

```java
// JVM verifies:
// 1. Magic number (0xCAFEBABE)
// 2. Version compatibility
// 3. Constant pool validity
// 4. Method bytecode correctness
```

#### 2.2 Preparation

**Purpose**: Allocates memory for class variables and initializes them to default values.

**Example**:

```java
public class PreparationExample {
    // Static variables get default values during preparation
    static int count;           // Default: 0
    static boolean flag;        // Default: false
    static String name;         // Default: null
    static double price;        // Default: 0.0
    
    // Final static variables get actual values during preparation
    static final int MAX_SIZE = 100;  // Gets 100 immediately
    
    public static void main(String[] args) {
        System.out.println("count: " + count);      // 0
        System.out.println("flag: " + flag);        // false
        System.out.println("name: " + name);        // null
        System.out.println("MAX_SIZE: " + MAX_SIZE); // 100
    }
}
```

**Memory Allocation During Preparation**:

```
┌─────────────────────────────────────┐
│         Method Area                 │
├─────────────────────────────────────┤
│ PreparationExample.class            │
│   count: 0 (int default)           │
│   flag: false (boolean default)     │
│   name: null (reference default)    │
│   price: 0.0 (double default)      │
│   MAX_SIZE: 100 (final value)       │
└─────────────────────────────────────┘
```

#### 2.3 Resolution

**Purpose**: Replaces symbolic references with direct references.

**Example**:

```java
public class ResolutionExample {
    public void method() {
        // Symbolic reference: "java.lang.String"
        String str = "Hello";
        
        // Symbolic reference: "System.out"
        System.out.println(str);
        
        // After resolution, JVM replaces with direct memory addresses
    }
}
```

**Resolution Process**:

```
Before Resolution:
┌─────────────────────────────────────┐
│ Symbolic Reference:                 │
│   "java.lang.String"                │
│   "System.out"                      │
└─────────────────────────────────────┘

After Resolution:
┌─────────────────────────────────────┐
│ Direct Reference:                   │
│   Memory Address: 0x7f8a3c001234   │
│   Memory Address: 0x7f8a3c005678   │
└─────────────────────────────────────┘
```

### 3. Initialization

**Purpose**: Executes static initializers and initializes static variables.

**Example**:

```java
public class InitializationExample {
    // Static block executes during initialization
    static {
        System.out.println("Static block 1");
        count = 10;
    }
    
    static int count = 5;  // Initialized to 5
    
    static {
        System.out.println("Static block 2");
        count = 20;  // Overwrites to 20
    }
    
    public static void main(String[] args) {
        System.out.println("count: " + count);  // 20
    }
}
```

**Output**:
```
Static block 1
Static block 2
count: 20
```

**Initialization Order**:

```
1. Parent class static blocks
2. Child class static blocks
3. Parent class instance blocks
4. Parent class constructor
5. Child class instance blocks
6. Child class constructor
```

**Example**:

```java
class Parent {
    static {
        System.out.println("Parent static block");
    }
    
    {
        System.out.println("Parent instance block");
    }
    
    Parent() {
        System.out.println("Parent constructor");
    }
}

class Child extends Parent {
    static {
        System.out.println("Child static block");
    }
    
    {
        System.out.println("Child instance block");
    }
    
    Child() {
        System.out.println("Child constructor");
    }
}

public class InitializationOrder {
    public static void main(String[] args) {
        new Child();
    }
}
```

**Output**:
```
Parent static block
Child static block
Parent instance block
Parent constructor
Child instance block
Child constructor
```

### Class Loader Hierarchy

The JVM uses a **delegation model** with three built-in class loaders:

```
┌─────────────────────────────────────┐
│    Bootstrap ClassLoader             │
│    (null - implemented in native)    │
│    - Loads: rt.jar, core Java APIs │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│    Extension ClassLoader             │
│    (Platform ClassLoader in Java 9+)│
│    - Loads: ext/*.jar, platform libs│
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│    Application ClassLoader            │
│    (System/App ClassLoader)          │
│    - Loads: classpath, user classes │
└─────────────────────────────────────┘
```

**Delegation Model Example**:

```java
public class ClassLoaderHierarchy {
    public static void main(String[] args) {
        // Get Application ClassLoader
        ClassLoader appLoader = ClassLoaderHierarchy.class.getClassLoader();
        System.out.println("Application ClassLoader: " + appLoader);
        
        // Get Platform ClassLoader (parent)
        ClassLoader platformLoader = appLoader.getParent();
        System.out.println("Platform ClassLoader: " + platformLoader);
        
        // Get Bootstrap ClassLoader (parent of Platform, returns null)
        ClassLoader bootstrapLoader = platformLoader.getParent();
        System.out.println("Bootstrap ClassLoader: " + bootstrapLoader); // null
        
        // String class is loaded by Bootstrap ClassLoader
        ClassLoader stringLoader = String.class.getClassLoader();
        System.out.println("String ClassLoader: " + stringLoader); // null
    }
}
```

**Output**:
```
Application ClassLoader: jdk.internal.loader.ClassLoaders$AppClassLoader@2f0e140b
Platform ClassLoader: jdk.internal.loader.ClassLoaders$PlatformClassLoader@1b6d3586
Bootstrap ClassLoader: null
String ClassLoader: null
```

**Delegation Process**:

```java
// When loading a class:
// 1. Application ClassLoader checks if already loaded
// 2. If not, delegates to Platform ClassLoader
// 3. Platform ClassLoader delegates to Bootstrap ClassLoader
// 4. Bootstrap tries to load from rt.jar
// 5. If not found, Platform tries to load from ext/
// 6. If not found, Application loads from classpath
```

---

## Memory Model (Runtime Data Areas)

The JVM memory is divided into several runtime data areas, each serving a specific purpose.

### Complete Memory Layout

```
┌─────────────────────────────────────────────────────────────┐
│                    JVM Memory Model                          │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │         Method Area (Shared)                        │   │
│  │  - Class metadata, static variables,               │   │
│  │    method bytecode, constant pool                   │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │         Heap (Shared)                                │   │
│  │  ┌──────────────────┐  ┌──────────────────┐          │   │
│  │  │  Young Generation│  │  Old Generation  │          │   │
│  │  │  - Eden          │  │  - Tenured       │          │   │
│  │  │  - Survivor S0   │  │                  │          │   │
│  │  │  - Survivor S1   │  │                  │          │   │
│  │  └──────────────────┘  └──────────────────┘          │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │         Stack (Per Thread)                          │   │
│  │  - Local variables, method parameters,              │   │
│  │    return addresses, method calls                    │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │         PC Registers (Per Thread)                    │   │
│  │  - Current instruction pointer                       │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │         Native Method Stack (Per Thread)             │   │
│  │  - Native method calls                               │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

### 1. Method Area (PermGen / Metaspace)

**Purpose**: Stores class-level data shared across all instances.

**Contents**:
- Class metadata (name, superclass, interfaces)
- Method bytecode
- Static variables
- Constant pool
- Field and method information

**Example**:

```java
public class MethodAreaExample {
    // Static variable stored in Method Area
    static String className = "MethodAreaExample";
    
    // Final static stored in Method Area
    static final int MAX_SIZE = 100;
    
    // Method bytecode stored in Method Area
    public void method() {
        int localVar = 10;  // Stored in Stack, not Method Area
        System.out.println(localVar);
    }
    
    public static void main(String[] args) {
        // Class metadata loaded into Method Area
        MethodAreaExample obj1 = new MethodAreaExample();
        MethodAreaExample obj2 = new MethodAreaExample();
        
        // Both objects share the same class metadata from Method Area
        System.out.println(obj1.getClass() == obj2.getClass()); // true
    }
}
```

**Memory Layout**:

```
┌─────────────────────────────────────┐
│         Method Area                  │
├─────────────────────────────────────┤
│ MethodAreaExample.class              │
│   - Class metadata                   │
│   - Static variables:                │
│     className = "MethodAreaExample" │
│     MAX_SIZE = 100                   │
│   - Method bytecode:                │
│     method() { ... }                 │
│     main() { ... }                   │
│   - Constant pool                    │
└─────────────────────────────────────┘
```

**Java 8+ Changes**:

- **Java 7 and earlier**: Method Area was part of PermGen (Permanent Generation)
- **Java 8+**: Method Area is now called **Metaspace** and uses native memory

```bash
# Java 7: PermGen settings
-XX:PermSize=256m
-XX:MaxPermSize=512m

# Java 8+: Metaspace settings
-XX:MetaspaceSize=256m
-XX:MaxMetaspaceSize=512m
```

### 2. Heap Memory

**Purpose**: Stores all object instances and arrays.

**Characteristics**:
- Shared across all threads
- Managed by Garbage Collector
- Divided into Young and Old Generation

**Heap Structure**:

```
┌─────────────────────────────────────────────────────────┐
│                    Heap Memory                           │
├─────────────────────────────────────────────────────────┤
│                                                           │
│  ┌───────────────────────────────────────────────────┐ │
│  │         Young Generation                           │ │
│  │  ┌──────────────┐  ┌──────────┐  ┌──────────┐     │ │
│  │  │    Eden      │  │Survivor  │  │Survivor  │     │ │
│  │  │              │  │   S0     │  │   S1     │     │ │
│  │  │  (New objs)  │  │          │  │          │     │ │
│  │  └──────────────┘  └──────────┘  └──────────┘     │ │
│  └───────────────────────────────────────────────────┘ │
│                          │                               │
│                          ▼ (Promotion after GC)          │
│  ┌───────────────────────────────────────────────────┐ │
│  │         Old Generation (Tenured)                  │ │
│  │  - Long-lived objects                             │ │
│  │  - Survived multiple GC cycles                     │ │
│  └───────────────────────────────────────────────────┘ │
│                                                           │
└─────────────────────────────────────────────────────────┘
```

**Example**:

```java
public class HeapMemoryExample {
    public static void main(String[] args) {
        // Objects created in Heap
        String str1 = new String("Hello");  // Object in Heap
        String str2 = new String("World");  // Object in Heap
        
        // Arrays stored in Heap
        int[] numbers = new int[1000];      // Array in Heap
        
        // Custom objects in Heap
        Person person = new Person("John", 30);  // Object in Heap
        
        // References stored in Stack, objects in Heap
        System.out.println("str1: " + str1);
        System.out.println("person: " + person);
    }
}

class Person {
    String name;  // Reference in object (object in Heap)
    int age;      // Primitive in object (object in Heap)
    
    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

**Memory Layout**:

```
┌─────────────────────────────────────┐
│         Stack (Thread 1)            │
├─────────────────────────────────────┤
│ str1 → [Heap Address: 0x1000]      │
│ str2 → [Heap Address: 0x2000]       │
│ numbers → [Heap Address: 0x3000]    │
│ person → [Heap Address: 0x4000]     │
└─────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────┐
│         Heap                        │
├─────────────────────────────────────┤
│ 0x1000: String("Hello")             │
│ 0x2000: String("World")             │
│ 0x3000: int[1000]                   │
│ 0x4000: Person {                    │
│          name → 0x5000              │
│          age = 30                   │
│        }                            │
│ 0x5000: String("John")              │
└─────────────────────────────────────┘
```

**Heap Generations Explained**:

#### Young Generation

**Eden Space**: Where new objects are created

```java
public class EdenSpaceExample {
    public static void main(String[] args) {
        // New objects created in Eden Space
        for (int i = 0; i < 1000; i++) {
            String obj = new String("Object-" + i);
            // Objects accumulate in Eden Space
        }
        // When Eden is full, Minor GC occurs
    }
}
```

**Survivor Spaces (S0, S1)**: Objects that survive Minor GC

```java
public class SurvivorSpaceExample {
    public static void main(String[] args) {
        List<String> longLived = new ArrayList<>();
        
        for (int i = 0; i < 100; i++) {
            String obj = new String("LongLived-" + i);
            longLived.add(obj);  // Reference kept, survives GC
            // After Minor GC, these move to Survivor Space
        }
        // After multiple GC cycles, move to Old Generation
    }
}
```

#### Old Generation

**Tenured Space**: Long-lived objects

```java
public class OldGenerationExample {
    // Static variables stored in Method Area, but referenced objects in Heap
    static List<String> cache = new ArrayList<>();
    
    public static void main(String[] args) {
        // Objects that survive many GC cycles
        for (int i = 0; i < 10000; i++) {
            String obj = new String("Cached-" + i);
            cache.add(obj);
            // After 15+ GC cycles, promoted to Old Generation
        }
    }
}
```

**Heap Size Configuration**:

```bash
# Set initial heap size
-Xms512m

# Set maximum heap size
-Xmx2048m

# Set Young Generation size
-Xmn256m

# Set ratio between Eden and Survivor
-XX:SurvivorRatio=8  # Eden:Survivor = 8:1:1
```

### 3. Stack Memory

**Purpose**: Stores method calls, local variables, and partial results.

**Characteristics**:
- Per-thread (each thread has its own stack)
- LIFO (Last In, First Out)
- Fast access
- Limited size (default: 1MB per thread)

**Stack Frame Structure**:

```
┌─────────────────────────────────────┐
│         Stack Frame                 │
├─────────────────────────────────────┤
│ Local Variables                     │
│   - Primitive values                │
│   - Object references               │
├─────────────────────────────────────┤
│ Operand Stack                       │
│   - Intermediate calculations      │
├─────────────────────────────────────┤
│ Frame Data                          │
│   - Return address                  │
│   - Reference to constant pool      │
│   - Exception table                 │
└─────────────────────────────────────┘
```

**Example**:

```java
public class StackMemoryExample {
    public static void main(String[] args) {
        int x = 10;           // Local variable in main() stack frame
        int y = 20;           // Local variable in main() stack frame
        int result = add(x, y);  // Method call creates new stack frame
        System.out.println(result);
    }
    
    public static int add(int a, int b) {
        // New stack frame created for add()
        int sum = a + b;      // Local variable in add() stack frame
        return sum;           // Return value
        // Stack frame destroyed when method returns
    }
}
```

**Stack Frame Execution**:

```
┌─────────────────────────────────────┐
│         Stack (Thread 1)            │
├─────────────────────────────────────┤
│                                     │
│  ┌───────────────────────────────┐  │
│  │ main() Stack Frame          │  │
│  │   Local Variables:           │  │
│  │     x = 10                   │  │
│  │     y = 20                   │  │
│  │     result = ?                │  │
│  │   Operand Stack:              │  │
│  │     [empty]                   │  │
│  │   Return Address:             │  │
│  │     [line 5]                  │  │
│  └───────────────────────────────┘  │
│           │                          │
│           ▼ (Method call)            │
│  ┌───────────────────────────────┐  │
│  │ add() Stack Frame             │  │
│  │   Parameters:                 │  │
│  │     a = 10                    │  │
│  │     b = 20                    │  │
│  │   Local Variables:             │  │
│  │     sum = 30                  │  │
│  │   Operand Stack:              │  │
│  │     [30]                       │  │
│  │   Return Address:             │  │
│  │     [main: line 5]             │  │
│  └───────────────────────────────┘  │
│                                     │
└─────────────────────────────────────┘
```

**Recursive Method Example**:

```java
public class RecursiveStackExample {
    public static void main(String[] args) {
        int result = factorial(5);
        System.out.println("Factorial: " + result);
    }
    
    public static int factorial(int n) {
        if (n <= 1) {
            return 1;  // Base case
        }
        return n * factorial(n - 1);  // Recursive call
    }
}
```

**Stack Growth (factorial(5))**:

```
┌─────────────────────────────────────┐
│ Stack Frames (Growing)               │
├─────────────────────────────────────┤
│ factorial(1) → returns 1            │
│ factorial(2) → 2 * 1 = 2            │
│ factorial(3) → 3 * 2 = 6           │
│ factorial(4) → 4 * 6 = 24           │
│ factorial(5) → 5 * 24 = 120        │
│ main()                              │
└─────────────────────────────────────┘
```

**Stack Overflow Example**:

```java
public class StackOverflowExample {
    public static void main(String[] args) {
        infiniteRecursion();  // Causes StackOverflowError
    }
    
    public static void infiniteRecursion() {
        infiniteRecursion();  // No base case, infinite recursion
    }
}
```

**Stack Size Configuration**:

```bash
# Set thread stack size
-Xss1m        # 1MB per thread
-Xss256k      # 256KB per thread

# Default: 1MB (platform dependent)
```

### 4. PC Registers (Program Counter)

**Purpose**: Stores the address of the current instruction being executed.

**Characteristics**:
- Per-thread (each thread has its own PC register)
- Points to the next instruction to execute
- Changes with each instruction execution

**Example**:

```java
public class PCRegisterExample {
    public static void main(String[] args) {
        int a = 10;        // PC: instruction 1
        int b = 20;        // PC: instruction 2
        int sum = a + b;   // PC: instruction 3
        System.out.println(sum);  // PC: instruction 4
    }
}
```

**PC Register Flow**:

```
Thread 1 PC Register:
┌─────────────────────────────────────┐
│ PC: 0x1000 → int a = 10;          │
│ PC: 0x1004 → int b = 20;           │
│ PC: 0x1008 → int sum = a + b;      │
│ PC: 0x100C → System.out.println(); │
└─────────────────────────────────────┘
```

### 5. Native Method Stack

**Purpose**: Stores native method calls (C/C++ code).

**Characteristics**:
- Per-thread
- Used for JNI (Java Native Interface) calls
- Separate from Java stack

**Example**:

```java
public class NativeMethodStackExample {
    // Native method declaration
    public native void nativeMethod();
    
    static {
        // Load native library
        System.loadLibrary("nativeLib");
    }
    
    public static void main(String[] args) {
        NativeMethodStackExample obj = new NativeMethodStackExample();
        obj.nativeMethod();  // Calls native C/C++ code
    }
}
```

**Native Method Call Flow**:

```
┌─────────────────────────────────────┐
│         Java Stack                  │
│   nativeMethod() frame              │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│    Native Method Stack              │
│   C/C++ function call               │
└─────────────────────────────────────┘
```

---

## Execution Engine

The Execution Engine is responsible for executing the bytecode. It consists of three main components:

### 1. Interpreter

**Purpose**: Reads and executes bytecode line by line.

**Characteristics**:
- Simple and straightforward
- Slower execution
- No compilation overhead
- Immediate execution

**How It Works**:

```java
public class InterpreterExample {
    public static void main(String[] args) {
        int result = 0;
        for (int i = 0; i < 1000; i++) {
            result += i;  // Each line interpreted and executed
        }
        System.out.println(result);
    }
}
```

**Interpreter Execution**:

```
Bytecode:
  iconst_0        → Interpreter executes → Stack: [0]
  istore_1        → Interpreter executes → Store 0 in variable 1
  iconst_0        → Interpreter executes → Stack: [0]
  istore_2        → Interpreter executes → Store 0 in variable 2
  iload_2         → Interpreter executes → Load variable 2
  ...
```

### 2. JIT Compiler (Just-In-Time Compiler)

**Purpose**: Compiles frequently executed bytecode to native machine code for better performance.

**Characteristics**:
- Compiles hot methods (methods called frequently)
- Faster execution than interpreter
- Compilation overhead
- Adaptive optimization

**JIT Compilation Process**:

```
┌─────────────────────────────────────────────────────────┐
│              JIT Compilation Process                     │
├─────────────────────────────────────────────────────────┤
│                                                           │
│  1. Method Execution Count                              │
│     ┌─────────────────────────────────────┐             │
│     │ Interpreter counts method calls    │             │
│     │ Threshold: 10,000 (default)        │             │
│     └─────────────────────────────────────┘             │
│                    │                                     │
│                    ▼                                     │
│  2. Compilation Queue                                   │
│     ┌─────────────────────────────────────┐             │
│     │ Hot methods queued for compilation │             │
│     └─────────────────────────────────────┘             │
│                    │                                     │
│                    ▼                                     │
│  3. JIT Compilation                                     │
│     ┌─────────────────────────────────────┐             │
│     │ Bytecode → Native Machine Code     │             │
│     │ Optimizations applied              │             │
│     └─────────────────────────────────────┘             │
│                    │                                     │
│                    ▼                                     │
│  4. Native Code Execution                                │
│     ┌─────────────────────────────────────┐             │
│     │ Fast native code execution           │             │
│     └─────────────────────────────────────┘             │
│                                                           │
└─────────────────────────────────────────────────────────┘
```

**Example**:

```java
public class JITCompilerExample {
    public static void main(String[] args) {
        // This method will be compiled by JIT after many calls
        for (int i = 0; i < 100000; i++) {
            hotMethod();  // Called 100,000 times → JIT compiles it
        }
    }
    
    // Hot method - will be JIT compiled
    public static void hotMethod() {
        int sum = 0;
        for (int i = 0; i < 1000; i++) {
            sum += i;
        }
    }
}
```

**JIT Compiler Types**:

1. **C1 Compiler (Client Compiler)**:
   - Fast compilation
   - Less optimization
   - Good for startup time

2. **C2 Compiler (Server Compiler)**:
   - Slower compilation
   - Aggressive optimization
   - Better for long-running applications

**Java 8+ Tiered Compilation**:

```bash
# Enable tiered compilation (default in Java 8+)
-XX:+TieredCompilation

# Use C1 compiler only
-XX:TieredStopAtLevel=1

# Use C2 compiler only
-XX:TieredStopAtLevel=4
```

### 3. Garbage Collector

**Purpose**: Automatically manages memory by reclaiming unused objects.

**GC Process**:

```
┌─────────────────────────────────────────────────────────┐
│              Garbage Collection Process                   │
├─────────────────────────────────────────────────────────┤
│                                                           │
│  1. Mark Phase                                          │
│     ┌─────────────────────────────────────┐             │
│     │ Identify reachable objects          │             │
│     │ Mark all referenced objects         │             │
│     └─────────────────────────────────────┘             │
│                    │                                     │
│                    ▼                                     │
│  2. Sweep Phase                                          │
│     ┌─────────────────────────────────────┐             │
│     │ Remove unmarked objects             │             │
│     │ Reclaim memory                      │             │
│     └─────────────────────────────────────┘             │
│                    │                                     │
│                    ▼                                     │
│  3. Compact Phase (Optional)                             │
│     ┌─────────────────────────────────────┐             │
│     │ Defragment memory                    │             │
│     │ Move objects to reduce fragmentation│             │
│     └─────────────────────────────────────┘             │
│                                                           │
└─────────────────────────────────────────────────────────┘
```

**Example**:

```java
public class GarbageCollectionExample {
    public static void main(String[] args) {
        // Object created in Heap
        String obj1 = new String("Object 1");
        String obj2 = new String("Object 2");
        
        // obj1 reference changed, original object becomes unreachable
        obj1 = obj2;  // "Object 1" is now eligible for GC
        
        // obj2 reference set to null
        obj2 = null;  // "Object 2" still referenced by obj1
        
        // Force GC (not recommended in production)
        System.gc();
        
        // After GC, "Object 1" memory is reclaimed
    }
}
```

**GC Types**:

1. **Serial GC**: Single-threaded, good for small applications
2. **Parallel GC**: Multi-threaded, good for throughput
3. **G1 GC**: Low-latency, good for large heaps
4. **ZGC**: Ultra-low latency, good for very large heaps
5. **Shenandoah**: Low-latency, concurrent GC

**GC Configuration**:

```bash
# Serial GC
-XX:+UseSerialGC

# Parallel GC
-XX:+UseParallelGC

# G1 GC
-XX:+UseG1GC
-XX:MaxGCPauseMillis=200

# ZGC
-XX:+UseZGC

# GC Logging
-Xlog:gc*:file=gc.log
```

---

## Complete JVM Architecture Diagram

```
┌─────────────────────────────────────────────────────────────────────┐
│                         JVM Architecture                             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │              Class Loader Subsystem                           │   │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐        │   │
│  │  │   Loading    │→ │   Linking    │→ │Initialization│        │   │
│  │  │              │  │  - Verify    │  │              │        │   │
│  │  │  Read .class │  │  - Prepare   │  │ Execute static│       │   │
│  │  │  Create Class│  │  - Resolve   │  │  blocks       │        │   │
│  │  └──────────────┘  └──────────────┘  └──────────────┘        │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                          │                                            │
│                          ▼                                            │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │              Runtime Data Areas                               │   │
│  │                                                               │   │
│  │  ┌───────────────────────────────────────────────────────┐ │   │
│  │  │ Method Area (Shared)                                    │ │   │
│  │  │  - Class metadata, static vars, method bytecode       │ │   │
│  │  └───────────────────────────────────────────────────────┘ │   │
│  │                                                               │   │
│  │  ┌───────────────────────────────────────────────────────┐ │   │
│  │  │ Heap (Shared)                                           │ │   │
│  │  │  ┌──────────────┐  ┌──────────────┐                    │ │   │
│  │  │  │ Young Gen    │  │ Old Gen      │                    │ │   │
│  │  │  │ - Eden       │  │ - Tenured    │                    │ │   │
│  │  │  │ - S0, S1     │  │              │                    │ │   │
│  │  │  └──────────────┘  └──────────────┘                    │ │   │
│  │  └───────────────────────────────────────────────────────┘ │   │
│  │                                                               │   │
│  │  ┌───────────────────────────────────────────────────────┐ │   │
│  │  │ Stack (Per Thread)                                     │ │   │
│  │  │  - Method calls, local vars, operand stack             │ │   │
│  │  └───────────────────────────────────────────────────────┘ │   │
│  │                                                               │   │
│  │  ┌───────────────────────────────────────────────────────┐ │   │
│  │  │ PC Registers (Per Thread)                              │ │   │
│  │  │  - Current instruction pointer                         │ │   │
│  │  └───────────────────────────────────────────────────────┘ │   │
│  │                                                               │   │
│  │  ┌───────────────────────────────────────────────────────┐ │   │
│  │  │ Native Method Stack (Per Thread)                       │ │   │
│  │  │  - Native method calls                                 │ │   │
│  │  └───────────────────────────────────────────────────────┘ │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                          │                                            │
│                          ▼                                            │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │              Execution Engine                                 │   │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │   │
│  │  │ Interpreter  │  │ JIT Compiler │  │   Garbage    │      │   │
│  │  │              │  │              │  │  Collector   │      │   │
│  │  │ Execute      │  │ Compile hot  │  │              │      │   │
│  │  │ bytecode     │  │ methods      │  │ Reclaim      │      │   │
│  │  │ line by line │  │ to native    │  │ memory       │      │   │
│  │  └──────────────┘  └──────────────┘  └──────────────┘      │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                          │                                            │
│                          ▼                                            │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │              Native Method Interface (JNI)                   │   │
│  │  - Native Libraries                                          │   │
│  │  - C/C++ Code                                                │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

---

## Real-World Examples

### Example 1: Complete Object Lifecycle

```java
public class ObjectLifecycleExample {
    // Static variable → Method Area
    static int classCounter = 0;
    
    // Instance variables → Heap (when object created)
    private String name;
    private int age;
    
    // Constructor
    public ObjectLifecycleExample(String name, int age) {
        this.name = name;  // Reference stored in Heap object
        this.age = age;    // Primitive stored in Heap object
        classCounter++;    // Method Area variable updated
    }
    
    public static void main(String[] args) {
        // Local variable → Stack
        String localVar = "Main method";
        
        // Object creation → Heap
        ObjectLifecycleExample obj = new ObjectLifecycleExample("John", 30);
        
        // Method call → New stack frame
        obj.displayInfo();
        
        // Object becomes eligible for GC when reference is null
        obj = null;
        // GC will reclaim memory in Heap
    }
    
    // Instance method → Method Area (bytecode)
    public void displayInfo() {
        // Local variables → Stack
        String info = "Name: " + name + ", Age: " + age;
        System.out.println(info);
    }
}
```

**Memory Allocation**:

```
Method Area:
┌─────────────────────────────────────┐
│ ObjectLifecycleExample.class        │
│   - classCounter = 1                │
│   - displayInfo() bytecode          │
│   - main() bytecode                 │
└─────────────────────────────────────┘

Stack (main thread):
┌─────────────────────────────────────┐
│ main() frame:                       │
│   localVar → "Main method"          │
│   obj → [Heap Address: 0x1000]      │
└─────────────────────────────────────┘

Heap:
┌─────────────────────────────────────┐
│ 0x1000: ObjectLifecycleExample {    │
│          name → 0x2000              │
│          age = 30                   │
│        }                            │
│ 0x2000: String("John")              │
└─────────────────────────────────────┘
```

### Example 2: Memory Leak Detection

```java
import java.util.ArrayList;
import java.util.List;

public class MemoryLeakExample {
    // Static list holds references → prevents GC
    private static List<Object> cache = new ArrayList<>();
    
    public static void main(String[] args) {
        // Memory leak: objects added but never removed
        for (int i = 0; i < 1000000; i++) {
            Object obj = new Object();
            cache.add(obj);  // Object never eligible for GC
        }
        // Heap will fill up, may cause OutOfMemoryError
    }
    
    // Fix: Remove references when no longer needed
    public static void clearCache() {
        cache.clear();  // Objects now eligible for GC
    }
}
```

### Example 3: Stack vs Heap

```java
public class StackVsHeapExample {
    public static void main(String[] args) {
        // Primitive → Stack
        int primitiveValue = 42;
        
        // Object → Heap, reference → Stack
        String objectValue = new String("Hello");
        
        // Array → Heap, reference → Stack
        int[] array = new int[100];
        
        // Method call → New stack frame
        modifyValues(primitiveValue, objectValue, array);
        
        System.out.println("primitiveValue: " + primitiveValue);  // 42 (unchanged)
        System.out.println("objectValue: " + objectValue);         // "Hello" (unchanged)
        System.out.println("array[0]: " + array[0]);               // 999 (changed)
    }
    
    public static void modifyValues(int prim, String str, int[] arr) {
        // Stack frame created
        prim = 100;              // Changes local copy (Stack)
        str = "Modified";        // Changes local reference (Stack)
        arr[0] = 999;            // Modifies Heap object
    }
}
```

**Explanation**:
- Primitives: Pass by value (Stack copy)
- Object references: Pass by value (reference copied, but points to same Heap object)
- Arrays: Modified in Heap, visible to caller

---

## Performance Tuning

### 1. Heap Size Tuning

```bash
# Production recommendations
-Xms2g              # Initial heap size
-Xmx4g              # Maximum heap size
-XX:NewRatio=2      # Old:Young = 2:1
-XX:SurvivorRatio=8 # Eden:Survivor = 8:1:1
```

### 2. GC Tuning

```bash
# G1 GC for low latency
-XX:+UseG1GC
-XX:MaxGCPauseMillis=200
-XX:G1HeapRegionSize=16m

# Parallel GC for throughput
-XX:+UseParallelGC
-XX:ParallelGCThreads=4
```

### 3. JIT Tuning

```bash
# Enable JIT compilation
-XX:+TieredCompilation

# Set compilation threshold
-XX:CompileThreshold=10000

# Print compilation info
-XX:+PrintCompilation
```

### 4. Monitoring

```java
public class JVMMonitoringExample {
    public static void main(String[] args) {
        Runtime runtime = Runtime.getRuntime();
        
        // Total memory
        long totalMemory = runtime.totalMemory();
        System.out.println("Total Memory: " + totalMemory / 1024 / 1024 + " MB");
        
        // Free memory
        long freeMemory = runtime.freeMemory();
        System.out.println("Free Memory: " + freeMemory / 1024 / 1024 + " MB");
        
        // Used memory
        long usedMemory = totalMemory - freeMemory;
        System.out.println("Used Memory: " + usedMemory / 1024 / 1024 + " MB");
        
        // Max memory
        long maxMemory = runtime.maxMemory();
        System.out.println("Max Memory: " + maxMemory / 1024 / 1024 + " MB");
    }
}
```

---

## Summary

### Class Loader Subsystem
- **Loading**: Reads `.class` files and creates Class objects
- **Linking**: Verifies, prepares, and resolves classes
- **Initialization**: Executes static blocks and initializes static variables
- **Delegation Model**: Bootstrap → Platform → Application

### Memory Model
- **Method Area**: Class metadata, static variables, method bytecode
- **Heap**: Object instances, divided into Young and Old Generation
- **Stack**: Method calls, local variables, per-thread
- **PC Registers**: Current instruction pointer, per-thread
- **Native Method Stack**: Native method calls, per-thread

### Execution Engine
- **Interpreter**: Executes bytecode line by line
- **JIT Compiler**: Compiles hot methods to native code
- **Garbage Collector**: Automatically reclaims unused memory

Understanding JVM architecture is crucial for:
- Writing efficient Java code
- Debugging memory issues
- Performance tuning
- Understanding Java's "Write Once, Run Anywhere" principle

