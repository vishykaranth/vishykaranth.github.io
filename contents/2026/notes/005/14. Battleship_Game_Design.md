# Battleship Board Game - High-Level and Low-Level Design

## Table of Contents
1. [Overview](#overview)
2. [High-Level Design (HLD)](#high-level-design-hld)
3. [Low-Level Design (LLD)](#low-level-design-lld)
4. [Implementation Details](#implementation-details)

---

## Overview

### Game Description
Battleship is a two-player strategy game where players place ships on a grid and take turns guessing coordinates to sink opponent's ships. The first player to sink all opponent's ships wins.

### Requirements
- **Functional Requirements**:
  - Two-player game support
  - Ship placement (5 ships: Carrier, Battleship, Cruiser, Submarine, Destroyer)
  - Turn-based gameplay
  - Hit/miss tracking
  - Game state management
  - Win/loss detection
  - Real-time updates

- **Non-Functional Requirements**:
  - Low latency (< 100ms for moves)
  - High availability (99.9%)
  - Scalable to 10,000+ concurrent games
  - Real-time synchronization
  - Secure game state

---

## High-Level Design (HLD)

### 1. System Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                        Client Layer                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐         │
│  │ Web Client   │  │ Mobile App   │  │ Desktop App  │         │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘         │
└─────────┼──────────────────┼──────────────────┼─────────────────┘
          │                  │                  │
          └──────────────────┼──────────────────┘
                             │
          ┌──────────────────▼──────────────────┐
          │      API Gateway / Load Balancer     │
          └──────────────────┬──────────────────┘
                             │
          ┌──────────────────▼──────────────────┐
          │         Application Services         │
          ├──────────────────────────────────────┤
          │  ┌──────────────┐  ┌──────────────┐ │
          │  │ Game Service │  │ Matchmaking  │ │
          │  │              │  │   Service    │ │
          │  └──────┬───────┘  └──────┬───────┘ │
          │         │                 │          │
          │  ┌──────▼─────────────────▼───────┐ │
          │  │      WebSocket Service         │ │
          │  │  (Real-time Game Updates)      │ │
          │  └────────────────────────────────┘ │
          └──────────────┬───────────────────────┘
                         │
          ┌──────────────▼───────────────────────┐
          │         Data Layer                   │
          ├──────────────────────────────────────┤
          │  ┌──────────────┐  ┌──────────────┐ │
          │  │   Redis      │  │  PostgreSQL  │ │
          │  │  (Game State)│  │  (Persistence)│ │
          │  └──────────────┘  └──────────────┘ │
          │  ┌──────────────┐                  │
          │  │   MongoDB    │                  │
          │  │  (Game Logs) │                  │
          │  └──────────────┘                  │
          └──────────────────────────────────────┘
```

### 2. Component Breakdown

#### 2.1 Game Service
- **Responsibilities**:
  - Game creation and management
  - Ship placement validation
  - Move validation and processing
  - Win/loss detection
  - Game state management

#### 2.2 Matchmaking Service
- **Responsibilities**:
  - Player matching
  - Queue management
  - Skill-based matching (optional)

#### 2.3 WebSocket Service
- **Responsibilities**:
  - Real-time game updates
  - Bidirectional communication
  - Connection management

#### 2.4 Data Storage
- **Redis**: Active game state (fast access)
- **PostgreSQL**: Game history, player stats
- **MongoDB**: Game logs, analytics

### 3. Database Design

#### 3.1 PostgreSQL Schema

```sql
-- Users Table
CREATE TABLE users (
    user_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Games Table
CREATE TABLE games (
    game_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    player1_id UUID NOT NULL REFERENCES users(user_id),
    player2_id UUID NOT NULL REFERENCES users(user_id),
    status VARCHAR(20) NOT NULL DEFAULT 'WAITING', -- WAITING, IN_PROGRESS, FINISHED, ABANDONED
    winner_id UUID REFERENCES users(user_id),
    current_turn_user_id UUID REFERENCES users(user_id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    finished_at TIMESTAMP,
    CONSTRAINT check_different_players CHECK (player1_id != player2_id)
);

-- Game Moves Table
CREATE TABLE game_moves (
    move_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    game_id UUID NOT NULL REFERENCES games(game_id),
    player_id UUID NOT NULL REFERENCES users(user_id),
    row INT NOT NULL CHECK (row >= 0 AND row < 10),
    col INT NOT NULL CHECK (col >= 0 AND col < 10),
    result VARCHAR(10) NOT NULL, -- HIT, MISS, SUNK
    ship_type VARCHAR(20), -- CARRIER, BATTLESHIP, etc.
    move_number INT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(game_id, row, col)
);

-- Ship Placements Table
CREATE TABLE ship_placements (
    placement_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    game_id UUID NOT NULL REFERENCES games(game_id),
    player_id UUID NOT NULL REFERENCES users(user_id),
    ship_type VARCHAR(20) NOT NULL,
    start_row INT NOT NULL,
    start_col INT NOT NULL,
    end_row INT NOT NULL,
    end_col INT NOT NULL,
    orientation VARCHAR(10) NOT NULL, -- HORIZONTAL, VERTICAL
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(game_id, player_id, ship_type)
);

-- Player Statistics Table
CREATE TABLE player_stats (
    user_id UUID PRIMARY KEY REFERENCES users(user_id),
    total_games INT DEFAULT 0,
    wins INT DEFAULT 0,
    losses INT DEFAULT 0,
    draws INT DEFAULT 0,
    win_rate DECIMAL(5,2) DEFAULT 0.00,
    average_moves_per_game DECIMAL(5,2) DEFAULT 0.00,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Indexes
CREATE INDEX idx_games_status ON games(status);
CREATE INDEX idx_games_players ON games(player1_id, player2_id);
CREATE INDEX idx_moves_game ON game_moves(game_id);
CREATE INDEX idx_moves_player ON game_moves(player_id);
CREATE INDEX idx_ships_game_player ON ship_placements(game_id, player_id);
```

#### 3.2 Redis Data Structures

```redis
# Game State (Hash)
game:{game_id}:state
  - status: "IN_PROGRESS"
  - current_turn: "player1_id"
  - player1_ships_remaining: 5
  - player2_ships_remaining: 5
  - last_move_at: "2024-01-15T10:30:00Z"

# Player Boards (Hash)
game:{game_id}:player:{player_id}:board
  - grid: "JSON string of 10x10 grid"
  - ships: "JSON array of ship placements"

# Opponent View (Hash)
game:{game_id}:player:{player_id}:opponent_view
  - grid: "JSON string of 10x10 grid (hits/misses only)"

# Game Moves (List)
game:{game_id}:moves
  - [move1_json, move2_json, ...]

# Active Games Set
active_games: {game_id1, game_id2, ...}

# Player Game Mapping
player:{player_id}:active_game: {game_id}
```

### 4. API Design

#### 4.1 REST APIs

```yaml
# Game Management
POST   /api/v1/games                    # Create new game
GET    /api/v1/games/{game_id}           # Get game details
GET    /api/v1/games/{game_id}/board     # Get player's board
POST   /api/v1/games/{game_id}/ships     # Place ships
POST   /api/v1/games/{game_id}/moves     # Make a move
GET    /api/v1/games/{game_id}/moves     # Get move history
DELETE /api/v1/games/{game_id}           # Abandon game

# Matchmaking
POST   /api/v1/matchmaking/queue         # Join matchmaking queue
DELETE /api/v1/matchmaking/queue        # Leave queue
GET    /api/v1/matchmaking/status        # Get queue status

# User Management
POST   /api/v1/users/register            # Register user
POST   /api/v1/users/login               # Login
GET    /api/v1/users/{user_id}/stats     # Get player statistics
```

#### 4.2 WebSocket Events

```json
// Client → Server
{
  "type": "PLACE_SHIP",
  "gameId": "uuid",
  "shipType": "CARRIER",
  "startRow": 0,
  "startCol": 0,
  "endRow": 0,
  "endCol": 4,
  "orientation": "HORIZONTAL"
}

{
  "type": "MAKE_MOVE",
  "gameId": "uuid",
  "row": 5,
  "col": 3
}

// Server → Client
{
  "type": "GAME_STATE_UPDATE",
  "gameId": "uuid",
  "status": "IN_PROGRESS",
  "currentTurn": "player1_id",
  "player1ShipsRemaining": 3,
  "player2ShipsRemaining": 5
}

{
  "type": "MOVE_RESULT",
  "gameId": "uuid",
  "playerId": "player1_id",
  "row": 5,
  "col": 3,
  "result": "HIT",
  "shipType": "BATTLESHIP",
  "isSunk": false,
  "isYourTurn": false
}

{
  "type": "GAME_OVER",
  "gameId": "uuid",
  "winnerId": "player1_id",
  "reason": "ALL_SHIPS_SUNK"
}
```

### 5. Game Flow

```
┌─────────────────────────────────────────────────────────────┐
│                    Game Flow Diagram                        │
└─────────────────────────────────────────────────────────────┘

1. Player Registration/Login
   └──> Get authentication token

2. Join Matchmaking Queue
   └──> Wait for opponent

3. Game Created
   ├──> Player 1 places ships
   ├──> Player 2 places ships
   └──> Game status: IN_PROGRESS

4. Gameplay Loop
   ├──> Current player makes move
   ├──> Server validates move
   ├──> Update game state
   ├──> Broadcast to both players
   ├──> Check win condition
   └──> Switch turn (if not game over)

5. Game Over
   ├──> Update statistics
   ├──> Save game history
   └──> Cleanup game state
```

### 6. Scalability Considerations

#### 6.1 Horizontal Scaling
- **Stateless Services**: Game service instances can scale horizontally
- **Load Balancing**: Distribute requests across instances
- **Session Affinity**: Use sticky sessions for WebSocket connections

#### 6.2 Caching Strategy
- **Redis**: Cache active game states
- **TTL**: 1 hour for active games
- **Write-through**: Update Redis and PostgreSQL

#### 6.3 Database Optimization
- **Read Replicas**: Use for read-heavy operations
- **Connection Pooling**: Manage database connections
- **Partitioning**: Partition game_moves by game_id

#### 6.4 Message Queue
- **RabbitMQ/Kafka**: For async game event processing
- **Event Sourcing**: Store game events for replay

---

## Low-Level Design (LLD)

### 1. Class Diagram

```java
// Core Domain Models

public class Game {
    private UUID gameId;
    private UUID player1Id;
    private UUID player2Id;
    private GameStatus status;
    private UUID currentTurnPlayerId;
    private UUID winnerId;
    private LocalDateTime createdAt;
    private LocalDateTime finishedAt;
    private Map<UUID, PlayerBoard> playerBoards;
    private List<Move> moves;
    
    // Methods
    public void placeShip(UUID playerId, ShipPlacement placement);
    public MoveResult makeMove(UUID playerId, int row, int col);
    public boolean isGameOver();
    public UUID getWinner();
    public void switchTurn();
}

public class PlayerBoard {
    private UUID playerId;
    private Grid grid; // 10x10 grid
    private List<Ship> ships;
    private int shipsRemaining;
    
    // Methods
    public boolean placeShip(Ship ship, int startRow, int startCol, Orientation orientation);
    public CellState getCellState(int row, int col);
    public boolean isValidPlacement(Ship ship, int startRow, int startCol, Orientation orientation);
    public HitResult processHit(int row, int col);
    public boolean areAllShipsSunk();
}

public class Grid {
    private Cell[][] cells; // 10x10 array
    private static final int SIZE = 10;
    
    // Methods
    public Cell getCell(int row, int col);
    public void setCell(int row, int col, Cell cell);
    public boolean isValidCoordinate(int row, int col);
    public boolean isCellEmpty(int row, int col);
}

public class Cell {
    private CellState state; // EMPTY, SHIP, HIT, MISS
    private Ship ship; // null if no ship
    
    // Methods
    public boolean hasShip();
    public void setShip(Ship ship);
    public HitResult hit();
}

public class Ship {
    private ShipType type;
    private int length;
    private List<Cell> occupiedCells;
    private int hits;
    private boolean isSunk;
    
    // Methods
    public boolean isSunk();
    public void recordHit();
    public List<Cell> getOccupiedCells();
}

public enum ShipType {
    CARRIER(5),
    BATTLESHIP(4),
    CRUISER(3),
    SUBMARINE(3),
    DESTROYER(2);
    
    private final int length;
    
    ShipType(int length) {
        this.length = length;
    }
    
    public int getLength() {
        return length;
    }
}

public enum CellState {
    EMPTY,
    SHIP,
    HIT,
    MISS
}

public enum Orientation {
    HORIZONTAL,
    VERTICAL
}

public enum GameStatus {
    WAITING,
    IN_PROGRESS,
    FINISHED,
    ABANDONED
}

public class Move {
    private UUID moveId;
    private UUID gameId;
    private UUID playerId;
    private int row;
    private int col;
    private MoveResult result;
    private int moveNumber;
    private LocalDateTime timestamp;
}

public class MoveResult {
    private boolean isHit;
    private boolean isSunk;
    private ShipType shipType; // null if miss
    private String message;
}

public class ShipPlacement {
    private ShipType shipType;
    private int startRow;
    private int startCol;
    private int endRow;
    private int endCol;
    private Orientation orientation;
}
```

### 2. Service Layer

```java
// Game Service

@Service
public class GameService {
    private final GameRepository gameRepository;
    private final GameStateCache gameStateCache;
    private final WebSocketService webSocketService;
    private final GameValidator gameValidator;
    
    public Game createGame(UUID player1Id, UUID player2Id) {
        Game game = new Game(player1Id, player2Id);
        game = gameRepository.save(game);
        gameStateCache.cacheGameState(game);
        return game;
    }
    
    public void placeShip(UUID gameId, UUID playerId, ShipPlacement placement) {
        Game game = gameRepository.findById(gameId)
            .orElseThrow(() -> new GameNotFoundException(gameId));
        
        gameValidator.validateShipPlacement(game, playerId, placement);
        game.placeShip(playerId, placement);
        
        gameRepository.save(game);
        gameStateCache.updateGameState(game);
        webSocketService.broadcastGameUpdate(game);
    }
    
    public MoveResult makeMove(UUID gameId, UUID playerId, int row, int col) {
        Game game = gameRepository.findById(gameId)
            .orElseThrow(() -> new GameNotFoundException(gameId));
        
        gameValidator.validateMove(game, playerId, row, col);
        MoveResult result = game.makeMove(playerId, row, col);
        
        gameRepository.save(game);
        gameStateCache.updateGameState(game);
        webSocketService.broadcastMoveResult(game, result);
        
        if (game.isGameOver()) {
            handleGameOver(game);
        }
        
        return result;
    }
    
    private void handleGameOver(Game game) {
        game.setStatus(GameStatus.FINISHED);
        game.setWinner(game.getWinner());
        game.setFinishedAt(LocalDateTime.now());
        
        gameRepository.save(game);
        gameStateCache.removeGameState(game.getGameId());
        webSocketService.broadcastGameOver(game);
        
        // Update player statistics asynchronously
        statisticsService.updatePlayerStats(game);
    }
}

// Game Validator

@Component
public class GameValidator {
    public void validateShipPlacement(Game game, UUID playerId, ShipPlacement placement) {
        if (game.getStatus() != GameStatus.WAITING && 
            game.getStatus() != GameStatus.IN_PROGRESS) {
            throw new InvalidGameStateException("Cannot place ships in current game state");
        }
        
        PlayerBoard board = game.getPlayerBoard(playerId);
        Ship ship = new Ship(placement.getShipType());
        
        if (!board.isValidPlacement(ship, placement.getStartRow(), 
                                    placement.getStartCol(), 
                                    placement.getOrientation())) {
            throw new InvalidShipPlacementException("Invalid ship placement");
        }
        
        // Check if ship already placed
        if (board.hasShipType(placement.getShipType())) {
            throw new ShipAlreadyPlacedException("Ship already placed");
        }
    }
    
    public void validateMove(Game game, UUID playerId, int row, int col) {
        if (game.getStatus() != GameStatus.IN_PROGRESS) {
            throw new InvalidGameStateException("Game is not in progress");
        }
        
        if (!game.getCurrentTurnPlayerId().equals(playerId)) {
            throw new NotYourTurnException("It is not your turn");
        }
        
        PlayerBoard opponentBoard = game.getOpponentBoard(playerId);
        if (!opponentBoard.isValidCoordinate(row, col)) {
            throw new InvalidCoordinateException("Invalid coordinate");
        }
        
        if (opponentBoard.isCellAlreadyHit(row, col)) {
            throw new CellAlreadyHitException("Cell already hit");
        }
    }
}
```

### 3. Algorithm: Ship Placement Validation

```java
public boolean isValidPlacement(Ship ship, int startRow, int startCol, Orientation orientation) {
    int length = ship.getType().getLength();
    int endRow = startRow;
    int endCol = startCol;
    
    if (orientation == Orientation.HORIZONTAL) {
        endCol = startCol + length - 1;
    } else {
        endRow = startRow + length - 1;
    }
    
    // Check bounds
    if (!isValidCoordinate(startRow, startCol) || 
        !isValidCoordinate(endRow, endCol)) {
        return false;
    }
    
    // Check if cells are empty and no adjacent ships
    for (int row = startRow; row <= endRow; row++) {
        for (int col = startCol; col <= endCol; col++) {
            if (!isCellEmpty(row, col)) {
                return false;
            }
            // Check adjacent cells for existing ships
            if (hasAdjacentShip(row, col)) {
                return false;
            }
        }
    }
    
    return true;
}

private boolean hasAdjacentShip(int row, int col) {
    int[] dx = {-1, -1, -1, 0, 0, 1, 1, 1};
    int[] dy = {-1, 0, 1, -1, 1, -1, 0, 1};
    
    for (int i = 0; i < 8; i++) {
        int newRow = row + dx[i];
        int newCol = col + dy[i];
        
        if (isValidCoordinate(newRow, newCol)) {
            Cell cell = grid.getCell(newRow, newCol);
            if (cell.hasShip()) {
                return true;
            }
        }
    }
    
    return false;
}
```

### 4. Algorithm: Move Processing

```java
public MoveResult processHit(int row, int col) {
    Cell cell = grid.getCell(row, col);
    
    if (cell.getState() == CellState.HIT || cell.getState() == CellState.MISS) {
        throw new CellAlreadyHitException("Cell already hit");
    }
    
    if (cell.hasShip()) {
        // Hit
        cell.setState(CellState.HIT);
        Ship ship = cell.getShip();
        ship.recordHit();
        
        boolean isSunk = ship.isSunk();
        if (isSunk) {
            shipsRemaining--;
        }
        
        return MoveResult.builder()
            .isHit(true)
            .isSunk(isSunk)
            .shipType(ship.getType())
            .message(isSunk ? "You sunk my " + ship.getType() + "!" : "Hit!")
            .build();
    } else {
        // Miss
        cell.setState(CellState.MISS);
        
        return MoveResult.builder()
            .isHit(false)
            .isSunk(false)
            .shipType(null)
            .message("Miss!")
            .build();
    }
}
```

### 5. Sequence Diagrams

#### 5.1 Ship Placement Sequence

```
Player 1          Game Service        Validator        Repository        Cache
   │                    │                  │                │              │
   │──placeShip()──────>│                  │                │              │
   │                    │──validate()─────>│                │              │
   │                    │                  │──check()───────>│              │
   │                    │<──valid──────────│                │              │
   │                    │──placeShip()─────│                │              │
   │                    │                  │                │              │
   │                    │──────────────────────────────────>│              │
   │                    │<──────────────────────────────────│              │
   │                    │──────────────────────────────────────────────>│
   │                    │<──────────────────────────────────────────────│
   │<──success──────────│                  │                │              │
   │                    │──broadcast()─────│                │              │
   │                    │                  │                │              │
```

#### 5.2 Move Processing Sequence

```
Player 1          Game Service        Validator        Repository        Cache      WebSocket
   │                    │                  │                │              │            │
   │──makeMove()───────>│                  │                │              │            │
   │                    │──validate()─────>│                │              │            │
   │                    │                  │──check()───────>│              │            │
   │                    │<──valid──────────│                │              │            │
   │                    │──processHit()────│                │              │            │
   │                    │                  │                │              │            │
   │                    │──────────────────────────────────>│              │            │
   │                    │<──────────────────────────────────│              │            │
   │                    │──────────────────────────────────────────────>│            │
   │                    │<──────────────────────────────────────────────│            │
   │                    │──────────────────────────────────────────────────────────>│
   │                    │<──────────────────────────────────────────────────────────│
   │<──MoveResult───────│                  │                │              │            │
   │                    │                  │                │              │            │
   │                    │──checkGameOver()─│                │              │            │
   │                    │                  │                │              │            │
```

### 6. Data Structures

#### 6.1 Grid Representation

```java
// Option 1: 2D Array (Simple)
private Cell[][] grid = new Cell[10][10];

// Option 2: Map-based (Memory efficient for sparse grids)
private Map<String, Cell> grid = new HashMap<>();
// Key: "row:col" format

// Option 3: Bit manipulation (Ultra memory efficient)
private long[] gridBits; // Each bit represents cell state
```

#### 6.2 Ship Tracking

```java
// Option 1: List of Ships
private List<Ship> ships = new ArrayList<>();

// Option 2: Map by ShipType
private Map<ShipType, Ship> ships = new HashMap<>();

// Option 3: Set of occupied cells
private Set<Cell> shipCells = new HashSet<>();
```

### 7. State Management

```java
// Game State Machine
public enum GameState {
    WAITING {
        @Override
        public GameState transition(GameEvent event) {
            if (event == GameEvent.BOTH_PLAYERS_READY) {
                return IN_PROGRESS;
            }
            return this;
        }
    },
    IN_PROGRESS {
        @Override
        public GameState transition(GameEvent event) {
            if (event == GameEvent.ALL_SHIPS_SUNK) {
                return FINISHED;
            }
            if (event == GameEvent.PLAYER_ABANDONED) {
                return ABANDONED;
            }
            return this;
        }
    },
    FINISHED {
        @Override
        public GameState transition(GameEvent event) {
            return this; // Terminal state
        }
    },
    ABANDONED {
        @Override
        public GameState transition(GameEvent event) {
            return this; // Terminal state
        }
    };
    
    public abstract GameState transition(GameEvent event);
}
```

### 8. Error Handling

```java
// Custom Exceptions
public class GameNotFoundException extends RuntimeException {
    public GameNotFoundException(UUID gameId) {
        super("Game not found: " + gameId);
    }
}

public class InvalidShipPlacementException extends RuntimeException {
    public InvalidShipPlacementException(String message) {
        super(message);
    }
}

public class NotYourTurnException extends RuntimeException {
    public NotYourTurnException(String message) {
        super(message);
    }
}

public class CellAlreadyHitException extends RuntimeException {
    public CellAlreadyHitException(String message) {
        super(message);
    }
}
```

### 9. Caching Strategy

```java
@Service
public class GameStateCache {
    private final RedisTemplate<String, Object> redisTemplate;
    private static final String GAME_KEY_PREFIX = "game:";
    private static final Duration TTL = Duration.ofHours(1);
    
    public void cacheGameState(Game game) {
        String key = GAME_KEY_PREFIX + game.getGameId();
        redisTemplate.opsForValue().set(key, game, TTL);
    }
    
    public Optional<Game> getGameState(UUID gameId) {
        String key = GAME_KEY_PREFIX + gameId;
        Game game = (Game) redisTemplate.opsForValue().get(key);
        return Optional.ofNullable(game);
    }
    
    public void updateGameState(Game game) {
        cacheGameState(game); // Update with new TTL
    }
    
    public void removeGameState(UUID gameId) {
        String key = GAME_KEY_PREFIX + gameId;
        redisTemplate.delete(key);
    }
}
```

### 10. WebSocket Implementation

```java
@Component
public class GameWebSocketHandler extends TextWebSocketHandler {
    private final GameService gameService;
    private final Map<String, WebSocketSession> sessions = new ConcurrentHashMap<>();
    
    @Override
    public void afterConnectionEstablished(WebSocketSession session) {
        String gameId = extractGameId(session);
        sessions.put(gameId, session);
    }
    
    @Override
    protected void handleTextMessage(WebSocketSession session, TextMessage message) {
        GameMessage gameMessage = parseMessage(message.getPayload());
        
        switch (gameMessage.getType()) {
            case "PLACE_SHIP":
                handlePlaceShip(session, gameMessage);
                break;
            case "MAKE_MOVE":
                handleMakeMove(session, gameMessage);
                break;
        }
    }
    
    public void broadcastGameUpdate(Game game) {
        GameUpdateMessage message = new GameUpdateMessage(game);
        String payload = serializeMessage(message);
        
        broadcastToPlayers(game, payload);
    }
    
    private void broadcastToPlayers(Game game, String message) {
        sendToPlayer(game.getPlayer1Id(), message);
        sendToPlayer(game.getPlayer2Id(), message);
    }
}
```

---

## Implementation Details

### 1. Technology Stack

- **Backend**: Java 17, Spring Boot
- **Database**: PostgreSQL 14, Redis 7, MongoDB 6
- **Messaging**: WebSocket (Spring WebSocket), RabbitMQ
- **Caching**: Redis
- **API**: REST, WebSocket
- **Authentication**: JWT

### 2. Deployment Architecture

```
┌─────────────────────────────────────────────────────────┐
│                    Kubernetes Cluster                    │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌──────────────┐  ┌──────────────┐                   │
│  │ Game Service │  │ Matchmaking  │                   │
│  │   (3 pods)   │  │   (2 pods)   │                   │
│  └──────┬───────┘  └──────┬───────┘                   │
│         │                 │                            │
│  ┌──────▼─────────────────▼───────┐                   │
│  │      WebSocket Service         │                   │
│  │         (4 pods)               │                   │
│  └────────────────────────────────┘                   │
│                                                         │
│  ┌──────────────┐  ┌──────────────┐                   │
│  │  PostgreSQL  │  │    Redis     │                   │
│  │  (Primary +  │  │  (Cluster)   │                   │
│  │   Replicas)  │  │              │                   │
│  └──────────────┘  └──────────────┘                   │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 3. Performance Optimizations

1. **Connection Pooling**: Database and Redis connection pools
2. **Async Processing**: Async game event processing
3. **Batch Operations**: Batch database writes
4. **Compression**: Compress WebSocket messages
5. **CDN**: Static assets via CDN

### 4. Security Considerations

1. **Authentication**: JWT tokens for API access
2. **Authorization**: Verify player ownership
3. **Input Validation**: Validate all inputs
4. **Rate Limiting**: Prevent abuse
5. **HTTPS/WSS**: Encrypt all communications

---

## Summary

This design provides:

1. **Scalable Architecture**: Horizontal scaling, caching, load balancing
2. **Real-time Updates**: WebSocket for instant game updates
3. **Data Persistence**: PostgreSQL for game history, Redis for active state
4. **Clean Design**: Separation of concerns, clear interfaces
5. **Error Handling**: Comprehensive error handling and validation
6. **Performance**: Optimized for low latency and high throughput

The system can handle thousands of concurrent games with sub-100ms latency for moves and real-time synchronization between players.

