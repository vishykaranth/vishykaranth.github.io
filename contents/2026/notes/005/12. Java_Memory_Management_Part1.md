# Java Memory Management: Heap, Stack, Method Area - Part 1

## Overview

Java's memory management is one of its most important features, providing automatic memory allocation and garbage collection. Understanding how Java manages memory is crucial for writing efficient, performant applications and diagnosing memory-related issues.

---

## 1. Java Memory Model Overview

### 1.1 Memory Regions

Java Virtual Machine (JVM) divides memory into several distinct regions, each serving a specific purpose:

```
┌─────────────────────────────────────────────────────────────┐
│                    JVM Memory Layout                         │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                    Method Area (Metaspace)                    │
│  - Class metadata                                             │
│  - Static variables                                           │
│  - Method bytecode                                            │
│  - Runtime constant pool                                      │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                         Heap                                  │
│  ┌──────────────────────┐  ┌──────────────────────┐        │
│  │   Young Generation    │  │   Old Generation      │        │
│  │  ┌──────┐ ┌────────┐ │  │   (Tenured Space)    │        │
│  │  │ Eden │ │ Survivor│ │  │                      │        │
│  │  │      │ │  0 & 1  │ │  │                      │        │
│  │  └──────┘ └────────┘ │  │                      │        │
│  └──────────────────────┘  └──────────────────────┘        │
│  - Object instances                                          │
│  - Arrays                                                    │
│  - Instance variables                                        │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                    Stack (Per Thread)                        │
│  - Method frames                                             │
│  - Local variables                                           │
│  - Method parameters                                         │
│  - Return addresses                                          │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│              Program Counter Register (Per Thread)           │
│  - Current instruction pointer                                │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│              Native Method Stack (Per Thread)                │
│  - Native method calls                                       │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 Key Characteristics

| Memory Region | Thread-Shared | Lifecycle | Garbage Collected |
|---------------|---------------|------------|-------------------|
| **Heap** | Yes | Application lifetime | Yes (GC) |
| **Stack** | No (per thread) | Method execution | No (automatic) |
| **Method Area** | Yes | Application lifetime | Yes (class unloading) |
| **PC Register** | No (per thread) | Thread lifetime | No |
| **Native Stack** | No (per thread) | Thread lifetime | No |

---

## 2. Stack Memory

### 2.1 Overview

The **stack** is a thread-private memory region that stores method invocations, local variables, and method parameters. Each thread has its own stack.

**Key Characteristics**:
- **Thread-private**: Each thread has its own stack
- **LIFO (Last In, First Out)**: Method calls are pushed and popped
- **Fast access**: Stack operations are very fast
- **Limited size**: Default size is typically 1MB (configurable)
- **Automatic cleanup**: Stack frames are automatically removed when methods return

### 2.2 Stack Frame Structure

Each method invocation creates a **stack frame** containing:

```
┌─────────────────────────────────────────────────────────────┐
│                    Stack Frame                               │
├─────────────────────────────────────────────────────────────┤
│  Local Variables Array                                       │
│  - Primitive values (int, boolean, etc.)                     │
│  - Object references (pointers to heap)                     │
├─────────────────────────────────────────────────────────────┤
│  Operand Stack                                               │
│  - Intermediate computation values                           │
│  - Method call arguments                                     │
├─────────────────────────────────────────────────────────────┤
│  Frame Data                                                   │
│  - Return address                                            │
│  - Reference to constant pool                                │
│  - Exception handler table                                   │
└─────────────────────────────────────────────────────────────┘
```

### 2.3 Stack Memory Example

```java
public class StackMemoryExample {
    
    public static void main(String[] args) {
        // Stack frame for main() method
        int localVar = 10;              // Stored on stack
        String name = "John";           // Reference on stack, object on heap
        StackMemoryExample obj = new StackMemoryExample();  // Reference on stack
        
        // New stack frame created for method1()
        obj.method1(20);
        
        // Stack frame for main() resumes
        System.out.println("Back in main: " + localVar);
    }
    
    public void method1(int param) {
        // Stack frame for method1()
        // param = 20 (stored on stack)
        int local = 5;                  // Stored on stack
        String text = "Hello";          // Reference on stack, object on heap
        
        // New stack frame created for method2()
        method2(local);
        
        // Stack frame for method1() resumes
        System.out.println("Back in method1: " + local);
        // Stack frame for method1() is removed when method returns
    }
    
    public void method2(int value) {
        // Stack frame for method2()
        // value = 5 (stored on stack)
        int result = value * 2;          // Stored on stack
        
        System.out.println("In method2: " + result);
        // Stack frame for method2() is removed when method returns
    }
}
```

**Stack Memory Visualization**:

```
Thread Stack (at method2 execution):

┌─────────────────────────────────────┐
│ method2() stack frame                │ ← Top of stack
│ - value = 5                          │
│ - result = 10                        │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│ method1() stack frame               │
│ - param = 20                        │
│ - local = 5                          │
│ - text (reference) → Heap            │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│ main() stack frame                  │
│ - localVar = 10                     │
│ - name (reference) → Heap            │
│ - obj (reference) → Heap             │
└─────────────────────────────────────┘
```

### 2.4 Stack Memory for Primitives vs Objects

```java
public class StackPrimitivesVsObjects {
    
    public static void main(String[] args) {
        // Primitive types: stored directly on stack
        int number = 42;                // 4 bytes on stack
        double price = 99.99;          // 8 bytes on stack
        boolean flag = true;           // 1 byte on stack
        char letter = 'A';             // 2 bytes on stack
        
        // Object references: stored on stack, objects on heap
        String text = "Hello";         // Reference (8 bytes) on stack
                                      // String object on heap
        
        // Array references: stored on stack, array on heap
        int[] numbers = new int[1000]; // Reference (8 bytes) on stack
                                      // Array object (4000+ bytes) on heap
        
        // Method call: creates new stack frame
        processData(number, text, numbers);
    }
    
    public static void processData(int num, String str, int[] arr) {
        // Stack frame contains:
        // - num: 42 (copied value on stack)
        // - str: reference to "Hello" object on heap
        // - arr: reference to array object on heap
        
        // Local variables on stack
        int localNum = num * 2;        // 84 on stack
        String localStr = str + " World";  // Reference on stack, new object on heap
        
        // Modifying array affects heap object (shared reference)
        arr[0] = 999;                  // Modifies heap object
        
        // Modifying primitive doesn't affect caller
        num = 100;                     // Only affects local stack copy
    }
}
```

**Memory Layout**:

```
Stack:
┌─────────────────────────────────────┐
│ processData() frame                 │
│ - num = 100 (local copy)            │
│ - str → Heap (String "Hello")       │
│ - arr → Heap (int[1000])            │
│ - localNum = 84                      │
│ - localStr → Heap (String "Hello World") │
└─────────────────────────────────────┘

Heap:
┌─────────────────────────────────────┐
│ String "Hello"                       │
│ - char[] value                       │
│ - int hash                           │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│ int[1000]                           │
│ - [999, 0, 0, ...]                  │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│ String "Hello World"                │
│ - char[] value                       │
│ - int hash                           │
└─────────────────────────────────────┘
```

### 2.5 Stack Overflow

**Stack Overflow** occurs when the stack size is exceeded, typically due to:
- Deep recursion
- Infinite recursion
- Large local variables

```java
public class StackOverflowExample {
    
    // This will cause StackOverflowError
    public static void infiniteRecursion(int count) {
        System.out.println("Count: " + count);
        
        // Each call creates a new stack frame
        // Stack fills up and overflows
        infiniteRecursion(count + 1);
    }
    
    // Deep recursion example
    public static int factorial(int n) {
        if (n <= 1) {
            return 1;
        }
        // Each recursive call creates a new stack frame
        return n * factorial(n - 1);
    }
    
    public static void main(String[] args) {
        // This will work for small numbers
        System.out.println(factorial(5));  // 120
        
        // This might cause StackOverflowError for very large numbers
        // System.out.println(factorial(10000));  // Stack overflow!
        
        // Infinite recursion will definitely cause stack overflow
        // infiniteRecursion(0);  // StackOverflowError
    }
}
```

**Stack Overflow Error**:
```
Exception in thread "main" java.lang.StackOverflowError
    at StackOverflowExample.infiniteRecursion(StackOverflowExample.java:8)
    at StackOverflowExample.infiniteRecursion(StackOverflowExample.java:8)
    at StackOverflowExample.infiniteRecursion(StackOverflowExample.java:8)
    ...
```

**Preventing Stack Overflow**:
- Use iterative algorithms instead of deep recursion
- Increase stack size: `-Xss2m` (2MB stack)
- Implement tail recursion optimization (if supported)

---

## 3. Heap Memory

### 3.1 Overview

The **heap** is a shared memory region where all object instances and arrays are stored. It is the largest memory area and is managed by the garbage collector.

**Key Characteristics**:
- **Thread-shared**: All threads share the same heap
- **Dynamic allocation**: Objects allocated at runtime
- **Garbage collected**: Automatic memory management
- **Configurable size**: `-Xms` (initial), `-Xmx` (maximum)
- **Divided into generations**: Young and Old generation

### 3.2 Heap Structure

```
┌─────────────────────────────────────────────────────────────┐
│                         Heap                                 │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌─────────────────────────────────────────────────────┐    │
│  │          Young Generation (Eden + Survivor)         │    │
│  │                                                       │    │
│  │  ┌──────────────┐  ┌──────────┐  ┌──────────┐       │    │
│  │  │    Eden      │  │Survivor 0│  │Survivor 1│       │    │
│  │  │              │  │          │  │          │       │    │
│  │  │ New objects  │  │Promoted  │  │Promoted  │       │    │
│  │  │ allocated    │  │objects   │  │objects   │       │    │
│  │  │ here         │  │          │  │          │       │    │
│  │  └──────────────┘  └──────────┘  └──────────┘       │    │
│  │                                                       │    │
│  └─────────────────────────────────────────────────────┘    │
│                                                               │
│  ┌─────────────────────────────────────────────────────┐    │
│  │          Old Generation (Tenured Space)               │    │
│  │                                                       │    │
│  │  Long-lived objects                                   │    │
│  │  Objects that survived multiple GC cycles            │    │
│  │                                                       │    │
│  └─────────────────────────────────────────────────────┘    │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

### 3.3 Object Allocation on Heap

```java
public class HeapMemoryExample {
    
    public static void main(String[] args) {
        // All these objects are allocated on the heap
        
        // 1. String objects
        String str1 = "Hello";                    // Heap
        String str2 = new String("World");        // Heap
        
        // 2. Custom objects
        Person person = new Person("John", 30);  // Heap
        Person[] people = new Person[10];        // Array on heap
        
        // 3. Collections
        List<String> list = new ArrayList<>();    // ArrayList on heap
        Map<String, Integer> map = new HashMap<>(); // HashMap on heap
        
        // 4. Wrapper objects
        Integer number = new Integer(42);         // Integer object on heap
        Double price = 99.99;                     // Auto-boxed, Double on heap
        
        // Stack contains only references to heap objects
        processObjects(person, list, map);
    }
    
    public static void processObjects(Person p, List<String> l, Map<String, Integer> m) {
        // Stack frame contains references (pointers) to heap objects
        // p → Person object on heap
        // l → ArrayList object on heap
        // m → HashMap object on heap
        
        // Modifying objects affects the heap objects
        p.setAge(31);                             // Modifies heap object
        l.add("New Item");                        // Modifies heap object
        m.put("key", 100);                        // Modifies heap object
        
        // Creating new objects allocates on heap
        Person newPerson = new Person("Jane", 25); // New object on heap
    }
}

class Person {
    private String name;    // Reference on heap (points to String object)
    private int age;        // Primitive, stored directly in Person object
    
    public Person(String name, int age) {
        this.name = name;   // Reference assignment
        this.age = age;     // Value assignment
    }
    
    public void setAge(int age) {
        this.age = age;
    }
}
```

**Memory Layout**:

```
Stack:
┌─────────────────────────────────────┐
│ main() frame                       │
│ - str1 → Heap                      │
│ - str2 → Heap                      │
│ - person → Heap                    │
│ - people → Heap                    │
│ - list → Heap                      │
│ - map → Heap                       │
└─────────────────────────────────────┘

Heap:
┌─────────────────────────────────────┐
│ String "Hello"                      │
│ - char[] value                      │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│ String "World"                      │
│ - char[] value                      │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│ Person                              │
│ - name → String "John"              │
│ - age = 30                          │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│ Person[10]                          │
│ - [0] = null                        │
│ - [1] = null                        │
│ ...                                 │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│ ArrayList                           │
│ - Object[] elementData             │
│ - int size                          │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│ HashMap                             │
│ - Node[] table                      │
│ - int size                          │
└─────────────────────────────────────┘
```

### 3.4 Heap Memory Allocation Process

```java
public class HeapAllocationExample {
    
    public static void main(String[] args) {
        // Step 1: Object allocation request
        MyObject obj = new MyObject(100, "Test");
        
        // What happens:
        // 1. JVM checks if there's enough space in Eden space
        // 2. If yes, object is allocated in Eden
        // 3. If no, minor GC is triggered
        // 4. After GC, if still no space, object allocated in Old generation
        
        System.out.println("Object created: " + obj);
        
        // Step 2: Multiple object allocations
        MyObject[] objects = new MyObject[1000];
        for (int i = 0; i < 1000; i++) {
            objects[i] = new MyObject(i, "Object" + i);
            // Each allocation happens in Eden space (if space available)
        }
        
        // Step 3: Objects survive GC and get promoted
        // After several minor GCs, long-lived objects move to Survivor space
        // After more GCs, they move to Old generation
    }
}

class MyObject {
    private int id;
    private String name;
    private byte[] data;  // Large array to demonstrate memory usage
    
    public MyObject(int id, String name) {
        this.id = id;
        this.name = name;
        this.data = new byte[1024];  // 1KB array allocated on heap
    }
}
```

**Allocation Process**:

```
1. new MyObject() called
   │
   ▼
2. Check Eden space availability
   │
   ├─→ Enough space? → Allocate in Eden
   │
   └─→ Not enough? → Trigger Minor GC
       │
       ├─→ After GC, space available? → Allocate in Eden
       │
       └─→ Still not enough? → Allocate in Old Generation
```

### 3.5 Heap Memory Sizes

**Default Heap Sizes** (Java 8+):
- **Initial heap size**: 1/64 of physical memory (minimum 8MB)
- **Maximum heap size**: 1/4 of physical memory (or 1GB, whichever is smaller)

**Configuring Heap Size**:

```bash
# Set initial heap size to 256MB
java -Xms256m MyApplication

# Set maximum heap size to 2GB
java -Xmx2g MyApplication

# Set both initial and maximum to 1GB
java -Xms1g -Xmx1g MyApplication

# Example: Run application with 512MB initial, 2GB maximum
java -Xms512m -Xmx2g -jar myapp.jar
```

**Heap Size Monitoring**:

```java
public class HeapSizeExample {
    
    public static void main(String[] args) {
        // Get runtime instance
        Runtime runtime = Runtime.getRuntime();
        
        // Total memory: current heap size
        long totalMemory = runtime.totalMemory();
        System.out.println("Total Memory: " + (totalMemory / 1024 / 1024) + " MB");
        
        // Free memory: available memory in heap
        long freeMemory = runtime.freeMemory();
        System.out.println("Free Memory: " + (freeMemory / 1024 / 1024) + " MB");
        
        // Used memory: total - free
        long usedMemory = totalMemory - freeMemory;
        System.out.println("Used Memory: " + (usedMemory / 1024 / 1024) + " MB");
        
        // Maximum memory: maximum heap size
        long maxMemory = runtime.maxMemory();
        System.out.println("Max Memory: " + (maxMemory / 1024 / 1024) + " MB");
        
        // Memory usage percentage
        double usagePercent = (double) usedMemory / maxMemory * 100;
        System.out.println("Memory Usage: " + String.format("%.2f", usagePercent) + "%");
    }
}
```

**Output Example**:
```
Total Memory: 256 MB
Free Memory: 245 MB
Used Memory: 11 MB
Max Memory: 3641 MB
Memory Usage: 0.30%
```

---

## 4. Method Area (Metaspace)

### 4.1 Overview

The **Method Area** (called **Metaspace** in Java 8+) stores class metadata, static variables, method bytecode, and runtime constant pool.

**Key Characteristics**:
- **Thread-shared**: All threads share the same method area
- **Class metadata**: Information about loaded classes
- **Static variables**: Class-level variables
- **Method bytecode**: Compiled method code
- **Runtime constant pool**: String literals, constants

### 4.2 Method Area Contents

```
┌─────────────────────────────────────────────────────────────┐
│                    Method Area (Metaspace)                  │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌─────────────────────────────────────────────────────┐    │
│  │          Class Metadata                              │    │
│  │  - Class name, modifiers                             │    │
│  │  - Field information                                 │    │
│  │  - Method information                                │    │
│  │  - Superclass and interfaces                         │    │
│  │  - Constant pool                                    │    │
│  └─────────────────────────────────────────────────────┘    │
│                                                               │
│  ┌─────────────────────────────────────────────────────┐    │
│  │          Static Variables                            │    │
│  │  - Class-level variables                             │    │
│  │  - Final variables                                  │    │
│  └─────────────────────────────────────────────────────┘    │
│                                                               │
│  ┌─────────────────────────────────────────────────────┐    │
│  │          Method Bytecode                             │    │
│  │  - Compiled method instructions                     │    │
│  │  - One copy per method (shared by all instances)    │    │
│  └─────────────────────────────────────────────────────┘    │
│                                                               │
│  ┌─────────────────────────────────────────────────────┐    │
│  │          Runtime Constant Pool                      │    │
│  │  - String literals                                  │    │
│  │  - Numeric constants                                │    │
│  │  - Field and method references                     │    │
│  └─────────────────────────────────────────────────────┘    │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

### 4.3 Method Area Example

```java
public class MethodAreaExample {
    
    // Static variable: stored in Method Area
    private static int staticCounter = 0;
    
    // Final static variable: stored in Method Area
    private static final String APP_NAME = "MyApplication";
    
    // Instance variable: stored in heap (in object instance)
    private int instanceCounter = 0;
    
    // Method bytecode: stored in Method Area
    public void instanceMethod() {
        // Local variable: stored on stack
        int localVar = 10;
        staticCounter++;
        instanceCounter++;
    }
    
    // Static method bytecode: stored in Method Area
    public static void staticMethod() {
        // Local variable: stored on stack
        int localVar = 20;
        staticCounter++;
        
        // String literal: stored in Method Area (String Pool)
        String message = "Hello from static method";
        System.out.println(message);
    }
    
    public static void main(String[] args) {
        // Class metadata loaded into Method Area when first accessed
        MethodAreaExample obj1 = new MethodAreaExample();
        MethodAreaExample obj2 = new MethodAreaExample();
        
        // Both objects share the same class metadata and static variables
        obj1.instanceMethod();
        obj2.instanceMethod();
        
        // Static method called - uses Method Area bytecode
        staticMethod();
        
        // Static variable shared across all instances
        System.out.println("Static counter: " + staticCounter);  // 3
        System.out.println("Instance counter (obj1): " + obj1.instanceCounter);  // 1
        System.out.println("Instance counter (obj2): " + obj2.instanceCounter);  // 1
    }
}
```

**Memory Layout**:

```
Method Area:
┌─────────────────────────────────────┐
│ MethodAreaExample Class Metadata   │
│ - Class name                       │
│ - Fields: staticCounter, APP_NAME │
│ - Methods: instanceMethod, staticMethod │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│ Static Variables                    │
│ - staticCounter = 3                │
│ - APP_NAME = "MyApplication"       │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│ Method Bytecode                     │
│ - instanceMethod() bytecode         │
│ - staticMethod() bytecode           │
│ - main() bytecode                   │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│ String Pool (Runtime Constant Pool) │
│ - "Hello from static method"        │
│ - "MyApplication"                   │
└─────────────────────────────────────┘

Heap:
┌─────────────────────────────────────┐
│ MethodAreaExample instance (obj1)   │
│ - instanceCounter = 1              │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│ MethodAreaExample instance (obj2)    │
│ - instanceCounter = 1               │
└─────────────────────────────────────┘
```

### 4.4 String Pool (Runtime Constant Pool)

```java
public class StringPoolExample {
    
    public static void main(String[] args) {
        // String literals: stored in String Pool (Method Area)
        String str1 = "Hello";           // String Pool
        String str2 = "Hello";           // Same reference (reused)
        String str3 = new String("Hello"); // New object on heap
        
        // Comparison
        System.out.println(str1 == str2);  // true (same reference)
        System.out.println(str1 == str3);  // false (different objects)
        System.out.println(str1.equals(str3)); // true (same content)
        
        // Intern: moves string to String Pool
        String str4 = str3.intern();
        System.out.println(str1 == str4);  // true (now in String Pool)
        
        // Concatenation creates new objects
        String str5 = "Hello" + " World";  // Compile-time constant, in String Pool
        String str6 = str1 + " World";     // Runtime concatenation, new object on heap
        
        // String Pool benefits
        String[] strings = new String[1000];
        for (int i = 0; i < 1000; i++) {
            strings[i] = "Constant";  // All reference same String Pool object
        }
        // Only one "Constant" object exists in String Pool
    }
}
```

**String Pool Memory**:

```
Method Area (String Pool):
┌─────────────────────────────────────┐
│ "Hello"                             │ ← str1, str2, str4 reference this
│ "Hello World"                       │ ← str5 references this
│ "Constant"                           │ ← All 1000 array elements reference this
└─────────────────────────────────────┘

Heap:
┌─────────────────────────────────────┐
│ String "Hello"                      │ ← str3 references this (new object)
│ - char[] value → Method Area "Hello"│
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│ String "Hello World"                │ ← str6 references this (runtime concat)
│ - char[] value                      │
└─────────────────────────────────────┘
```

### 4.5 Metaspace vs PermGen (Java 8+)

**Java 7 and earlier**:
- **PermGen (Permanent Generation)**: Fixed size, part of heap
- **Issues**: OutOfMemoryError: PermGen space
- **Configuration**: `-XX:PermSize`, `-XX:MaxPermSize`

**Java 8+**:
- **Metaspace**: Native memory, not part of heap
- **Benefits**: Auto-growing, no PermGen errors
- **Configuration**: `-XX:MetaspaceSize`, `-XX:MaxMetaspaceSize`

```java
public class MetaspaceExample {
    
    // Static variables: stored in Metaspace
    private static final int MAX_SIZE = 1000;
    private static String sharedData = "Shared";
    
    public static void main(String[] args) {
        // Class metadata loaded into Metaspace
        MetaspaceExample obj = new MetaspaceExample();
        
        // Dynamic class loading also uses Metaspace
        // (Advanced: Reflection, dynamic proxies, etc.)
    }
}
```

**Configuring Metaspace**:

```bash
# Set initial Metaspace size to 256MB
java -XX:MetaspaceSize=256m MyApplication

# Set maximum Metaspace size to 512MB
java -XX:MaxMetaspaceSize=512m MyApplication

# Example
java -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=256m -jar myapp.jar
```

---

## 5. Memory Interaction Example

### 5.1 Complete Memory Flow

```java
public class CompleteMemoryExample {
    
    // Static variable: Method Area
    private static int classCounter = 0;
    
    // Instance variable: Heap (in object)
    private String name;
    private int id;
    
    public CompleteMemoryExample(String name, int id) {
        // Parameters: Stack
        // this.name reference: Stack
        // String object: Heap (or String Pool if literal)
        this.name = name;
        this.id = id;
        classCounter++;
    }
    
    public void processData(int value) {
        // Stack frame created
        // value parameter: Stack
        // Local variables: Stack
        
        int result = value * 2;  // Stack
        
        // String literal: Method Area (String Pool)
        String message = "Processing: " + result;
        
        // New object: Heap
        DataObject data = new DataObject(result, message);
        
        // Method call: New stack frame
        displayResult(data);
    }
    
    public static void displayResult(DataObject data) {
        // Static method bytecode: Method Area
        // Parameter reference: Stack
        // Object: Heap
        
        System.out.println(data.toString());
    }
    
    public static void main(String[] args) {
        // Stack frame for main()
        // args parameter: Stack (array reference)
        // args array: Heap
        
        // Object creation: Heap
        CompleteMemoryExample obj = new CompleteMemoryExample("Test", 1);
        
        // Method call: New stack frame
        obj.processData(42);
        
        // Static variable access: Method Area
        System.out.println("Class counter: " + classCounter);
    }
}

class DataObject {
    private int value;
    private String message;
    
    public DataObject(int value, String message) {
        this.value = value;
        this.message = message;
    }
    
    @Override
    public String toString() {
        return "DataObject{value=" + value + ", message='" + message + "'}";
    }
}
```

**Complete Memory Layout**:

```
Method Area:
┌─────────────────────────────────────┐
│ CompleteMemoryExample Class         │
│ - classCounter = 1                  │
│ - Method bytecode                   │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│ String Pool                         │
│ - "Processing: 84"                  │
│ - "Test"                            │
└─────────────────────────────────────┘

Heap:
┌─────────────────────────────────────┐
│ CompleteMemoryExample               │
│ - name → String "Test"              │
│ - id = 1                            │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│ DataObject                          │
│ - value = 84                        │
│ - message → String "Processing: 84" │
└─────────────────────────────────────┘

Stack (at displayResult execution):
┌─────────────────────────────────────┐
│ displayResult() frame               │
│ - data → Heap (DataObject)          │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│ processData() frame                 │
│ - value = 42                        │
│ - result = 84                       │
│ - message → Heap                    │
│ - data → Heap                       │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│ main() frame                        │
│ - args → Heap (String[])            │
│ - obj → Heap                        │
└─────────────────────────────────────┘
```

---

## Summary

**Part 1** covered:

1. **Stack Memory**:
   - Thread-private, LIFO structure
   - Stores method frames, local variables, parameters
   - Fast access, automatic cleanup
   - Can overflow with deep recursion

2. **Heap Memory**:
   - Thread-shared, largest memory region
   - Stores all object instances and arrays
   - Divided into Young and Old generations
   - Managed by garbage collector

3. **Method Area (Metaspace)**:
   - Stores class metadata, static variables, method bytecode
   - Contains String Pool for string literals
   - Shared across all threads
   - Auto-growing in Java 8+

**Key Takeaways**:
- **Stack**: Fast, automatic, limited size, thread-private
- **Heap**: Large, garbage collected, shared, object storage
- **Method Area**: Class metadata, static data, shared across instances

In **Part 2**, we'll cover **Garbage Collection** in detail, including:
- GC algorithms (Mark-Sweep, Mark-Compact, Generational)
- GC types (Minor, Major, Full GC)
- GC tuning and optimization
- Memory leaks and how to prevent them

