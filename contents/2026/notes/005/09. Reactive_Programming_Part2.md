# Reactive Programming: Part 2 - Project Reactor, Comparisons, and Advanced Topics

## Table of Contents
1. [Project Reactor Overview](#project-reactor-overview)
2. [Mono and Flux](#mono-and-flux)
3. [Reactor Operators](#reactor-operators)
4. [Reactor Error Handling](#reactor-error-handling)
5. [Reactor Schedulers](#reactor-schedulers)
6. [Spring WebFlux Integration](#spring-webflux-integration)
7. [RxJava vs Project Reactor](#rxjava-vs-project-reactor)
8. [Advanced Patterns](#advanced-patterns)
9. [Best Practices](#best-practices)
10. [Real-World Examples](#real-world-examples)

---

## Project Reactor Overview

### What is Project Reactor?

**Project Reactor** is a fully non-blocking reactive programming foundation for the JVM, with efficient demand management (backpressure). It's the reactive library used by Spring Framework 5+.

**Key Features:**
- Non-blocking and backpressure-ready
- Java 8+ functional APIs
- Reactive Streams compliant
- Spring Framework integration
- Excellent performance

### Core Principles

1. **Non-Blocking**: All operations are asynchronous
2. **Backpressure**: Built-in flow control
3. **Composable**: Chain operations fluently
4. **Functional**: Uses functional programming patterns

### Maven Dependency

```xml
<dependency>
    <groupId>io.projectreactor</groupId>
    <artifactId>reactor-core</artifactId>
    <version>3.6.0</version>
</dependency>
```

---

## Mono and Flux

### Mono<T>

**Mono** represents a stream that emits **0 or 1** item, then completes or errors.

**Use Cases:**
- HTTP requests (one response)
- Database queries (one result)
- Optional-like scenarios

#### Creating Mono

```java
// From a value
Mono<String> mono = Mono.just("Hello");

// Empty Mono
Mono<String> empty = Mono.empty();

// From Optional
Optional<String> optional = Optional.of("Hello");
Mono<String> fromOptional = Mono.justOrEmpty(optional);

// From Callable
Mono<String> fromCallable = Mono.fromCallable(() -> 
    expensiveOperation()
);

// From Future
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> "Hello");
Mono<String> fromFuture = Mono.fromFuture(future);

// Deferred (lazy)
Mono<String> deferred = Mono.defer(() -> 
    Mono.just(getCurrentTime())
);

// Error
Mono<String> error = Mono.error(new RuntimeException("Error"));
```

#### Subscribing to Mono

```java
Mono<String> mono = Mono.just("Hello");

// Full subscription
mono.subscribe(
    item -> System.out.println("Received: " + item),      // onNext
    error -> System.err.println("Error: " + error),       // onError
    () -> System.out.println("Completed")                 // onComplete
);

// Simple subscription
mono.subscribe(item -> System.out.println(item));

// Blocking (for testing only)
String value = mono.block();
```

### Flux<T>

**Flux** represents a stream that emits **0 to N** items, then completes or errors.

**Use Cases:**
- Collections of data
- Event streams
- Infinite sequences
- High-volume data

#### Creating Flux

```java
// From values
Flux<String> flux = Flux.just("A", "B", "C");

// From Iterable
List<String> list = Arrays.asList("A", "B", "C");
Flux<String> fromList = Flux.fromIterable(list);

// Range
Flux<Integer> range = Flux.range(1, 10);
// Emits: 1, 2, 3, ..., 10

// Interval (infinite)
Flux<Long> interval = Flux.interval(Duration.ofSeconds(1));
// Emits: 0, 1, 2, ... every second

// From Array
Flux<String> fromArray = Flux.fromArray(new String[]{"A", "B", "C"});

// From Stream
Flux<String> fromStream = Flux.fromStream(Stream.of("A", "B", "C"));

// Empty
Flux<String> empty = Flux.empty();

// Error
Flux<String> error = Flux.error(new RuntimeException("Error"));

// Generate (infinite)
Flux<Integer> generated = Flux.generate(
    () -> 0,  // Initial state
    (state, sink) -> {
        sink.next(state);
        if (state == 10) sink.complete();
        return state + 1;
    }
);
```

#### Subscribing to Flux

```java
Flux<String> flux = Flux.just("A", "B", "C");

// Full subscription
flux.subscribe(
    item -> System.out.println("Received: " + item),
    error -> System.err.println("Error: " + error),
    () -> System.out.println("Completed"),
    subscription -> subscription.request(Long.MAX_VALUE)  // Request all
);

// With backpressure control
flux.subscribe(
    item -> System.out.println(item),
    error -> System.err.println(error),
    () -> System.out.println("Done"),
    subscription -> {
        subscription.request(1);  // Request one at a time
        // Can request more later
    }
);
```

### Mono vs Flux Decision

```
Need 0 or 1 item?  → Mono<T>
Need 0 to N items? → Flux<T>
```

**Examples:**
```java
// Mono: Single result
Mono<User> getUser(String id);

// Flux: Multiple results
Flux<User> getAllUsers();

// Mono: Optional result
Mono<User> findUser(String id);

// Flux: Stream of events
Flux<Event> getEvents();
```

---

## Reactor Operators

### Transformation Operators

#### 1. map()

Transforms each item.

```java
Flux<String> source = Flux.just("hello", "world");
Flux<String> upper = source.map(String::toUpperCase);
// Result: "HELLO", "WORLD"

Mono<String> mono = Mono.just("hello");
Mono<String> upperMono = mono.map(String::toUpperCase);
```

#### 2. flatMap()

Transforms each item into a Publisher, then merges.

```java
Flux<String> source = Flux.just("hello", "world");
Flux<Character> chars = source.flatMap(word -> 
    Flux.fromArray(word.split(""))
        .map(s -> s.charAt(0))
);
// Result: 'h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd'
// Order may vary (concurrent)
```

#### 3. flatMapSequential()

Like flatMap, but preserves order.

```java
Flux<String> source = Flux.just("hello", "world");
Flux<Character> chars = source.flatMapSequential(word -> 
    Flux.fromArray(word.split(""))
        .map(s -> s.charAt(0))
);
// Order preserved
```

#### 4. concatMap()

Like flatMap, but waits for each inner Publisher to complete.

```java
Flux<String> source = Flux.just("hello", "world");
Flux<Character> chars = source.concatMap(word -> 
    Flux.fromArray(word.split(""))
        .map(s -> s.charAt(0))
);
// Sequential, order preserved
```

#### 5. switchMap()

Cancels previous inner Publisher when new item arrives.

```java
Flux<String> source = Flux.just("hello", "world");
Flux<Character> chars = source.switchMap(word -> 
    Flux.fromArray(word.split(""))
        .map(s -> s.charAt(0))
        .delayElements(Duration.ofMillis(100))
);
// Only emits from latest word
```

#### 6. scan()

Applies accumulator function.

```java
Flux<Integer> numbers = Flux.just(1, 2, 3, 4, 5);
Flux<Integer> sum = numbers.scan((acc, item) -> acc + item);
// Result: 1, 3, 6, 10, 15
```

### Filtering Operators

#### 1. filter()

Filters items based on predicate.

```java
Flux<Integer> numbers = Flux.range(1, 10);
Flux<Integer> evens = numbers.filter(n -> n % 2 == 0);
// Result: 2, 4, 6, 8, 10
```

#### 2. take()

Takes first n items.

```java
Flux<Integer> numbers = Flux.range(1, 10);
Flux<Integer> first5 = numbers.take(5);
// Result: 1, 2, 3, 4, 5
```

#### 3. takeWhile()

Takes items while predicate is true.

```java
Flux<Integer> numbers = Flux.range(1, 10);
Flux<Integer> lessThan5 = numbers.takeWhile(n -> n < 5);
// Result: 1, 2, 3, 4
```

#### 4. skip()

Skips first n items.

```java
Flux<Integer> numbers = Flux.range(1, 10);
Flux<Integer> after5 = numbers.skip(5);
// Result: 6, 7, 8, 9, 10
```

#### 5. distinct()

Removes duplicates.

```java
Flux<Integer> numbers = Flux.just(1, 2, 2, 3, 3, 3, 4);
Flux<Integer> unique = numbers.distinct();
// Result: 1, 2, 3, 4
```

#### 6. debounce()

Emits item after specified time without another emission.

```java
Flux<String> source = Flux.just("a", "b", "c")
    .delayElements(Duration.ofMillis(100));
Flux<String> debounced = source.debounce(Duration.ofMillis(50));
```

### Combining Operators

#### 1. merge()

Merges multiple Publishers.

```java
Flux<String> flux1 = Flux.just("A", "B");
Flux<String> flux2 = Flux.just("C", "D");
Flux<String> merged = Flux.merge(flux1, flux2);
// Result: "A", "B", "C", "D" (order may vary)
```

#### 2. concat()

Concatenates Publishers (preserves order).

```java
Flux<String> flux1 = Flux.just("A", "B");
Flux<String> flux2 = Flux.just("C", "D");
Flux<String> concatenated = Flux.concat(flux1, flux2);
// Result: "A", "B", "C", "D"
```

#### 3. zip()

Combines items from multiple Publishers.

```java
Flux<String> flux1 = Flux.just("A", "B", "C");
Flux<Integer> flux2 = Flux.just(1, 2, 3);
Flux<String> zipped = Flux.zip(flux1, flux2, 
    (str, num) -> str + num
);
// Result: "A1", "B2", "C3"
```

#### 4. combineLatest()

Combines latest items from multiple Publishers.

```java
Flux<String> flux1 = Flux.just("A", "B");
Flux<Integer> flux2 = Flux.just(1, 2);
Flux<String> combined = Flux.combineLatest(flux1, flux2,
    (str, num) -> str + num
);
// Result: "A1", "B1", "B2"
```

### Utility Operators

#### 1. doOnNext()

Side effect for each item.

```java
Flux<Integer> numbers = Flux.range(1, 5);
numbers.doOnNext(i -> System.out.println("Processing: " + i))
    .subscribe();
```

#### 2. delayElements()

Delays each emission.

```java
Flux<String> source = Flux.just("A", "B", "C");
Flux<String> delayed = source.delayElements(Duration.ofSeconds(1));
```

#### 3. timeout()

Emits error if no item within time limit.

```java
Flux<String> source = Flux.just("Hello")
    .delayElements(Duration.ofSeconds(2));
Flux<String> timed = source.timeout(Duration.ofSeconds(1));
// Will error if source doesn't emit within 1 second
```

#### 4. retry()

Retries on error.

```java
Flux<String> source = Flux.error(new RuntimeException());
Flux<String> retried = source.retry(3);
// Retries up to 3 times
```

#### 5. buffer()

Collects items into buffers.

```java
Flux<Integer> numbers = Flux.range(1, 10);
Flux<List<Integer>> buffered = numbers.buffer(3);
// Result: [1,2,3], [4,5,6], [7,8,9], [10]
```

#### 6. window()

Splits into windows (Flux of Flux).

```java
Flux<Integer> numbers = Flux.range(1, 10);
Flux<Flux<Integer>> windowed = numbers.window(3);
// Result: Flux([1,2,3]), Flux([4,5,6]), Flux([7,8,9]), Flux([10])
```

---

## Reactor Error Handling

### Error Propagation

By default, errors terminate the stream.

```java
Flux<Integer> source = Flux.just(1, 2, 3)
    .map(i -> {
        if (i == 2) throw new RuntimeException("Error");
        return i;
    });

source.subscribe(
    item -> System.out.println(item),
    error -> System.out.println("Error: " + error),
    () -> System.out.println("Complete")
);
// Output: 1, Error: RuntimeException
```

### Error Handling Operators

#### 1. onErrorReturn()

Returns a default value on error.

```java
Flux<Integer> source = Flux.just(1, 2, 3)
    .map(i -> {
        if (i == 2) throw new RuntimeException("Error");
        return i;
    })
    .onErrorReturn(-1);

source.subscribe(item -> System.out.println(item));
// Output: 1, -1
```

#### 2. onErrorResume()

Switches to another Publisher on error.

```java
Flux<Integer> source = Flux.just(1, 2, 3)
    .map(i -> {
        if (i == 2) throw new RuntimeException("Error");
        return i;
    })
    .onErrorResume(error -> Flux.just(10, 20));

source.subscribe(item -> System.out.println(item));
// Output: 1, 10, 20
```

#### 3. onErrorMap()

Transforms the error.

```java
Flux<Integer> source = Flux.just(1, 2, 3)
    .map(i -> {
        if (i == 2) throw new RuntimeException("Error");
        return i;
    })
    .onErrorMap(error -> new IllegalStateException("Mapped error", error));
```

#### 4. retry()

Retries the entire sequence.

```java
Flux<Integer> source = Flux.just(1, 2, 3)
    .map(i -> {
        if (i == 2) throw new RuntimeException("Error");
        return i;
    })
    .retry(2);

source.subscribe(
    item -> System.out.println(item),
    error -> System.out.println("Error: " + error)
);
```

#### 5. retryWhen()

Custom retry logic.

```java
Flux<Integer> source = Flux.just(1, 2, 3)
    .map(i -> {
        if (i == 2) throw new RuntimeException("Error");
        return i;
    })
    .retryWhen(Retry.fixedDelay(3, Duration.ofSeconds(1)));
```

### Error Handling Best Practices

```java
// 1. Handle errors at the right level
Flux<String> source = Flux.just("a", "b", "c")
    .map(this::riskyOperation)
    .onErrorReturn("default")  // Handle at operation level
    .onErrorResume(error -> {
        log.error("Error occurred", error);
        return Flux.just("fallback");
    });  // Handle at stream level

// 2. Use doOnError for logging
Flux<String> source = Flux.just("a", "b", "c")
    .doOnError(error -> log.error("Error: ", error))
    .onErrorReturn("default");

// 3. Retry with exponential backoff
Flux<String> source = Flux.just("a", "b", "c")
    .retryWhen(Retry.backoff(3, Duration.ofSeconds(1)));
```

---

## Reactor Schedulers

### What are Schedulers?

**Schedulers** control which thread executes work in Reactor.

### Types of Schedulers

#### 1. Schedulers.immediate()

Executes on current thread (synchronous).

```java
Flux<String> source = Flux.just("Hello")
    .subscribeOn(Schedulers.immediate());
```

#### 2. Schedulers.single()

Single thread for all work.

```java
Flux<String> source = Flux.just("Hello")
    .subscribeOn(Schedulers.single());
```

#### 3. Schedulers.elastic()

Creates threads on demand (deprecated, use boundedElastic).

```java
Flux<String> source = Flux.just("Hello")
    .subscribeOn(Schedulers.boundedElastic());
```

#### 4. Schedulers.boundedElastic()

Thread pool with bounded size (for blocking I/O).

```java
Flux<String> source = Flux.just("Hello")
    .subscribeOn(Schedulers.boundedElastic());
```

#### 5. Schedulers.parallel()

Fixed pool of worker threads (for CPU-intensive work).

```java
Flux<Integer> source = Flux.range(1, 1000)
    .subscribeOn(Schedulers.parallel())
    .map(i -> i * i); // CPU-intensive
```

### subscribeOn() vs publishOn()

#### subscribeOn()

Specifies which thread the Publisher should execute on.

```java
Flux<String> source = Flux.create(sink -> {
    System.out.println("Thread: " + Thread.currentThread().getName());
    sink.next("Hello");
    sink.complete();
})
.subscribeOn(Schedulers.boundedElastic());

source.subscribe();
// Output: Thread: boundedElastic-1
```

#### publishOn()

Switches to a different Scheduler downstream.

```java
Flux<String> source = Flux.just("Hello")
    .publishOn(Schedulers.parallel())
    .map(s -> {
        System.out.println("Map on: " + Thread.currentThread().getName());
        return s.toUpperCase();
    });

source.subscribe();
// Output: Map on: parallel-1
```

### Example: Threading in Reactor

```java
Flux<String> source = Flux.create(sink -> {
    System.out.println("Emit on: " + Thread.currentThread().getName());
    sink.next("Hello");
    sink.complete();
})
.subscribeOn(Schedulers.boundedElastic())  // Emit on elastic thread
.publishOn(Schedulers.parallel())  // Switch to parallel thread
.map(s -> {
    System.out.println("Map on: " + Thread.currentThread().getName());
    return s.toUpperCase();
})
.publishOn(Schedulers.single())  // Switch to single thread
.doOnNext(s -> 
    System.out.println("Observe on: " + Thread.currentThread().getName())
);

source.subscribe();
```

---

## Spring WebFlux Integration

### What is Spring WebFlux?

**Spring WebFlux** is a reactive web framework built on Project Reactor, providing non-blocking, reactive alternatives to Spring MVC.

### Key Components

#### 1. Reactive Controllers

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    // Return Mono for single result
    @GetMapping("/{id}")
    public Mono<User> getUser(@PathVariable String id) {
        return userService.findById(id);
    }
    
    // Return Flux for multiple results
    @GetMapping
    public Flux<User> getAllUsers() {
        return userService.findAll();
    }
    
    // Accept Mono in request body
    @PostMapping
    public Mono<User> createUser(@RequestBody Mono<User> userMono) {
        return userService.save(userMono);
    }
    
    // Server-Sent Events
    @GetMapping(value = "/events", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<User>> getUserEvents() {
        return userService.getUserEvents()
            .map(user -> ServerSentEvent.<User>builder()
                .data(user)
                .build());
    }
}
```

#### 2. Reactive Repositories

```java
public interface UserRepository extends ReactiveCrudRepository<User, String> {
    Flux<User> findByTenantId(String tenantId);
    Mono<User> findByEmail(String email);
}
```

#### 3. Reactive WebClient

```java
@Service
public class UserService {
    
    private final WebClient webClient;
    
    public UserService(WebClient.Builder webClientBuilder) {
        this.webClient = webClientBuilder
            .baseUrl("http://api.example.com")
            .build();
    }
    
    public Mono<User> getUser(String id) {
        return webClient.get()
            .uri("/users/{id}", id)
            .retrieve()
            .bodyToMono(User.class)
            .timeout(Duration.ofSeconds(5))
            .retry(3);
    }
    
    public Flux<User> getAllUsers() {
        return webClient.get()
            .uri("/users")
            .retrieve()
            .bodyToFlux(User.class);
    }
}
```

#### 4. Reactive Database Access

**R2DBC (Reactive Relational Database Connectivity):**

```java
@Repository
public class UserRepository {
    
    private final R2dbcEntityTemplate template;
    
    public Mono<User> findById(String id) {
        return template.select(User.class)
            .matching(Query.query(Criteria.where("id").is(id)))
            .one();
    }
    
    public Flux<User> findAll() {
        return template.select(User.class).all();
    }
    
    public Mono<User> save(User user) {
        return template.insert(user);
    }
}
```

**MongoDB Reactive:**

```java
@Repository
public interface UserRepository extends ReactiveMongoRepository<User, String> {
    Flux<User> findByTenantId(String tenantId);
    Mono<User> findByEmail(String email);
}
```

### WebFlux Configuration

```java
@Configuration
public class WebFluxConfig {
    
    @Bean
    public WebClient webClient() {
        return WebClient.builder()
            .baseUrl("http://api.example.com")
            .codecs(configurer -> configurer
                .defaultCodecs()
                .maxInMemorySize(16 * 1024 * 1024))
            .build();
    }
    
    @Bean
    public RouterFunction<ServerResponse> routes(UserHandler userHandler) {
        return RouterFunctions.route()
            .GET("/users/{id}", userHandler::getUser)
            .GET("/users", userHandler::getAllUsers)
            .POST("/users", userHandler::createUser)
            .build();
    }
}
```

### Functional Endpoints (Alternative to Controllers)

```java
@Component
public class UserHandler {
    
    private final UserService userService;
    
    public Mono<ServerResponse> getUser(ServerRequest request) {
        String id = request.pathVariable("id");
        return userService.findById(id)
            .flatMap(user -> ServerResponse.ok()
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(user))
            .switchIfEmpty(ServerResponse.notFound().build());
    }
    
    public Mono<ServerResponse> getAllUsers(ServerRequest request) {
        return ServerResponse.ok()
            .contentType(MediaType.APPLICATION_JSON)
            .body(userService.findAll(), User.class);
    }
    
    public Mono<ServerResponse> createUser(ServerRequest request) {
        return request.bodyToMono(User.class)
            .flatMap(userService::save)
            .flatMap(user -> ServerResponse.status(HttpStatus.CREATED)
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(user));
    }
}
```

---

## RxJava vs Project Reactor

### Comparison Table

| Aspect | RxJava | Project Reactor |
|--------|--------|-----------------|
| **Origin** | ReactiveX (Microsoft) | Pivotal (Spring) |
| **Spring Integration** | Manual | Native (WebFlux) |
| **API Style** | More operators | More Spring-friendly |
| **Learning Curve** | Steeper | Gentler (Spring ecosystem) |
| **Performance** | Excellent | Excellent (optimized) |
| **Backpressure** | Flowable | Built-in (Flux/Mono) |
| **Community** | Large | Growing (Spring ecosystem) |
| **Documentation** | Good | Excellent (Spring docs) |

### Code Comparison

#### Creating a Stream

**RxJava:**
```java
Observable<String> observable = Observable.just("Hello", "World");
```

**Reactor:**
```java
Flux<String> flux = Flux.just("Hello", "World");
```

#### Transforming

**RxJava:**
```java
Observable<String> upper = observable.map(String::toUpperCase);
```

**Reactor:**
```java
Flux<String> upper = flux.map(String::toUpperCase);
```

#### Error Handling

**RxJava:**
```java
Observable<String> source = Observable.just("Hello")
    .map(s -> {
        if (s.equals("Hello")) throw new RuntimeException();
        return s;
    })
    .onErrorReturn("Error occurred");
```

**Reactor:**
```java
Flux<String> source = Flux.just("Hello")
    .map(s -> {
        if (s.equals("Hello")) throw new RuntimeException();
        return s;
    })
    .onErrorReturn("Error occurred");
```

### When to Use Which?

#### Use RxJava When:
- ✅ You need the most comprehensive operator set
- ✅ Working outside Spring ecosystem
- ✅ Team already knows RxJava
- ✅ Need RxJava-specific operators

#### Use Project Reactor When:
- ✅ Using Spring Framework 5+
- ✅ Building Spring Boot applications
- ✅ Need Spring WebFlux integration
- ✅ Want Spring-native reactive support
- ✅ Prefer Spring ecosystem consistency

### Interoperability

Both libraries are Reactive Streams compliant, so they can interoperate:

```java
// RxJava to Reactor
Observable<String> rxObservable = Observable.just("Hello");
Flux<String> reactorFlux = Flux.from(rxObservable.toFlowable(BackpressureStrategy.BUFFER));

// Reactor to RxJava
Flux<String> reactorFlux = Flux.just("Hello");
Observable<String> rxObservable = RxJava3Adapter.fluxToObservable(reactorFlux);
```

---

## Advanced Patterns

### 1. Circuit Breaker Pattern

```java
@Service
public class ExternalService {
    
    private final CircuitBreaker circuitBreaker;
    
    public Mono<String> callExternalService() {
        return Mono.fromCallable(() -> {
            // External service call
            return httpClient.get("/api/data");
        })
        .transformDeferred(CircuitBreakerOperator.of(circuitBreaker))
        .onErrorResume(error -> {
            // Fallback when circuit is open
            return Mono.just("Fallback data");
        });
    }
}
```

### 2. Retry with Exponential Backoff

```java
Flux<String> source = Flux.just("data")
    .flatMap(this::riskyOperation)
    .retryWhen(Retry.backoff(3, Duration.ofSeconds(1))
        .maxBackoff(Duration.ofSeconds(10))
        .doBeforeRetry(retrySignal -> 
            log.info("Retrying: {}", retrySignal.totalRetries())
        )
    );
```

### 3. Caching

```java
@Service
public class UserService {
    
    private final Cache<String, Mono<User>> userCache;
    
    public Mono<User> getUser(String id) {
        return userCache.get(id, key -> 
            fetchUserFromDatabase(key)
                .cache(Duration.ofMinutes(5))
        );
    }
}
```

### 4. Parallel Processing

```java
Flux<Integer> numbers = Flux.range(1, 1000);

Flux<Integer> processed = numbers
    .parallel(4)  // 4 parallel rails
    .runOn(Schedulers.parallel())
    .map(i -> i * i)  // Process in parallel
    .sequential();  // Merge back to sequential
```

### 5. Batch Processing

```java
Flux<Integer> numbers = Flux.range(1, 100);

Flux<List<Integer>> batched = numbers
    .buffer(10)  // Batch of 10
    .flatMap(batch -> 
        processBatch(batch)  // Process each batch
    );
```

### 6. Timeout and Fallback

```java
Mono<String> result = externalService.getData()
    .timeout(Duration.ofSeconds(5))
    .onErrorResume(TimeoutException.class, e -> 
        getCachedData()  // Fallback to cache
    )
    .onErrorResume(error -> 
        Mono.just("Default value")  // Final fallback
    );
```

### 7. Combining Multiple Sources

```java
Mono<User> user = getUser(userId);
Mono<Profile> profile = getProfile(userId);
Mono<Settings> settings = getSettings(userId);

Mono<UserData> combined = Mono.zip(user, profile, settings)
    .map(tuple -> new UserData(
        tuple.getT1(),  // user
        tuple.getT2(),  // profile
        tuple.getT3()   // settings
    ));
```

### 8. Conditional Processing

```java
Flux<String> source = Flux.just("a", "b", "c");

Flux<String> processed = source
    .flatMap(item -> {
        if (item.equals("a")) {
            return processA(item);
        } else if (item.equals("b")) {
            return processB(item);
        } else {
            return processC(item);
        }
    });
```

---

## Best Practices

### 1. Avoid Blocking in Reactive Code

**BAD:**
```java
Mono<String> data = Mono.fromCallable(() -> {
    return blockingDatabase.query();  // Blocks thread!
});
```

**GOOD:**
```java
Mono<String> data = reactiveDatabase.query()  // Non-blocking
    .subscribeOn(Schedulers.boundedElastic());  // If must block, use boundedElastic
```

### 2. Handle Errors Appropriately

```java
// Don't swallow errors
Flux<String> source = Flux.just("a", "b", "c")
    .map(this::riskyOperation)
    .onErrorReturn("default");  // Handle, don't ignore

// Log errors
Flux<String> source = Flux.just("a", "b", "c")
    .doOnError(error -> log.error("Error occurred", error))
    .onErrorResume(error -> getFallback());
```

### 3. Use Appropriate Schedulers

```java
// I/O operations
Mono<String> data = fetchData()
    .subscribeOn(Schedulers.boundedElastic());

// CPU-intensive
Flux<Integer> processed = numbers
    .subscribeOn(Schedulers.parallel())
    .map(this::cpuIntensiveOperation);
```

### 4. Control Backpressure

```java
// For high-volume streams
Flux<Integer> source = Flux.range(1, 1_000_000);

source
    .onBackpressureBuffer(1000)  // Buffer up to 1000
    .subscribe(
        item -> process(item),
        error -> handleError(error),
        () -> complete(),
        subscription -> subscription.request(100)  // Request in batches
    );
```

### 5. Don't Block in Reactive Chains

**BAD:**
```java
String result = mono.block();  // Blocks thread!
```

**GOOD:**
```java
mono.subscribe(result -> {
    // Handle result asynchronously
});
```

### 6. Use Mono for Single Results

```java
// BAD: Using Flux for single result
Flux<User> getUser(String id) {
    return Flux.fromIterable(List.of(user));
}

// GOOD: Using Mono
Mono<User> getUser(String id) {
    return Mono.just(user);
}
```

### 7. Compose Operations

```java
// GOOD: Composable
Mono<User> user = getUser(userId)
    .flatMap(this::enrichUser)
    .flatMap(this::validateUser)
    .doOnNext(this::logUser)
    .cache(Duration.ofMinutes(5));
```

### 8. Test Reactive Code

```java
@Test
void testReactiveOperation() {
    StepVerifier.create(getUser("123"))
        .expectNextMatches(user -> user.getId().equals("123"))
        .verifyComplete();
}

@Test
void testErrorHandling() {
    StepVerifier.create(getUser("invalid"))
        .expectError(NotFoundException.class)
        .verify();
}
```

---

## Real-World Examples

### Example 1: Reactive REST API

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @GetMapping("/{id}")
    public Mono<ResponseEntity<User>> getUser(@PathVariable String id) {
        return userService.findById(id)
            .map(user -> ResponseEntity.ok(user))
            .switchIfEmpty(Mono.just(ResponseEntity.notFound().build()));
    }
    
    @GetMapping
    public Flux<User> getAllUsers(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {
        return userService.findAll(page, size);
    }
    
    @PostMapping
    public Mono<ResponseEntity<User>> createUser(@RequestBody Mono<User> userMono) {
        return userService.save(userMono)
            .map(user -> ResponseEntity.status(HttpStatus.CREATED).body(user));
    }
    
    @PutMapping("/{id}")
    public Mono<ResponseEntity<User>> updateUser(
            @PathVariable String id,
            @RequestBody Mono<User> userMono) {
        return userService.update(id, userMono)
            .map(user -> ResponseEntity.ok(user))
            .switchIfEmpty(Mono.just(ResponseEntity.notFound().build()));
    }
    
    @DeleteMapping("/{id}")
    public Mono<ResponseEntity<Void>> deleteUser(@PathVariable String id) {
        return userService.delete(id)
            .then(Mono.just(ResponseEntity.noContent().build()));
    }
}
```

### Example 2: Reactive Service with Multiple Data Sources

```java
@Service
public class UserService {
    
    private final UserRepository userRepository;
    private final ProfileService profileService;
    private final SettingsService settingsService;
    private final WebClient webClient;
    
    public Mono<EnrichedUser> getEnrichedUser(String userId) {
        Mono<User> user = userRepository.findById(userId);
        Mono<Profile> profile = profileService.getProfile(userId);
        Mono<Settings> settings = settingsService.getSettings(userId);
        
        return Mono.zip(user, profile, settings)
            .map(tuple -> EnrichedUser.builder()
                .user(tuple.getT1())
                .profile(tuple.getT2())
                .settings(tuple.getT3())
                .build())
            .timeout(Duration.ofSeconds(5))
            .retry(3)
            .onErrorResume(error -> {
                log.error("Error fetching user data", error);
                return Mono.just(getDefaultEnrichedUser());
            });
    }
    
    public Flux<User> searchUsers(String query) {
        return userRepository.findByNameContaining(query)
            .take(100)  // Limit results
            .filter(user -> user.isActive())
            .sort(Comparator.comparing(User::getName));
    }
}
```

### Example 3: Reactive Event Processing

```java
@Service
public class EventProcessor {
    
    private final Sinks.Many<Event> eventSink = Sinks.many().multicast().onBackpressureBuffer();
    
    public Flux<Event> getEventStream() {
        return eventSink.asFlux();
    }
    
    public void publishEvent(Event event) {
        eventSink.tryEmitNext(event);
    }
    
    public Flux<ProcessedEvent> processEvents() {
        return getEventStream()
            .buffer(Duration.ofSeconds(1))  // Batch events
            .flatMap(events -> 
                Flux.fromIterable(events)
                    .parallel(4)
                    .runOn(Schedulers.parallel())
                    .map(this::processEvent)
                    .sequential()
            )
            .doOnNext(this::saveProcessedEvent)
            .doOnError(error -> log.error("Error processing events", error))
            .retryWhen(Retry.backoff(3, Duration.ofSeconds(1)));
    }
}
```

### Example 4: Reactive Database Operations

```java
@Repository
public class UserRepository {
    
    private final R2dbcEntityTemplate template;
    
    public Mono<User> findById(String id) {
        return template.select(User.class)
            .matching(Query.query(Criteria.where("id").is(id)))
            .one()
            .timeout(Duration.ofSeconds(5))
            .retry(3);
    }
    
    public Flux<User> findByTenantId(String tenantId, Pageable pageable) {
        return template.select(User.class)
            .matching(Query.query(Criteria.where("tenantId").is(tenantId))
                .with(pageable))
            .all();
    }
    
    public Mono<User> save(User user) {
        return template.insert(user)
            .doOnSuccess(saved -> log.info("User saved: {}", saved.getId()))
            .doOnError(error -> log.error("Error saving user", error));
    }
    
    public Mono<Void> delete(String id) {
        return template.delete(User.class)
            .matching(Query.query(Criteria.where("id").is(id)))
            .all()
            .then();
    }
}
```

### Example 5: Reactive WebClient with Retry and Circuit Breaker

```java
@Service
public class ExternalApiService {
    
    private final WebClient webClient;
    private final CircuitBreaker circuitBreaker;
    
    public Mono<ApiResponse> callExternalApi(String endpoint) {
        return webClient.get()
            .uri(endpoint)
            .retrieve()
            .bodyToMono(ApiResponse.class)
            .transformDeferred(CircuitBreakerOperator.of(circuitBreaker))
            .timeout(Duration.ofSeconds(10))
            .retryWhen(Retry.backoff(3, Duration.ofSeconds(1))
                .filter(error -> error instanceof WebClientException)
            )
            .onErrorResume(TimeoutException.class, e -> {
                log.warn("Timeout calling external API: {}", endpoint);
                return getCachedResponse(endpoint);
            })
            .onErrorResume(CircuitBreakerOpenException.class, e -> {
                log.warn("Circuit breaker open, using fallback");
                return getFallbackResponse();
            })
            .doOnSuccess(response -> cacheResponse(endpoint, response))
            .doOnError(error -> log.error("Error calling external API", error));
    }
}
```

---

## Summary of Part 2

**Key Concepts Covered:**
1. ✅ Project Reactor overview and principles
2. ✅ Mono and Flux (creation, subscription)
3. ✅ Reactor operators (transformation, filtering, combining, utility)
4. ✅ Error handling in Reactor
5. ✅ Schedulers and threading
6. ✅ Spring WebFlux integration
7. ✅ RxJava vs Project Reactor comparison
8. ✅ Advanced patterns (circuit breaker, retry, caching, parallel processing)
9. ✅ Best practices for reactive programming
10. ✅ Real-world examples and use cases

**Complete Understanding:**
- Part 1 covered fundamentals, Reactive Streams, and RxJava
- Part 2 covered Project Reactor, Spring integration, and advanced topics
- Together, they provide comprehensive knowledge of reactive programming in Java

**Key Takeaways:**
- **Reactive Programming** enables non-blocking, scalable applications
- **Reactive Streams** provides the standard for interoperability
- **RxJava** offers comprehensive operators and wide adoption
- **Project Reactor** provides Spring-native reactive support
- **Spring WebFlux** enables fully reactive web applications
- **Best Practices** ensure efficient and maintainable reactive code

