# Two-Phase Booking with Distributed Locks: Complete Guide

## Table of Contents
1. [Introduction](#introduction)
2. [Understanding Two-Phase Booking](#understanding-two-phase-booking)
3. [Understanding Distributed Locks](#understanding-distributed-locks)
4. [Combining Two-Phase Booking with Distributed Locks](#combining-two-phase-booking-with-distributed-locks)
5. [Detailed Implementation](#detailed-implementation)
6. [Complete Code Examples](#complete-code-examples)
7. [Lock Management and Cleanup](#lock-management-and-cleanup)
8. [Error Handling and Edge Cases](#error-handling-and-edge-cases)
9. [Performance Optimization](#performance-optimization)
10. [Real-World Scenarios](#real-world-scenarios)
11. [Best Practices](#best-practices)

---

## Introduction

### What is Two-Phase Booking?

**Two-Phase Booking** is a pattern that splits the booking process into two distinct phases:

1. **Phase 1: Lock/Reserve** - Temporarily reserve resources (seats, inventory, etc.)
2. **Phase 2: Confirm** - Permanently book after payment/confirmation

This pattern provides:
- Better user experience (reserve before payment)
- Time for payment processing
- Graceful handling of failures
- Prevention of double booking

### What are Distributed Locks?

**Distributed Locks** allow multiple application servers to coordinate access to shared resources in a distributed system. Unlike database locks that work within a single database instance, distributed locks work across multiple servers.

Common implementations:
- **Redis** (most popular)
- **Zookeeper**
- **etcd**
- **Hazelcast**

### Why Combine Them?

Combining two-phase booking with distributed locks provides:
- **Scalability**: Works across multiple servers
- **Performance**: Fast in-memory locking
- **Reliability**: Prevents double booking in distributed systems
- **Flexibility**: Lock expiration and cleanup

---

## Understanding Two-Phase Booking

### Traditional Single-Phase Booking (Problems)

```python
# Single-phase booking - PROBLEMS:
def book_seat_single_phase(event_id, seat_id, user_id):
    with db.transaction():
        # Check and book atomically
        seat = db.query("SELECT * FROM seats WHERE id = ? FOR UPDATE", seat_id)
        
        if seat.status != 'available':
            raise SeatUnavailableError()
        
        # Book immediately
        db.execute("UPDATE seats SET status = 'booked' WHERE id = ?", seat_id)
        
        # What if payment fails? Seat is already booked!
        payment_result = payment_gateway.charge(user_id, amount)  # Can fail!
        
        if not payment_result.success:
            # Too late! Seat is already booked
            # Need to refund or handle error
            pass
        
        db.commit()
```

**Problems:**
- Seat booked before payment confirmation
- If payment fails, need complex rollback
- No time for user to complete payment
- Poor user experience

### Two-Phase Booking Solution

```
Phase 1: LOCK (Temporary Reservation)
├─ User selects seats
├─ System locks seats for 15 minutes
├─ Creates pending booking
└─ User proceeds to payment

Phase 2: CONFIRM (Permanent Booking)
├─ User completes payment
├─ System confirms booking
├─ Converts lock to permanent booking
└─ Releases lock
```

### Two-Phase Flow Diagram

```
User selects seats
    ↓
[Phase 1: Lock]
    ├─ Acquire distributed locks
    ├─ Create pending booking
    ├─ Set lock expiration (15 min)
    └─ Return booking_id
    ↓
User sees "Reserved for 15 minutes"
    ↓
User enters payment details
    ↓
Payment processing...
    ↓
[Phase 2: Confirm]
    ├─ Validate payment
    ├─ Confirm booking
    ├─ Convert to permanent
    └─ Release locks
    ↓
Booking confirmed!
```

---

## Understanding Distributed Locks

### Why Distributed Locks?

In a distributed system with multiple application servers:

```
Server 1                    Server 2                    Server 3
   │                           │                           │
   ├─ Check seat available     ├─ Check seat available     ├─ Check seat available
   │  (all see available)      │  (all see available)      │  (all see available)
   │                           │                           │
   ├─ Book seat                ├─ Book seat                ├─ Book seat
   │                           │                           │
   └─ All succeed! ❌          └─ All succeed! ❌          └─ All succeed! ❌
   
   → DOUBLE/TRIPLE BOOKING!
```

**Solution: Distributed Lock**

```
Server 1                    Server 2                    Server 3
   │                           │                           │
   ├─ Acquire lock ✅          ├─ Try to acquire lock     ├─ Try to acquire lock
   │  (succeeds)               │  (BLOCKED - waiting)     │  (BLOCKED - waiting)
   │                           │                           │
   ├─ Book seat                 │                           │
   │                           │                           │
   ├─ Release lock             │                           │
   │                           │                           │
   │                           ├─ Acquire lock ✅          │
   │                           │  (now succeeds)           │
   │                           ├─ Check availability        │
   │                           │  (seat already booked)    │
   │                           └─ Return error ✅          │
```

### Redis Distributed Lock Implementation

#### Basic Lock Acquisition

```python
import redis
import uuid
import time

class DistributedLock:
    def __init__(self, redis_client):
        self.redis = redis_client
    
    def acquire_lock(self, lock_key, timeout=10, lock_duration=15):
        """
        Acquire a distributed lock
        
        Args:
            lock_key: Unique identifier for the lock
            timeout: Maximum time to wait for lock (seconds)
            lock_duration: How long lock is held (seconds)
        
        Returns:
            lock_id if successful, None otherwise
        """
        lock_id = str(uuid.uuid4())
        end_time = time.time() + timeout
        
        while time.time() < end_time:
            # Try to acquire lock (SET if Not eXists)
            # NX = only set if not exists
            # EX = expiration time
            if self.redis.set(lock_key, lock_id, nx=True, ex=lock_duration):
                return lock_id
            
            # Wait a bit before retrying
            time.sleep(0.01)
        
        return None  # Timeout
    
    def release_lock(self, lock_key, lock_id):
        """
        Release lock only if we own it (atomic operation)
        """
        # Lua script for atomic check-and-delete
        lua_script = """
        if redis.call("get", KEYS[1]) == ARGV[1] then
            return redis.call("del", KEYS[1])
        else
            return 0
        end
        """
        
        return self.redis.eval(lua_script, 1, lock_key, lock_id)
    
    def extend_lock(self, lock_key, lock_id, additional_time=15):
        """
        Extend lock duration
        """
        lua_script = """
        if redis.call("get", KEYS[1]) == ARGV[1] then
            return redis.call("expire", KEYS[1], ARGV[2])
        else
            return 0
        end
        """
        
        return self.redis.eval(lua_script, 1, lock_key, lock_id, additional_time)
```

### Lock Properties

#### 1. Mutual Exclusion
Only one process can hold the lock at a time.

#### 2. Deadlock Freedom
Locks expire automatically, preventing deadlocks.

#### 3. Fault Tolerance
If a process crashes, the lock expires automatically.

#### 4. Atomicity
Lock operations are atomic (using Redis SET NX or Lua scripts).

---

## Combining Two-Phase Booking with Distributed Locks

### Architecture

```
┌─────────────┐
│   User      │
└──────┬──────┘
       │
       │ 1. Select seats
       ↓
┌─────────────────────────────────┐
│   Application Server 1           │
│                                  │
│  Phase 1: Lock                   │
│  ├─ Acquire Redis locks          │
│  ├─ Create pending booking       │
│  └─ Set expiration (15 min)      │
└──────┬───────────────────────────┘
       │
       │ Redis
       ↓
┌─────────────────────────────────┐
│   Redis Cluster                 │
│   lock:event:123:seat:S1        │
│   lock:event:123:seat:S2        │
│   (TTL: 15 minutes)             │
└─────────────────────────────────┘
       │
       │ 2. Payment
       ↓
┌─────────────────────────────────┐
│   Application Server 2           │
│                                  │
│  Phase 2: Confirm                │
│  ├─ Validate payment             │
│  ├─ Confirm booking              │
│  └─ Release locks                │
└─────────────────────────────────┘
       │
       │ Database
       ↓
┌─────────────────────────────────┐
│   PostgreSQL                     │
│   bookings (pending → confirmed) │
│   seats (available → booked)     │
└─────────────────────────────────┘
```

### Complete Flow

```
1. User selects seats [S1, S2, S3]
   ↓
2. Server 1: Phase 1 - Lock
   ├─ Try to acquire locks in Redis:
   │  ├─ lock:event:123:seat:S1
   │  ├─ lock:event:123:seat:S2
   │  └─ lock:event:123:seat:S3
   │
   ├─ If all locks acquired:
   │  ├─ Create pending booking in DB
   │  ├─ Update seat status to 'locked'
   │  └─ Return booking_id
   │
   └─ If any lock fails:
      └─ Release all acquired locks
      └─ Return error
   ↓
3. User sees "Reserved for 15 minutes"
   ↓
4. User enters payment details
   ↓
5. Server 2: Phase 2 - Confirm
   ├─ Validate booking (check status, expiration)
   ├─ Process payment
   │
   ├─ If payment successful:
   │  ├─ Update booking status to 'confirmed'
   │  ├─ Update seats to 'booked'
   │  ├─ Release Redis locks
   │  └─ Send confirmation
   │
   └─ If payment fails:
      └─ Keep booking as 'pending'
      └─ Locks expire automatically
   ↓
6. Booking confirmed!
```

---

## Detailed Implementation

### Phase 1: Lock Implementation

```python
import redis
import uuid
from datetime import datetime, timedelta
from typing import List, Dict, Optional

class TwoPhaseBooking:
    def __init__(self, redis_client, db_connection):
        self.redis = redis_client
        self.db = db_connection
        self.lock_manager = DistributedLock(redis_client)
    
    def phase1_lock_seats(
        self, 
        event_id: str, 
        seat_ids: List[str], 
        user_id: str,
        lock_duration_minutes: int = 15
    ) -> Dict:
        """
        Phase 1: Lock seats temporarily
        
        Returns:
            {
                'booking_id': str,
                'lock_ids': List[str],
                'expires_at': datetime,
                'seats': List[Dict]
            }
        """
        booking_id = str(uuid.uuid4())
        lock_keys = []
        acquired_locks = []  # (lock_key, lock_id) pairs
        
        try:
            # Step 1: Acquire all locks atomically
            for seat_id in seat_ids:
                lock_key = f"lock:event:{event_id}:seat:{seat_id}"
                lock_keys.append(lock_key)
                
                # Try to acquire lock
                lock_id = self.lock_manager.acquire_lock(
                    lock_key=lock_key,
                    timeout=2,  # Wait max 2 seconds
                    lock_duration=lock_duration_minutes * 60
                )
                
                if not lock_id:
                    # Failed to acquire lock - release all acquired locks
                    self._release_all_locks(acquired_locks)
                    raise SeatUnavailableError(
                        f"Seat {seat_id} is currently being booked by another user"
                    )
                
                acquired_locks.append((lock_key, lock_id))
            
            # Step 2: Verify seats are available in database
            seats = self.db.query("""
                SELECT seat_id, status, row_number, seat_number, price
                FROM seats
                WHERE event_id = ? AND seat_id IN (?)
            """, event_id, seat_ids)
            
            unavailable_seats = [
                s for s in seats 
                if s.status != 'available'
            ]
            
            if unavailable_seats:
                self._release_all_locks(acquired_locks)
                raise SeatUnavailableError(
                    f"Seats {[s.seat_id for s in unavailable_seats]} are not available"
                )
            
            # Step 3: Create pending booking in database
            with self.db.transaction():
                booking = self.db.execute("""
                    INSERT INTO bookings (
                        booking_id, user_id, event_id, status,
                        expiry_time, total_amount, created_at
                    )
                    VALUES (?, ?, ?, 'pending', ?, ?, NOW())
                    RETURNING booking_id, expiry_time
                """, 
                    booking_id,
                    user_id,
                    event_id,
                    datetime.now() + timedelta(minutes=lock_duration_minutes),
                    sum(s.price for s in seats)
                )
                
                # Create booking_seats records
                for seat in seats:
                    self.db.execute("""
                        INSERT INTO booking_seats (
                            booking_id, seat_id, price
                        )
                        VALUES (?, ?, ?)
                    """, booking_id, seat.seat_id, seat.price)
                
                # Update seat status to 'locked' (not 'booked' yet)
                self.db.execute("""
                    UPDATE seats
                    SET status = 'locked',
                        booking_id = ?
                    WHERE seat_id IN (?)
                """, booking_id, seat_ids)
                
                self.db.commit()
            
            # Step 4: Store lock information in Redis for cleanup
            for lock_key, lock_id in acquired_locks:
                self.redis.setex(
                    f"booking:{booking_id}:lock:{lock_key}",
                    lock_duration_minutes * 60,
                    lock_id
                )
            
            return {
                'booking_id': booking_id,
                'lock_ids': [lock_id for _, lock_id in acquired_locks],
                'expires_at': booking.expiry_time,
                'seats': [
                    {
                        'seat_id': s.seat_id,
                        'row': s.row_number,
                        'number': s.seat_number,
                        'price': s.price
                    }
                    for s in seats
                ],
                'total_amount': booking.total_amount
            }
            
        except Exception as e:
            # Cleanup on error
            self._release_all_locks(acquired_locks)
            raise
    
    def _release_all_locks(self, acquired_locks: List[tuple]):
        """
        Release all acquired locks
        """
        for lock_key, lock_id in acquired_locks:
            try:
                self.lock_manager.release_lock(lock_key, lock_id)
            except Exception as e:
                # Log error but continue releasing other locks
                print(f"Error releasing lock {lock_key}: {e}")
```

### Phase 2: Confirm Implementation

```python
    def phase2_confirm_booking(
        self,
        booking_id: str,
        payment_id: str,
        payment_method: str
    ) -> Dict:
        """
        Phase 2: Confirm booking after payment
        
        Returns:
            {
                'booking_id': str,
                'status': 'confirmed',
                'confirmed_at': datetime
            }
        """
        # Step 1: Validate booking
        booking = self.db.query("""
            SELECT booking_id, user_id, event_id, status, expiry_time
            FROM bookings
            WHERE booking_id = ?
        """, booking_id)
        
        if not booking:
            raise BookingNotFoundError(f"Booking {booking_id} not found")
        
        if booking.status != 'pending':
            raise InvalidBookingStatusError(
                f"Booking is {booking.status}, expected 'pending'"
            )
        
        if booking.expiry_time < datetime.now():
            raise BookingExpiredError("Booking has expired")
        
        # Step 2: Get locked seats
        seat_locks = self.db.query("""
            SELECT seat_id
            FROM booking_seats
            WHERE booking_id = ?
        """, booking_id)
        
        seat_ids = [sl.seat_id for sl in seat_locks]
        
        # Step 3: Verify locks still exist in Redis
        lock_keys = [
            f"lock:event:{booking.event_id}:seat:{seat_id}"
            for seat_id in seat_ids
        ]
        
        for lock_key in lock_keys:
            if not self.redis.exists(lock_key):
                raise LockExpiredError("Lock has expired")
        
        # Step 4: Confirm booking in database
        with self.db.transaction():
            # Update booking status
            self.db.execute("""
                UPDATE bookings
                SET status = 'confirmed',
                    payment_id = ?,
                    payment_method = ?,
                    confirmed_at = NOW()
                WHERE booking_id = ?
                AND status = 'pending'
            """, payment_id, payment_method, booking_id)
            
            # Update seats to 'booked'
            self.db.execute("""
                UPDATE seats
                SET status = 'booked'
                WHERE seat_id IN (?)
                AND status = 'locked'
            """, seat_ids)
            
            self.db.commit()
        
        # Step 5: Release Redis locks
        for lock_key in lock_keys:
            # Get lock_id from Redis
            stored_lock_id = self.redis.get(f"booking:{booking_id}:lock:{lock_key}")
            if stored_lock_id:
                self.lock_manager.release_lock(lock_key, stored_lock_id.decode())
            
            # Clean up lock tracking
            self.redis.delete(f"booking:{booking_id}:lock:{lock_key}")
        
        # Step 6: Invalidate cache
        self._invalidate_cache(booking.event_id, seat_ids)
        
        # Step 7: Send confirmation
        self._send_confirmation(booking.user_id, booking_id)
        
        return {
            'booking_id': booking_id,
            'status': 'confirmed',
            'confirmed_at': datetime.now()
        }
```

### Lock Expiration and Cleanup

```python
    def cleanup_expired_locks(self):
        """
        Background job to clean up expired locks
        Should run every minute
        """
        # Find expired bookings
        expired_bookings = self.db.query("""
            SELECT booking_id, event_id, user_id
            FROM bookings
            WHERE status = 'pending'
            AND expiry_time < NOW()
        """)
        
        for booking in expired_bookings:
            try:
                # Get seat IDs
                seat_locks = self.db.query("""
                    SELECT seat_id
                    FROM booking_seats
                    WHERE booking_id = ?
                """, booking.booking_id)
                
                seat_ids = [sl.seat_id for sl in seat_locks]
                
                # Release Redis locks
                for seat_id in seat_ids:
                    lock_key = f"lock:event:{booking.event_id}:seat:{seat_id}"
                    
                    # Try to get lock_id
                    stored_lock_id = self.redis.get(
                        f"booking:{booking.booking_id}:lock:{lock_key}"
                    )
                    
                    if stored_lock_id:
                        self.lock_manager.release_lock(
                            lock_key, 
                            stored_lock_id.decode()
                        )
                    
                    # Clean up
                    self.redis.delete(f"booking:{booking.booking_id}:lock:{lock_key}")
                
                # Update booking status
                self.db.execute("""
                    UPDATE bookings
                    SET status = 'expired'
                    WHERE booking_id = ?
                """, booking.booking_id)
                
                # Release seats
                self.db.execute("""
                    UPDATE seats
                    SET status = 'available',
                        booking_id = NULL
                    WHERE seat_id IN (?)
                    AND status = 'locked'
                """, seat_ids)
                
                # Notify user
                self._notify_lock_expired(booking.user_id, booking.booking_id)
                
            except Exception as e:
                # Log error but continue with other bookings
                print(f"Error cleaning up booking {booking.booking_id}: {e}")
```

---

## Complete Code Examples

### Full Implementation

```python
import redis
import uuid
import time
from datetime import datetime, timedelta
from typing import List, Dict, Optional
from dataclasses import dataclass

@dataclass
class BookingResult:
    booking_id: str
    status: str
    expires_at: datetime
    seats: List[Dict]
    total_amount: float

class CompleteTwoPhaseBooking:
    def __init__(self, redis_host='localhost', redis_port=6379, db_connection=None):
        self.redis = redis.Redis(
            host=redis_host,
            port=redis_port,
            decode_responses=True
        )
        self.db = db_connection
        self.lock_timeout = 2  # seconds to wait for lock
        self.default_lock_duration = 15 * 60  # 15 minutes in seconds
    
    # ========== Phase 1: Lock ==========
    
    def lock_seats(
        self,
        event_id: str,
        seat_ids: List[str],
        user_id: str,
        lock_duration_minutes: int = 15
    ) -> BookingResult:
        """
        Phase 1: Lock seats for booking
        """
        booking_id = str(uuid.uuid4())
        acquired_locks = []
        
        try:
            # Acquire all locks
            for seat_id in seat_ids:
                lock_key = f"lock:event:{event_id}:seat:{seat_id}"
                lock_id = self._acquire_lock(lock_key, lock_duration_minutes * 60)
                
                if not lock_id:
                    # Release all acquired locks
                    self._release_locks(acquired_locks)
                    raise SeatUnavailableError(f"Seat {seat_id} is locked")
                
                acquired_locks.append((lock_key, lock_id))
            
            # Verify and create booking
            booking = self._create_pending_booking(
                booking_id, event_id, seat_ids, user_id, lock_duration_minutes
            )
            
            # Store lock references
            self._store_lock_references(booking_id, acquired_locks)
            
            return BookingResult(
                booking_id=booking_id,
                status='pending',
                expires_at=booking['expires_at'],
                seats=booking['seats'],
                total_amount=booking['total_amount']
            )
            
        except Exception as e:
            self._release_locks(acquired_locks)
            raise
    
    def _acquire_lock(self, lock_key: str, duration: int) -> Optional[str]:
        """Acquire a distributed lock"""
        lock_id = str(uuid.uuid4())
        end_time = time.time() + self.lock_timeout
        
        while time.time() < end_time:
            if self.redis.set(lock_key, lock_id, nx=True, ex=duration):
                return lock_id
            time.sleep(0.01)
        
        return None
    
    def _create_pending_booking(
        self,
        booking_id: str,
        event_id: str,
        seat_ids: List[str],
        user_id: str,
        lock_duration_minutes: int
    ) -> Dict:
        """Create pending booking in database"""
        with self.db.transaction():
            # Get seat details
            seats = self.db.query("""
                SELECT seat_id, row_number, seat_number, price, status
                FROM seats
                WHERE event_id = ? AND seat_id IN (?)
            """, event_id, seat_ids)
            
            if len(seats) != len(seat_ids):
                raise SeatNotFoundError("Some seats not found")
            
            unavailable = [s for s in seats if s.status != 'available']
            if unavailable:
                raise SeatUnavailableError(
                    f"Seats {[s.seat_id for s in unavailable]} are not available"
                )
            
            total_amount = sum(s.price for s in seats)
            expires_at = datetime.now() + timedelta(minutes=lock_duration_minutes)
            
            # Create booking
            self.db.execute("""
                INSERT INTO bookings (
                    booking_id, user_id, event_id, status,
                    total_amount, expiry_time, created_at
                )
                VALUES (?, ?, ?, 'pending', ?, ?, NOW())
            """, booking_id, user_id, event_id, total_amount, expires_at)
            
            # Create booking_seats
            for seat in seats:
                self.db.execute("""
                    INSERT INTO booking_seats (booking_id, seat_id, price)
                    VALUES (?, ?, ?)
                """, booking_id, seat.seat_id, seat.price)
            
            # Update seats to locked
            self.db.execute("""
                UPDATE seats
                SET status = 'locked', booking_id = ?
                WHERE seat_id IN (?)
            """, booking_id, seat_ids)
            
            self.db.commit()
            
            return {
                'expires_at': expires_at,
                'seats': [
                    {
                        'seat_id': s.seat_id,
                        'row': s.row_number,
                        'number': s.seat_number,
                        'price': s.price
                    }
                    for s in seats
                ],
                'total_amount': total_amount
            }
    
    def _store_lock_references(self, booking_id: str, locks: List[tuple]):
        """Store lock references for cleanup"""
        for lock_key, lock_id in locks:
            self.redis.setex(
                f"booking:{booking_id}:lock:{lock_key}",
                self.default_lock_duration,
                lock_id
            )
    
    def _release_locks(self, locks: List[tuple]):
        """Release multiple locks"""
        lua_script = """
        if redis.call("get", KEYS[1]) == ARGV[1] then
            return redis.call("del", KEYS[1])
        else
            return 0
        end
        """
        
        for lock_key, lock_id in locks:
            try:
                self.redis.eval(lua_script, 1, lock_key, lock_id)
            except Exception as e:
                print(f"Error releasing lock {lock_key}: {e}")
    
    # ========== Phase 2: Confirm ==========
    
    def confirm_booking(
        self,
        booking_id: str,
        payment_id: str,
        payment_method: str = 'credit_card'
    ) -> BookingResult:
        """
        Phase 2: Confirm booking after payment
        """
        # Validate booking
        booking = self._validate_booking(booking_id)
        
        # Get seat locks
        seat_locks = self.db.query("""
            SELECT seat_id FROM booking_seats WHERE booking_id = ?
        """, booking_id)
        
        seat_ids = [sl.seat_id for sl in seat_locks]
        
        # Verify locks still exist
        self._verify_locks_exist(booking.event_id, seat_ids)
        
        # Confirm in database
        self._confirm_in_database(booking_id, payment_id, payment_method, seat_ids)
        
        # Release locks
        self._release_booking_locks(booking_id, booking.event_id, seat_ids)
        
        # Invalidate cache
        self._invalidate_cache(booking.event_id, seat_ids)
        
        # Send confirmation
        self._send_confirmation(booking.user_id, booking_id)
        
        return BookingResult(
            booking_id=booking_id,
            status='confirmed',
            expires_at=datetime.now(),
            seats=[],
            total_amount=0
        )
    
    def _validate_booking(self, booking_id: str) -> Dict:
        """Validate booking can be confirmed"""
        booking = self.db.query("""
            SELECT booking_id, user_id, event_id, status, expiry_time
            FROM bookings
            WHERE booking_id = ?
        """, booking_id)
        
        if not booking:
            raise BookingNotFoundError()
        
        if booking.status != 'pending':
            raise InvalidBookingStatusError(f"Booking is {booking.status}")
        
        if booking.expiry_time < datetime.now():
            raise BookingExpiredError("Booking has expired")
        
        return booking
    
    def _verify_locks_exist(self, event_id: str, seat_ids: List[str]):
        """Verify locks still exist in Redis"""
        for seat_id in seat_ids:
            lock_key = f"lock:event:{event_id}:seat:{seat_id}"
            if not self.redis.exists(lock_key):
                raise LockExpiredError(f"Lock for seat {seat_id} has expired")
    
    def _confirm_in_database(
        self,
        booking_id: str,
        payment_id: str,
        payment_method: str,
        seat_ids: List[str]
    ):
        """Confirm booking in database"""
        with self.db.transaction():
            # Update booking
            rows = self.db.execute("""
                UPDATE bookings
                SET status = 'confirmed',
                    payment_id = ?,
                    payment_method = ?,
                    confirmed_at = NOW()
                WHERE booking_id = ?
                AND status = 'pending'
            """, payment_id, payment_method, booking_id)
            
            if rows == 0:
                raise ConcurrentModificationError("Booking was modified")
            
            # Update seats
            self.db.execute("""
                UPDATE seats
                SET status = 'booked'
                WHERE seat_id IN (?)
                AND status = 'locked'
            """, seat_ids)
            
            self.db.commit()
    
    def _release_booking_locks(
        self,
        booking_id: str,
        event_id: str,
        seat_ids: List[str]
    ):
        """Release all locks for a booking"""
        for seat_id in seat_ids:
            lock_key = f"lock:event:{event_id}:seat:{seat_id}"
            
            # Get stored lock_id
            stored_lock_id = self.redis.get(f"booking:{booking_id}:lock:{lock_key}")
            
            if stored_lock_id:
                # Release lock
                lua_script = """
                if redis.call("get", KEYS[1]) == ARGV[1] then
                    return redis.call("del", KEYS[1])
                else
                    return 0
                end
                """
                self.redis.eval(lua_script, 1, lock_key, stored_lock_id)
            
            # Clean up reference
            self.redis.delete(f"booking:{booking_id}:lock:{lock_key}")
    
    def _invalidate_cache(self, event_id: str, seat_ids: List[str]):
        """Invalidate cache for seats"""
        for seat_id in seat_ids:
            self.redis.delete(f"seat:{event_id}:{seat_id}:status")
        self.redis.delete(f"event:{event_id}:availability")
    
    def _send_confirmation(self, user_id: str, booking_id: str):
        """Send confirmation notification"""
        # Implementation depends on notification system
        pass
```

### Usage Example

```python
# Initialize
booking_system = CompleteTwoPhaseBooking(
    redis_host='localhost',
    redis_port=6379,
    db_connection=db
)

# Phase 1: Lock seats
try:
    result = booking_system.lock_seats(
        event_id='event-123',
        seat_ids=['S1', 'S2', 'S3'],
        user_id='user-456',
        lock_duration_minutes=15
    )
    
    print(f"Booking ID: {result.booking_id}")
    print(f"Expires at: {result.expires_at}")
    print(f"Total: ${result.total_amount}")
    
    # Show to user: "Reserved for 15 minutes"
    
    # Phase 2: Confirm after payment
    payment_result = process_payment(result.booking_id, amount=result.total_amount)
    
    if payment_result.success:
        confirmed = booking_system.confirm_booking(
            booking_id=result.booking_id,
            payment_id=payment_result.payment_id,
            payment_method='credit_card'
        )
        print(f"Booking confirmed: {confirmed.booking_id}")
    else:
        # Booking will expire automatically
        print("Payment failed, booking will expire")
        
except SeatUnavailableError as e:
    print(f"Seats not available: {e}")
except BookingExpiredError as e:
    print(f"Booking expired: {e}")
```

---

## Lock Management and Cleanup

### Lock Extension

```python
def extend_booking_lock(self, booking_id: str, additional_minutes: int = 5):
    """
    Extend lock duration (e.g., payment is processing)
    """
    booking = self.db.query("""
        SELECT booking_id, event_id, expiry_time
        FROM bookings
        WHERE booking_id = ? AND status = 'pending'
    """, booking_id)
    
    if not booking:
        raise BookingNotFoundError()
    
    # Get seat locks
    seat_locks = self.db.query("""
        SELECT seat_id FROM booking_seats WHERE booking_id = ?
    """, booking_id)
    
    # Extend locks in Redis
    for seat_lock in seat_locks:
        lock_key = f"lock:event:{booking.event_id}:seat:{seat_lock.seat_id}"
        stored_lock_id = self.redis.get(f"booking:{booking_id}:lock:{lock_key}")
        
        if stored_lock_id:
            lua_script = """
            if redis.call("get", KEYS[1]) == ARGV[1] then
                return redis.call("expire", KEYS[1], ARGV[2])
            else
                return 0
            end
            """
            self.redis.eval(
                lua_script,
                1,
                lock_key,
                stored_lock_id,
                additional_minutes * 60
            )
    
    # Extend expiry in database
    self.db.execute("""
        UPDATE bookings
        SET expiry_time = expiry_time + INTERVAL ? MINUTE
        WHERE booking_id = ?
    """, additional_minutes, booking_id)
```

### Automatic Cleanup Job

```python
import schedule
import time

def setup_cleanup_job(booking_system):
    """Setup automatic cleanup job"""
    
    def cleanup_expired():
        booking_system.cleanup_expired_locks()
    
    # Run every minute
    schedule.every(1).minutes.do(cleanup_expired)
    
    # Run in background thread
    import threading
    def run_scheduler():
        while True:
            schedule.run_pending()
            time.sleep(1)
    
    thread = threading.Thread(target=run_scheduler, daemon=True)
    thread.start()

# Usage
setup_cleanup_job(booking_system)
```

---

## Error Handling and Edge Cases

### Edge Cases

#### 1. Partial Lock Acquisition Failure

```python
def lock_seats_with_rollback(self, event_id, seat_ids, user_id):
    """
    Handle partial lock acquisition
    """
    acquired_locks = []
    
    try:
        for seat_id in seat_ids:
            lock_key = f"lock:event:{event_id}:seat:{seat_id}"
            lock_id = self._acquire_lock(lock_key, 900)
            
            if not lock_id:
                # Rollback: release all acquired locks
                self._release_locks(acquired_locks)
                raise SeatUnavailableError(f"Could not lock seat {seat_id}")
            
            acquired_locks.append((lock_key, lock_id))
        
        # Continue with booking creation...
        
    except Exception as e:
        # Always cleanup on error
        self._release_locks(acquired_locks)
        raise
```

#### 2. Lock Expires During Payment

```python
def confirm_with_lock_check(self, booking_id, payment_id):
    """
    Handle case where lock expires during payment
    """
    # Check lock before confirming
    booking = self._validate_booking(booking_id)
    seat_locks = self.db.query("""
        SELECT seat_id FROM booking_seats WHERE booking_id = ?
    """, booking_id)
    
    # Verify all locks still exist
    for seat_lock in seat_locks:
        lock_key = f"lock:event:{booking.event_id}:seat:{seat_lock.seat_id}"
        if not self.redis.exists(lock_key):
            # Lock expired - try to re-acquire
            if not self._try_reacquire_lock(lock_key, booking_id):
                raise LockExpiredError("Lock expired during payment")
    
    # Proceed with confirmation
    return self._confirm_in_database(booking_id, payment_id, seat_locks)
```

#### 3. Concurrent Confirmation Attempts

```python
def confirm_with_idempotency(self, booking_id, payment_id, idempotency_key):
    """
    Prevent duplicate confirmations
    """
    # Check idempotency
    existing = self.redis.get(f"confirm:{idempotency_key}")
    if existing:
        return json.loads(existing)
    
    # Confirm booking
    result = self.confirm_booking(booking_id, payment_id)
    
    # Store idempotency
    self.redis.setex(
        f"confirm:{idempotency_key}",
        3600,  # 1 hour
        json.dumps(result)
    )
    
    return result
```

---

## Performance Optimization

### 1. Batch Lock Acquisition

```python
def acquire_locks_batch(self, lock_keys: List[str], duration: int) -> Dict[str, str]:
    """
    Acquire multiple locks efficiently
    """
    acquired = {}
    failed = []
    
    # Try to acquire all locks
    pipe = self.redis.pipeline()
    for lock_key in lock_keys:
        lock_id = str(uuid.uuid4())
        pipe.set(lock_key, lock_id, nx=True, ex=duration)
        acquired[lock_key] = lock_id
    
    results = pipe.execute()
    
    # Check which succeeded
    successful = {}
    for i, (lock_key, lock_id) in enumerate(acquired.items()):
        if results[i]:
            successful[lock_key] = lock_id
        else:
            failed.append(lock_key)
    
    # Release successful if any failed
    if failed:
        self._release_locks([(k, v) for k, v in successful.items()])
        raise LockAcquisitionError(f"Failed to acquire locks: {failed}")
    
    return successful
```

### 2. Lock Pooling

```python
class LockPool:
    """
    Pool of pre-created locks for performance
    """
    def __init__(self, redis_client, pool_size=100):
        self.redis = redis_client
        self.pool_size = pool_size
        self.available_locks = queue.Queue(maxsize=pool_size)
        self._initialize_pool()
    
    def _initialize_pool(self):
        """Pre-create lock IDs"""
        for _ in range(self.pool_size):
            self.available_locks.put(str(uuid.uuid4()))
    
    def get_lock_id(self):
        """Get lock ID from pool"""
        try:
            return self.available_locks.get_nowait()
        except queue.Empty:
            return str(uuid.uuid4())  # Fallback
    
    def return_lock_id(self, lock_id):
        """Return lock ID to pool"""
        try:
            self.available_locks.put_nowait(lock_id)
        except queue.Full:
            pass  # Pool full, discard
```

### 3. Caching Lock Status

```python
def check_seat_availability_cached(self, event_id: str, seat_id: str) -> bool:
    """
    Check availability with caching
    """
    cache_key = f"seat:{event_id}:{seat_id}:available"
    
    # Check cache
    cached = self.redis.get(cache_key)
    if cached is not None:
        return cached == 'true'
    
    # Check lock
    lock_key = f"lock:event:{event_id}:seat:{seat_id}"
    is_locked = self.redis.exists(lock_key)
    
    # Check database
    seat = self.db.query("""
        SELECT status FROM seats
        WHERE event_id = ? AND seat_id = ?
    """, event_id, seat_id)
    
    available = not is_locked and seat.status == 'available'
    
    # Cache for 30 seconds
    self.redis.setex(cache_key, 30, 'true' if available else 'false')
    
    return available
```

---

## Real-World Scenarios

### Scenario 1: High-Traffic Event Booking

```python
# Flash sale scenario
def handle_flash_sale_booking(event_id, seat_ids, user_id):
    """
    Handle high-traffic booking with queue
    """
    # Add to queue first
    queue.publish('booking_requests', {
        'event_id': event_id,
        'seat_ids': seat_ids,
        'user_id': user_id
    })
    
    # Return immediately
    return {'status': 'queued', 'message': 'Your request is being processed'}

# Consumer processes sequentially
def process_booking_queue():
    while True:
        message = queue.consume('booking_requests')
        if message:
            try:
                # Now use two-phase booking
                result = booking_system.lock_seats(
                    event_id=message['event_id'],
                    seat_ids=message['seat_ids'],
                    user_id=message['user_id']
                )
                # Notify user
                notify_user(message['user_id'], result)
            except Exception as e:
                notify_user(message['user_id'], {'error': str(e)})
```

### Scenario 2: Group Bookings

```python
def book_group_seats(event_id, seat_groups, user_id):
    """
    Book multiple groups of seats (e.g., family wants to sit together)
    """
    all_seat_ids = [seat for group in seat_groups for seat in group]
    
    # Try to lock all seats
    try:
        result = booking_system.lock_seats(
            event_id=event_id,
            seat_ids=all_seat_ids,
            user_id=user_id
        )
        return result
    except SeatUnavailableError:
        # Try alternative groups
        for alternative_group in generate_alternatives(seat_groups):
            try:
                return booking_system.lock_seats(
                    event_id=event_id,
                    seat_ids=alternative_group,
                    user_id=user_id
                )
            except SeatUnavailableError:
                continue
        
        raise NoSeatsAvailableError()
```

---

## Best Practices

### 1. Lock Naming Convention

```python
# Good: Descriptive and unique
lock_key = f"lock:event:{event_id}:seat:{seat_id}"
lock_key = f"lock:inventory:product:{product_id}:warehouse:{warehouse_id}"

# Bad: Ambiguous
lock_key = f"lock:{id}"  # What is this locking?
```

### 2. Lock Duration

```python
# Good: Appropriate duration
LOCK_DURATION = {
    'seat_booking': 15 * 60,  # 15 minutes
    'payment_processing': 5 * 60,  # 5 minutes
    'inventory_reservation': 10 * 60,  # 10 minutes
}
```

### 3. Error Handling

```python
# Always cleanup on error
try:
    locks = acquire_locks(seat_ids)
    # ... process ...
except Exception as e:
    release_locks(locks)  # Always cleanup
    raise
```

### 4. Monitoring

```python
class LockMetrics:
    def track_lock_acquisition(self, success, duration):
        metrics.histogram('lock.acquisition.duration', duration)
        metrics.increment('lock.acquisition', tags={'success': success})
    
    def track_lock_conflicts(self):
        metrics.increment('lock.conflicts')
    
    def track_expired_locks(self):
        metrics.increment('lock.expired')
```

### 5. Testing

```python
def test_concurrent_booking():
    """Test concurrent booking attempts"""
    import threading
    
    results = []
    errors = []
    
    def attempt_booking(seat_id):
        try:
            result = booking_system.lock_seats(
                event_id='test-event',
                seat_ids=[seat_id],
                user_id=f'user-{threading.current_thread().ident}'
            )
            results.append(result)
        except Exception as e:
            errors.append(e)
    
    # Create 10 threads trying to book same seat
    threads = []
    for i in range(10):
        thread = threading.Thread(target=attempt_booking, args=('S1',))
        threads.append(thread)
        thread.start()
    
    for thread in threads:
        thread.join()
    
    # Only one should succeed
    assert len(results) == 1
    assert len(errors) == 9
```

---

## Summary

Two-Phase Booking with Distributed Locks provides:

1. **Scalability**: Works across multiple servers
2. **Reliability**: Prevents double booking
3. **User Experience**: Reserve before payment
4. **Flexibility**: Lock expiration and cleanup
5. **Performance**: Fast in-memory locking

Key takeaways:
- **Phase 1**: Lock resources temporarily
- **Phase 2**: Confirm after payment
- **Distributed Locks**: Coordinate across servers
- **Cleanup**: Automatic expiration handling
- **Error Handling**: Always cleanup on failure

This pattern is ideal for:
- Ticket booking systems
- E-commerce inventory
- Resource reservations
- Any system requiring temporary holds

