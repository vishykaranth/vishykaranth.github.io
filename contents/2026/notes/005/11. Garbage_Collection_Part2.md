# Garbage Collection: Tuning, GC Logs, and Practical Examples - Part 2

## Overview

This document covers advanced GC tuning strategies, comprehensive GC log analysis, troubleshooting common GC issues, and practical examples for optimizing Java applications.

---

## 1. GC Tuning Fundamentals

### 1.1 Tuning Goals

**Primary Objectives**:
1. **Minimize Pause Times**: Reduce stop-the-world pauses
2. **Maximize Throughput**: Maximize application processing time
3. **Minimize Memory Footprint**: Use memory efficiently
4. **Predictable Performance**: Consistent behavior under load

**Trade-offs**:
- Lower pause times may reduce throughput
- Higher throughput may increase pause times
- More memory may improve performance but increase cost
- Tuning is application-specific

### 1.2 Tuning Process

```
┌─────────────────────────────────────────────────────────────┐
│                    GC Tuning Workflow                       │
└─────────────────────────────────────────────────────────────┘

1. Baseline Measurement
   ├── Enable GC logging
   ├── Run under production-like load
   └── Collect metrics (pause times, throughput, heap usage)

2. Identify Issues
   ├── Analyze GC logs
   ├── Identify bottlenecks
   └── Set tuning goals

3. Apply Tuning
   ├── Adjust heap size
   ├── Tune GC-specific parameters
   └── Optimize application code

4. Validate
   ├── Measure improvements
   ├── Verify goals met
   └── Iterate if needed
```

### 1.3 Key Metrics to Monitor

**GC Metrics**:
- **Pause Time**: Time application is stopped
- **GC Frequency**: How often GC runs
- **Throughput**: Percentage of time spent in application vs GC
- **Heap Usage**: Memory utilization patterns
- **Allocation Rate**: Rate of object creation

**Application Metrics**:
- **Response Time**: Request latency
- **Throughput**: Requests per second
- **Error Rate**: Failed requests
- **Memory Leaks**: Growing heap usage

---

## 2. Heap Size Tuning

### 2.1 Initial and Maximum Heap Size

```bash
# Set initial and maximum heap size
-Xms4g -Xmx4g

# Best Practice: Set them equal to avoid heap resizing
-Xms8g -Xmx8g
```

**Guidelines**:
- **Initial Heap (-Xms)**: Set equal to maximum heap to avoid resizing overhead
- **Maximum Heap (-Xmx)**: 
  - Should be 25-50% of available RAM
  - Leave room for OS and other processes
  - Consider container limits in containerized environments

**Example Calculation**:
```bash
# Server with 32GB RAM
# - Reserve 4GB for OS
# - Reserve 4GB for other processes
# - Available for JVM: 24GB
# - Recommended: 12-16GB (50-66% of available)

java -Xms16g -Xmx16g -jar application.jar
```

### 2.2 Young Generation Sizing

#### G1 GC Young Generation

```bash
# Minimum young generation size (default: 5% of heap)
-XX:G1NewSizePercent=10

# Maximum young generation size (default: 60% of heap)
-XX:G1MaxNewSizePercent=40

# Example: For 8GB heap
# - Min young: 800MB (10%)
# - Max young: 3.2GB (40%)
```

**Tuning Guidelines**:
- **Larger Young Generation**: 
  - Fewer minor GCs
  - Longer minor GC pause times
  - Better for high allocation rates

- **Smaller Young Generation**:
  - More frequent minor GCs
  - Shorter minor GC pause times
  - Better for low allocation rates

#### Parallel GC Young Generation

```bash
# Ratio of young to old generation (default: NewRatio=2, means 1:2)
-XX:NewRatio=2

# Fixed size for young generation
-XX:NewSize=1g
-XX:MaxNewSize=2g

# Example: For 6GB heap with NewRatio=2
# - Young: 2GB
# - Old: 4GB
```

### 2.3 Metaspace Sizing

```bash
# Initial metaspace size (default: platform-dependent)
-XX:MetaspaceSize=256m

# Maximum metaspace size (default: unlimited)
-XX:MaxMetaspaceSize=512m

# Example: For applications with many classes
java -XX:MetaspaceSize=512m -XX:MaxMetaspaceSize=1g -jar application.jar
```

**Tuning Guidelines**:
- Monitor metaspace usage
- Set MaxMetaspaceSize to prevent unlimited growth
- Increase if seeing frequent metaspace GCs

---

## 3. GC-Specific Tuning

### 3.1 G1 GC Tuning

#### Pause Time Goals

```bash
# Target maximum pause time (default: 200ms)
-XX:MaxGCPauseMillis=100

# Example: For low-latency applications
java -XX:+UseG1GC -XX:MaxGCPauseMillis=50 -jar application.jar
```

**Impact**:
- Lower pause time goal → More frequent GCs
- Higher pause time goal → Less frequent GCs, longer pauses

#### Concurrent Marking Threshold

```bash
# Heap occupancy threshold to start concurrent marking (default: 45%)
-XX:InitiatingHeapOccupancyPercent=35

# Example: Start marking earlier to avoid full GCs
java -XX:+UseG1GC -XX:InitiatingHeapOccupancyPercent=30 -jar application.jar
```

**Tuning Guidelines**:
- **Lower Threshold (30-35%)**: 
  - Start marking earlier
  - More frequent marking cycles
  - Reduces risk of full GC

- **Higher Threshold (45-50%)**:
  - Start marking later
  - Less frequent marking cycles
  - May risk full GC if marking doesn't complete in time

#### Region Size

```bash
# Region size: 1MB to 32MB, must be power of 2 (default: heap_size / 2048)
-XX:G1HeapRegionSize=16m

# Example: For 16GB heap
# - Default region size: 8MB (16GB / 2048)
# - Custom: 16MB for larger objects
java -XX:+UseG1GC -XX:G1HeapRegionSize=16m -jar application.jar
```

**Tuning Guidelines**:
- **Larger Regions**: 
  - Fewer regions to manage
  - Better for large objects
  - Less fine-grained control

- **Smaller Regions**:
  - More regions to manage
  - Better for small objects
  - More fine-grained control

#### Complete G1 Tuning Example

```bash
# Production G1 Configuration
java -Xms16g -Xmx16g \
     -XX:+UseG1GC \
     -XX:MaxGCPauseMillis=100 \
     -XX:G1HeapRegionSize=16m \
     -XX:G1NewSizePercent=20 \
     -XX:G1MaxNewSizePercent=40 \
     -XX:InitiatingHeapOccupancyPercent=35 \
     -XX:G1ReservePercent=25 \
     -XX:ConcGCThreads=4 \
     -XX:ParallelGCThreads=8 \
     -XX:+UseStringDeduplication \
     -XX:+ParallelRefProcEnabled \
     -XX:+HeapDumpOnOutOfMemoryError \
     -XX:HeapDumpPath=/var/log/heapdump.hprof \
     -Xlog:gc*:file=/var/log/gc.log:time,level,tags:filecount=10,filesize=100M \
     -jar application.jar
```

### 3.2 ZGC Tuning

#### Concurrent GC Threads

```bash
# Number of concurrent GC threads (default: 12.5% of CPUs)
-XX:ConcGCThreads=4

# Example: For 16-core system
# - Default: 2 threads (16 * 0.125)
# - Custom: 4 threads for faster marking
java -XX:+UseZGC -XX:ConcGCThreads=4 -jar application.jar
```

#### Allocation Spike Tolerance

```bash
# Tolerance for allocation spikes (default: 2.0)
-XX:ZAllocationSpikeTolerance=2.0

# Example: More aggressive allocation
java -XX:+UseZGC -XX:ZAllocationSpikeTolerance=1.5 -jar application.jar
```

**Tuning Guidelines**:
- **Lower Tolerance (1.0-1.5)**: 
  - More aggressive allocation
  - May trigger GC more frequently
  - Better for steady allocation rates

- **Higher Tolerance (2.0-3.0)**:
  - Less aggressive allocation
  - May delay GC
  - Better for spiky allocation patterns

#### Complete ZGC Tuning Example

```bash
# Production ZGC Configuration
java -Xms32g -Xmx32g \
     -XX:+UseZGC \
     -XX:+UseNUMA \
     -XX:ConcGCThreads=4 \
     -XX:ZAllocationSpikeTolerance=2.0 \
     -XX:+UnlockExperimentalVMOptions \
     -XX:+UseZGCUncommit \
     -XX:+HeapDumpOnOutOfMemoryError \
     -XX:HeapDumpPath=/var/log/heapdump.hprof \
     -Xlog:gc*:file=/var/log/zgc.log:time,level,tags:filecount=10,filesize=100M \
     -jar application.jar
```

### 3.3 Shenandoah Tuning

#### Pause Time Interval

```bash
# Target pause time interval in milliseconds (default: 10ms)
-XX:ShenandoahGCPauseInterval=10

# Example: For ultra-low latency
java -XX:+UseShenandoahGC -XX:ShenandoahGCPauseInterval=5 -jar application.jar
```

#### Evacuation Reserve

```bash
# Percentage of heap reserved for evacuation (default: 5%)
-XX:ShenandoahEvacReserve=5

# Example: Increase reserve for high allocation rates
java -XX:+UseShenandoahGC -XX:ShenandoahEvacReserve=10 -jar application.jar
```

#### Complete Shenandoah Tuning Example

```bash
# Production Shenandoah Configuration
java -Xms8g -Xmx8g \
     -XX:+UseShenandoahGC \
     -XX:ParallelGCThreads=8 \
     -XX:ConcGCThreads=2 \
     -XX:ShenandoahGCPauseInterval=10 \
     -XX:ShenandoahEvacReserve=5 \
     -XX:+UseStringDeduplication \
     -XX:+UnlockExperimentalVMOptions \
     -XX:+UseShenandoahUncommit \
     -XX:+HeapDumpOnOutOfMemoryError \
     -XX:HeapDumpPath=/var/log/heapdump.hprof \
     -Xlog:gc*:file=/var/log/shenandoah.log:time,level,tags:filecount=10,filesize=100M \
     -jar application.jar
```

---

## 4. GC Logging and Analysis

### 4.1 Enabling GC Logging

#### Java 8 and Earlier

```bash
# Basic GC logging
-XX:+PrintGC
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
-Xloggc:/var/log/gc.log

# With rotation
-XX:+PrintGC
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
-Xloggc:/var/log/gc-%t.log
-XX:+UseGCLogFileRotation
-XX:NumberOfGCLogFiles=10
-XX:GCLogFileSize=100M
```

#### Java 9+ Unified Logging (Recommended)

```bash
# Basic unified logging
-Xlog:gc:file=/var/log/gc.log:time,level,tags

# Comprehensive GC logging
-Xlog:gc*:file=/var/log/gc.log:time,level,tags:filecount=10,filesize=100M

# Separate files for different GC events
-Xlog:gc:file=/var/log/gc.log:time,level,tags
-Xlog:gc+heap:file=/var/log/gc-heap.log:time,level,tags
-Xlog:gc+phases:file=/var/log/gc-phases.log:time,level,tags
```

#### Complete Logging Configuration

```bash
# Production GC logging configuration
-Xlog:gc*:file=/var/log/gc-%t.log:time,level,tags:filecount=10,filesize=100M \
-Xlog:safepoint:file=/var/log/safepoint-%t.log:time,level,tags:filecount=10,filesize=100M \
-Xlog:gc+heap:file=/var/log/gc-heap-%t.log:time,level,tags:filecount=10,filesize=100M
```

### 4.2 GC Log Analysis Tools

#### GCViewer

```bash
# Download GCViewer
wget https://github.com/chewiebug/GCViewer/releases/download/1.36/GCViewer-1.36.jar

# Analyze GC log
java -jar GCViewer-1.36.jar /var/log/gc.log
```

**Features**:
- Visual GC timeline
- Pause time statistics
- Throughput analysis
- Heap usage graphs
- GC event summary

#### gceasy.io

```bash
# Upload GC log to gceasy.io for analysis
# Provides:
# - Heap usage trends
# - GC pause time analysis
# - Memory leak detection
# - Recommendations
```

#### Command-Line Analysis

```bash
# Count GC events
grep -c "GC(" /var/log/gc.log

# Extract pause times
grep "Pause" /var/log/gc.log | awk '{print $NF}'

# Calculate average pause time
grep "Pause" /var/log/gc.log | awk '{sum+=$NF; count++} END {print sum/count "ms"}'

# Find longest pause
grep "Pause" /var/log/gc.log | awk '{print $NF}' | sort -n | tail -1
```

### 4.3 Analyzing G1 GC Logs

#### Sample G1 GC Log

```
[2024-01-15T10:30:00.123+0000][info][gc,start] GC(0) Pause Young (Normal) (G1 Evacuation Pause)
[2024-01-15T10:30:00.123+0000][info][gc,task] GC(0) Using 8 workers of 8 for evacuation
[2024-01-15T10:30:00.145+0000][info][gc,phases] GC(0)   Pre Evacuate Collection Set: 0.1ms
[2024-01-15T10:30:00.145+0000][info][gc,phases] GC(0)   Evacuate Collection Set: 20.5ms
[2024-01-15T10:30:00.145+0000][info][gc,phases] GC(0)   Post Evacuate Collection Set: 0.3ms
[2024-01-15T10:30:00.145+0000][info][gc,phases] GC(0)   Other: 0.8ms
[2024-01-15T10:30:00.145+0000][info][gc,heap] GC(0) Eden regions: 24->0(30)
[2024-01-15T10:30:00.145+0000][info][gc,heap] GC(0) Survivor regions: 0->3(3)
[2024-01-15T10:30:00.145+0000][info][gc,heap] GC(0) Old regions: 10->15
[2024-01-15T10:30:00.145+0000][info][gc,heap] GC(0) Humongous regions: 0->0
[2024-01-15T10:30:00.145+0000][info][gc,metaspace] GC(0) Metaspace: 5120K->5120K(1056768K)
[2024-01-15T10:30:00.145+0000][info][gc] GC(0) Pause Young (Normal) (G1 Evacuation Pause) 768M->256M(2G) 21.7ms
[2024-01-15T10:30:00.145+0000][info][gc,cpu] GC(0) User=0.16s Sys=0.01s Real=0.02s
```

**Key Metrics**:
- **Pause Time**: 21.7ms
- **Heap Before/After**: 768M->256M
- **Eden Regions**: 24->0 (cleared)
- **Survivor Regions**: 0->3 (created)
- **Old Regions**: 10->15 (promoted)

#### Concurrent Marking Log

```
[2024-01-15T10:35:00.123+0000][info][gc,start] GC(1) Pause Initial Mark (G1 Evacuation Pause)
[2024-01-15T10:35:00.145+0000][info][gc] GC(1) Pause Initial Mark (G1 Evacuation Pause) 768M->256M(2G) 22.0ms
[2024-01-15T10:35:00.145+0000][info][gc,marking] GC(1) Concurrent Mark Cycle
[2024-01-15T10:35:00.200+0000][info][gc,marking] GC(1) Concurrent Clear Claimed Marks
[2024-01-15T10:35:00.250+0000][info][gc,marking] GC(1) Concurrent Scan Root Regions
[2024-01-15T10:35:00.400+0000][info][gc,marking] GC(1) Concurrent Mark (150ms)
[2024-01-15T10:35:00.420+0000][info][gc,marking] GC(1) Concurrent Mark From Roots
[2024-01-15T10:35:00.450+0000][info][gc,marking] GC(1) Concurrent Preclean
[2024-01-15T10:35:00.470+0000][info][gc,marking] GC(1) Concurrent Mark (continue)
[2024-01-15T10:35:00.500+0000][info][gc,start] GC(1) Pause Remark
[2024-01-15T10:35:00.520+0000][info][gc] GC(1) Pause Remark 512M->512M(2G) 20.0ms
[2024-01-15T10:35:00.520+0000][info][gc,marking] GC(1) Concurrent Mark (continue)
[2024-01-15T10:35:00.550+0000][info][gc,marking] GC(1) Concurrent Rebuild Remembered Sets
[2024-01-15T10:35:00.600+0000][info][gc,start] GC(1) Pause Cleanup
[2024-01-15T10:35:00.610+0000][info][gc] GC(1) Pause Cleanup 512M->512M(2G) 10.0ms
[2024-01-15T10:35:00.610+0000][info][gc,marking] GC(1) Concurrent Mark Cycle 485.0ms
```

**Key Metrics**:
- **Initial Mark Pause**: 22.0ms
- **Concurrent Mark**: 150ms (concurrent)
- **Remark Pause**: 20.0ms
- **Cleanup Pause**: 10.0ms
- **Total Concurrent Time**: 485.0ms
- **Total STW Time**: 52.0ms

### 4.4 Analyzing ZGC Logs

#### Sample ZGC Log

```
[2024-01-15T10:30:00.123+0000][info][gc,start] GC(0) G1(0) Pause Mark Start
[2024-01-15T10:30:00.123+0000][info][gc,phases] GC(0) G1(0) Pause Mark Start 0.234ms
[2024-01-15T10:30:00.200+0000][info][gc,marking] GC(0) G1(0) Concurrent Mark 76.543ms
[2024-01-15T10:30:00.201+0000][info][gc,phases] GC(0) G1(0) Pause Mark End 0.456ms
[2024-01-15T10:30:00.201+0000][info][gc,reloc] GC(0) G1(0) Concurrent Relocate Start
[2024-01-15T10:30:00.250+0000][info][gc,reloc] GC(0) G1(0) Concurrent Relocate 48.234ms
[2024-01-15T10:30:00.251+0000][info][gc,heap] GC(0) G1(0) Heap: 8192M(100%)->4096M(50%)
[2024-01-15T10:30:00.251+0000][info][gc,stats] GC(0) G1(0) Pause Mark Start: 0.234ms
[2024-01-15T10:30:00.251+0000][info][gc,stats] GC(0) G1(0) Pause Mark End: 0.456ms
[2024-01-15T10:30:00.251+0000][info][gc,stats] GC(0) G1(0) Concurrent Mark: 76.543ms
[2024-01-15T10:30:00.251+0000][info][gc,stats] GC(0) G1(0) Concurrent Relocate: 48.234ms
```

**Key Metrics**:
- **Pause Mark Start**: 0.234ms (ultra-low)
- **Pause Mark End**: 0.456ms (ultra-low)
- **Concurrent Mark**: 76.543ms (concurrent)
- **Concurrent Relocate**: 48.234ms (concurrent)
- **Total STW Time**: < 1ms
- **Heap Reduction**: 8192M->4096M

### 4.5 Analyzing Shenandoah Logs

#### Sample Shenandoah Log

```
[2024-01-15T10:30:00.123+0000][info][gc,start] GC(0) Pause Init Mark
[2024-01-15T10:30:00.133+0000][info][gc] GC(0) Pause Init Mark 8192M->8192M(8192M) 10.234ms
[2024-01-15T10:30:00.200+0000][info][gc,marking] GC(0) Concurrent marking 66.543ms
[2024-01-15T10:30:00.201+0000][info][gc,start] GC(0) Pause Final Mark
[2024-01-15T10:30:00.211+0000][info][gc] GC(0) Pause Final Mark 8192M->4096M(8192M) 10.456ms
[2024-01-15T10:30:00.211+0000][info][gc,start] GC(0) Concurrent evacuation
[2024-01-15T10:30:00.300+0000][info][gc,evacuation] GC(0) Concurrent evacuation 88.234ms
[2024-01-15T10:30:00.301+0000][info][gc,start] GC(0) Pause Init Update Refs
[2024-01-15T10:30:00.311+0000][info][gc] GC(0) Pause Init Update Refs 4096M->4096M(8192M) 10.123ms
[2024-01-15T10:30:00.400+0000][info][gc,refs] GC(0) Concurrent update references 88.456ms
[2024-01-15T10:30:00.401+0000][info][gc,start] GC(0) Pause Final Update Refs
[2024-01-15T10:30:00.411+0000][info][gc] GC(0) Pause Final Update Refs 4096M->4096M(8192M) 10.234ms
```

**Key Metrics**:
- **Pause Init Mark**: 10.234ms
- **Concurrent Marking**: 66.543ms (concurrent)
- **Pause Final Mark**: 10.456ms
- **Concurrent Evacuation**: 88.234ms (concurrent)
- **Pause Init Update Refs**: 10.123ms
- **Concurrent Update Refs**: 88.456ms (concurrent)
- **Pause Final Update Refs**: 10.234ms
- **Total STW Time**: ~40ms
- **Total Concurrent Time**: ~243ms

---

## 5. Common GC Issues and Solutions

### 5.1 High Pause Times

#### Symptoms

```
[2024-01-15T10:30:00.123+0000][info][gc] GC(0) Pause Young (Normal) 768M->256M(2G) 500.0ms
```

**Problem**: Pause time (500ms) exceeds target (100ms)

#### Solutions

**G1 GC**:
```bash
# Reduce pause time goal
-XX:MaxGCPauseMillis=50

# Increase young generation size
-XX:G1MaxNewSizePercent=50

# Start concurrent marking earlier
-XX:InitiatingHeapOccupancyPercent=30
```

**ZGC/Shenandoah**:
```bash
# Increase concurrent GC threads
-XX:ConcGCThreads=8

# Check for allocation spikes
# Reduce object allocation rate in application
```

### 5.2 Frequent GCs

#### Symptoms

```
# GC runs every few seconds
[2024-01-15T10:30:00.123+0000][info][gc] GC(0) ...
[2024-01-15T10:30:05.456+0000][info][gc] GC(1) ...
[2024-01-15T10:30:10.789+0000][info][gc] GC(2) ...
```

**Problem**: High allocation rate causing frequent GCs

#### Solutions

```bash
# Increase heap size
-Xms8g -Xmx8g

# Increase young generation size
-XX:G1MaxNewSizePercent=50

# Optimize application code
# - Reduce object creation
# - Reuse objects
# - Use object pooling
```

### 5.3 Full GC Occurrences

#### Symptoms

```
[2024-01-15T10:30:00.123+0000][info][gc] GC(0) Pause Full (Allocation Failure) 4096M->2048M(8G) 2000.0ms
```

**Problem**: Full GC indicates heap pressure or concurrent marking not completing

#### Solutions

**G1 GC**:
```bash
# Start concurrent marking earlier
-XX:InitiatingHeapOccupancyPercent=30

# Increase heap size
-Xms8g -Xmx8g

# Increase concurrent marking threads
-XX:ConcGCThreads=4
```

**ZGC/Shenandoah**:
```bash
# Full GCs should be rare
# If occurring, check:
# - Heap size too small
# - Allocation rate too high
# - Memory leaks
```

### 5.4 Memory Leaks

#### Symptoms

```
# Heap usage continuously growing
[2024-01-15T10:30:00.123+0000][info][gc,heap] GC(0) Heap: 4G->3G(8G)
[2024-01-15T10:35:00.456+0000][info][gc,heap] GC(10) Heap: 5G->4G(8G)
[2024-01-15T10:40:00.789+0000][info][gc,heap] GC(20) Heap: 6G->5G(8G)
[2024-01-15T10:45:00.123+0000][info][gc,heap] GC(30) Heap: 7G->6G(8G)
```

**Problem**: Heap usage growing over time, indicating memory leak

#### Solutions

```bash
# Enable heap dumps on OOM
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/var/log/heapdump.hprof

# Analyze heap dump
# - Use Eclipse MAT (Memory Analyzer Tool)
# - Use jhat (Java Heap Analysis Tool)
# - Identify leaking objects

# Fix application code
# - Close resources properly
# - Remove references from collections
# - Fix listener/callback registrations
```

### 5.5 High GC Overhead

#### Symptoms

```
# GC taking significant percentage of time
# Throughput < 90%
```

**Problem**: Too much time spent in GC, reducing application throughput

#### Solutions

```bash
# Increase heap size
-Xms16g -Xmx16g

# Tune GC algorithm
# - Use G1 for balanced performance
# - Use ZGC/Shenandoah for low latency

# Optimize application
# - Reduce allocation rate
# - Use object pooling
# - Optimize data structures
```

---

## 6. Practical Tuning Examples

### 6.1 Web Application (REST API)

**Requirements**:
- Low latency (< 100ms response time)
- High throughput (1000+ req/s)
- 8GB heap
- Java 17

**Configuration**:

```bash
java -Xms8g -Xmx8g \
     -XX:+UseG1GC \
     -XX:MaxGCPauseMillis=100 \
     -XX:G1HeapRegionSize=16m \
     -XX:G1NewSizePercent=20 \
     -XX:G1MaxNewSizePercent=40 \
     -XX:InitiatingHeapOccupancyPercent=35 \
     -XX:ConcGCThreads=4 \
     -XX:ParallelGCThreads=8 \
     -XX:+UseStringDeduplication \
     -XX:+ParallelRefProcEnabled \
     -Xlog:gc*:file=/var/log/gc.log:time,level,tags:filecount=10,filesize=100M \
     -jar webapp.jar
```

**Expected Results**:
- Pause times: 50-100ms
- Throughput: > 95%
- GC frequency: Every 30-60 seconds

### 6.2 Real-Time Processing (Low Latency)

**Requirements**:
- Ultra-low latency (< 10ms pauses)
- 16GB heap
- Java 17

**Configuration**:

```bash
java -Xms16g -Xmx16g \
     -XX:+UseZGC \
     -XX:+UseNUMA \
     -XX:ConcGCThreads=4 \
     -XX:ZAllocationSpikeTolerance=2.0 \
     -XX:+UnlockExperimentalVMOptions \
     -XX:+UseZGCUncommit \
     -Xlog:gc*:file=/var/log/zgc.log:time,level,tags:filecount=10,filesize=100M \
     -jar realtime-app.jar
```

**Expected Results**:
- Pause times: < 10ms
- Throughput: > 98%
- GC frequency: Every 1-2 minutes

### 6.3 Batch Processing (High Throughput)

**Requirements**:
- Maximum throughput
- Acceptable pause times (< 500ms)
- 32GB heap
- Java 17

**Configuration**:

```bash
java -Xms32g -Xmx32g \
     -XX:+UseG1GC \
     -XX:MaxGCPauseMillis=500 \
     -XX:G1HeapRegionSize=32m \
     -XX:G1NewSizePercent=10 \
     -XX:G1MaxNewSizePercent=30 \
     -XX:InitiatingHeapOccupancyPercent=45 \
     -XX:ConcGCThreads=8 \
     -XX:ParallelGCThreads=16 \
     -XX:+UseStringDeduplication \
     -Xlog:gc*:file=/var/log/gc.log:time,level,tags:filecount=10,filesize=100M \
     -jar batch-app.jar
```

**Expected Results**:
- Pause times: 200-500ms
- Throughput: > 99%
- GC frequency: Every 2-5 minutes

### 6.4 Microservices (Containerized)

**Requirements**:
- Container memory limit: 2GB
- Low latency
- Java 17

**Configuration**:

```bash
java -Xms2g -Xmx2g \
     -XX:+UseG1GC \
     -XX:MaxGCPauseMillis=100 \
     -XX:G1HeapRegionSize=4m \
     -XX:G1NewSizePercent=30 \
     -XX:G1MaxNewSizePercent=50 \
     -XX:InitiatingHeapOccupancyPercent=40 \
     -XX:ConcGCThreads=2 \
     -XX:ParallelGCThreads=4 \
     -XX:+UseContainerSupport \
     -XX:MaxRAMPercentage=75.0 \
     -Xlog:gc*:file=/var/log/gc.log:time,level,tags:filecount=5,filesize=50M \
     -jar microservice.jar
```

**Key Points**:
- `-XX:+UseContainerSupport`: Respect container limits
- `-XX:MaxRAMPercentage=75.0`: Use 75% of container memory
- Smaller region size for smaller heap

---

## 7. GC Monitoring and Alerting

### 7.1 JMX Monitoring

```java
import java.lang.management.GarbageCollectorMXBean;
import java.lang.management.ManagementFactory;
import java.util.List;

public class GCMonitor {
    public static void monitorGC() {
        List<GarbageCollectorMXBean> gcBeans = 
            ManagementFactory.getGarbageCollectorMXBeans();
        
        for (GarbageCollectorMXBean gcBean : gcBeans) {
            System.out.println("GC Name: " + gcBean.getName());
            System.out.println("Collection Count: " + gcBean.getCollectionCount());
            System.out.println("Collection Time: " + gcBean.getCollectionTime() + "ms");
        }
    }
}
```

### 7.2 Prometheus Metrics

```bash
# Enable Prometheus JMX exporter
java -javaagent:jmx_prometheus_javaagent-0.19.0.jar=8080:config.yml \
     -jar application.jar
```

**config.yml**:
```yaml
rules:
  - pattern: 'java.lang<type=GarbageCollector, name=(.+)><>CollectionCount'
    name: 'jvm_gc_collection_count'
    labels:
      gc: '$1'
  - pattern: 'java.lang<type=GarbageCollector, name=(.+)><>CollectionTime'
    name: 'jvm_gc_collection_time_seconds'
    labels:
      gc: '$1'
    value: 0.001
```

### 7.3 Alerting Rules

```yaml
# Prometheus alerting rules
groups:
  - name: gc_alerts
    rules:
      - alert: HighGCPauseTime
        expr: jvm_gc_collection_time_seconds > 1
        for: 5m
        annotations:
          summary: "GC pause time exceeds 1 second"
      
      - alert: FrequentGC
        expr: rate(jvm_gc_collection_count[5m]) > 10
        for: 5m
        annotations:
          summary: "GC frequency exceeds 10 per minute"
      
      - alert: FullGC
        expr: increase(jvm_gc_collection_count{gc="G1 Old Generation"}[5m]) > 0
        for: 1m
        annotations:
          summary: "Full GC detected"
```

---

## 8. Best Practices

### 8.1 Heap Sizing

✅ **Do**:
- Set `-Xms` equal to `-Xmx` to avoid resizing
- Leave 25-50% of RAM for OS and other processes
- Monitor heap usage and adjust accordingly
- Use container memory limits in containerized environments

❌ **Don't**:
- Set heap too large (causes long GC pauses)
- Set heap too small (causes frequent GCs)
- Ignore container memory limits

### 8.2 GC Algorithm Selection

✅ **Do**:
- Use G1 for balanced workloads (Java 9+)
- Use ZGC for ultra-low latency (Java 15+)
- Use Shenandoah for low latency with concurrent evacuation (Java 15+)
- Test different algorithms for your workload

❌ **Don't**:
- Use Serial GC in production (too slow)
- Use Parallel GC for low-latency applications
- Switch GC algorithms without testing

### 8.3 GC Logging

✅ **Do**:
- Enable GC logging in production
- Use log rotation to prevent disk space issues
- Analyze GC logs regularly
- Monitor GC metrics via JMX/Prometheus

❌ **Don't**:
- Disable GC logging in production
- Let GC logs grow unbounded
- Ignore GC log warnings

### 8.4 Application Optimization

✅ **Do**:
- Reduce object allocation rate
- Reuse objects where possible
- Use object pooling for frequently created objects
- Close resources properly
- Remove references from collections

❌ **Don't**:
- Create unnecessary objects
- Hold references to large objects unnecessarily
- Ignore memory leaks
- Allocate objects in hot paths

---

## Summary

**GC Tuning**:
- Start with heap sizing
- Tune GC-specific parameters
- Monitor and iterate
- Application optimization is crucial

**GC Log Analysis**:
- Enable comprehensive logging
- Use analysis tools (GCViewer, gceasy.io)
- Monitor key metrics (pause times, frequency, throughput)
- Identify and fix issues proactively

**Best Practices**:
- Set `-Xms` equal to `-Xmx`
- Choose appropriate GC algorithm
- Enable GC logging
- Optimize application code
- Monitor and alert on GC metrics

Effective GC tuning requires understanding your application's behavior, monitoring GC metrics, and iteratively optimizing both GC settings and application code.

