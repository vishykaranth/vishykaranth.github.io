# Reactive Programming: Part 1 - Fundamentals, Reactive Streams, and RxJava

## Table of Contents
1. [Introduction to Reactive Programming](#introduction-to-reactive-programming)
2. [Reactive Streams Specification](#reactive-streams-specification)
3. [RxJava Deep Dive](#rxjava-deep-dive)
4. [RxJava Operators](#rxjava-operators)
5. [RxJava Error Handling](#rxjava-error-handling)
6. [RxJava Schedulers](#rxjava-schedulers)

---

## Introduction to Reactive Programming

### What is Reactive Programming?

**Reactive Programming** is a programming paradigm focused on asynchronous data streams and the propagation of change. It's about building systems that are:
- **Responsive**: React to events in a timely manner
- **Resilient**: Handle failures gracefully
- **Elastic**: Scale up and down based on load
- **Message-Driven**: Components communicate through messages

### Core Concepts

#### 1. Data Streams
Everything is a stream: user events, HTTP requests, database queries, file I/O, etc.

```
Traditional (Pull-based):
User → Request → Wait → Response

Reactive (Push-based):
User → Request → Subscribe → Stream of Events
```

#### 2. Observables and Observers

**Observable (Publisher)**: Source of data/events
**Observer (Subscriber)**: Consumer of data/events

```
Observable ──[data]──> Observer
    │                      │
    └──[data]──────────────┘
    │                      │
    └──[data]──────────────┘
```

#### 3. Backpressure

**Problem**: Producer is faster than Consumer
**Solution**: Consumer controls the rate of data flow

```
Fast Producer ──[data]──> Slow Consumer
                    │
                    └──> Backpressure: "Slow down!"
```

### Why Reactive Programming?

#### Problems with Traditional Approaches

**1. Blocking I/O**
```java
// Blocking - Thread waits
String data = database.query("SELECT * FROM users");
process(data); // Thread blocked until query completes
```

**2. Callback Hell**
```java
// Nested callbacks - hard to read and maintain
asyncOperation1(result1 -> {
    asyncOperation2(result1, result2 -> {
        asyncOperation3(result2, result3 -> {
            // Deep nesting, error handling is complex
        });
    });
});
```

**3. Thread Management**
```java
// Manual thread management - error-prone
ExecutorService executor = Executors.newFixedThreadPool(10);
Future<String> future = executor.submit(() -> {
    return processData();
});
// Need to handle exceptions, timeouts, cancellation
```

#### Benefits of Reactive Programming

1. **Non-Blocking**: Threads don't wait, improving resource utilization
2. **Composable**: Chain operations easily
3. **Error Handling**: Built-in error propagation
4. **Backpressure**: Automatic flow control
5. **Declarative**: Express what, not how

---

## Reactive Streams Specification

### Overview

**Reactive Streams** is a standard (JVM specification) that defines:
- Interfaces for asynchronous stream processing
- Non-blocking backpressure
- Interoperability between libraries

**Specification**: JVM Specification (java.util.concurrent.Flow)

### Core Interfaces

#### 1. Publisher<T>

Source of data. Emits items to Subscribers.

```java
public interface Publisher<T> {
    void subscribe(Subscriber<? super T> subscriber);
}
```

**Characteristics:**
- Can have multiple subscribers
- Emits items asynchronously
- Handles backpressure through subscription

#### 2. Subscriber<T>

Consumer of data. Receives items from Publisher.

```java
public interface Subscriber<T> {
    void onSubscribe(Subscription subscription);
    void onNext(T item);
    void onError(Throwable throwable);
    void onComplete();
}
```

**Lifecycle:**
```
onSubscribe → onNext* → (onError | onComplete)
```

**Example:**
```java
Subscriber<String> subscriber = new Subscriber<String>() {
    private Subscription subscription;
    
    @Override
    public void onSubscribe(Subscription subscription) {
        this.subscription = subscription;
        subscription.request(1); // Request first item
    }
    
    @Override
    public void onNext(String item) {
        System.out.println("Received: " + item);
        subscription.request(1); // Request next item
    }
    
    @Override
    public void onError(Throwable throwable) {
        System.err.println("Error: " + throwable.getMessage());
    }
    
    @Override
    public void onComplete() {
        System.out.println("Completed!");
    }
};
```

#### 3. Subscription

Controls the flow between Publisher and Subscriber.

```java
public interface Subscription {
    void request(long n);  // Request n items
    void cancel();          // Cancel subscription
}
```

**Key Methods:**
- `request(n)`: Request n items (backpressure control)
- `cancel()`: Cancel subscription

**Example:**
```java
// Request items in batches
subscription.request(10); // Request 10 items

// Cancel if needed
subscription.cancel(); // Stop receiving items
```

#### 4. Processor<T, R>

Both Publisher and Subscriber. Transforms data.

```java
public interface Processor<T, R> extends Subscriber<T>, Publisher<R> {
    // Inherits from both Subscriber and Publisher
}
```

**Use Case**: Transform data in a pipeline
```
Publisher<String> → Processor<String, Integer> → Subscriber<Integer>
```

### Backpressure Mechanisms

#### Problem Scenario

```
Fast Publisher: 1,000,000 items/second
Slow Consumer: 100 items/second

Without backpressure: Memory overflow!
```

#### Solution: Request-Based Backpressure

```java
Subscriber<Integer> subscriber = new Subscriber<Integer>() {
    private Subscription subscription;
    private int count = 0;
    
    @Override
    public void onSubscribe(Subscription subscription) {
        this.subscription = subscription;
        subscription.request(10); // Request 10 items initially
    }
    
    @Override
    public void onNext(Integer item) {
        process(item); // Slow processing
        count++;
        
        // Request more when ready
        if (count % 10 == 0) {
            subscription.request(10); // Request next batch
        }
    }
    
    // ...
};
```

### Reactive Streams Implementations

1. **RxJava**: Reactive Extensions for Java
2. **Project Reactor**: Spring's reactive library
3. **Akka Streams**: Actor-based streams
4. **Java 9+ Flow API**: Built-in reactive streams

---

## RxJava Deep Dive

### What is RxJava?

**RxJava** is a Java implementation of Reactive Extensions (ReactiveX), a library for composing asynchronous and event-based programs using observable sequences.

**Key Features:**
- Rich set of operators
- Schedulers for concurrency
- Error handling
- Backpressure support
- Interoperability with Java 9+ Flow

### Core Types

#### 1. Observable<T>

Emits zero or more items, then completes or errors.

```java
Observable<String> observable = Observable.create(emitter -> {
    emitter.onNext("Hello");
    emitter.onNext("World");
    emitter.onComplete();
});

observable.subscribe(
    item -> System.out.println(item),      // onNext
    error -> System.err.println(error),    // onError
    () -> System.out.println("Done")       // onComplete
);
```

**Characteristics:**
- Can emit 0 to N items
- Can complete or error
- Hot or Cold (lazy or eager)
- No backpressure by default

#### 2. Single<T>

Emits exactly one item or an error.

```java
Single<String> single = Single.just("Hello");

single.subscribe(
    item -> System.out.println(item),
    error -> System.err.println(error)
);
```

**Use Cases:**
- HTTP requests (one response)
- Database queries (one result)
- File reads (one content)

#### 3. Completable

Emits only completion or error signal (no items).

```java
Completable completable = Completable.fromAction(() -> {
    System.out.println("Doing something");
});

completable.subscribe(
    () -> System.out.println("Completed"),
    error -> System.err.println(error)
);
```

**Use Cases:**
- Delete operations
- Update operations
- Void methods

#### 4. Maybe<T>

Emits zero or one item, then completes or errors.

```java
Maybe<String> maybe = Maybe.just("Hello");
// or
Maybe<String> empty = Maybe.empty();

maybe.subscribe(
    item -> System.out.println(item),
    error -> System.err.println(error),
    () -> System.out.println("Empty")
);
```

**Use Cases:**
- Optional-like scenarios
- Find operations (may or may not find)

#### 5. Flowable<T>

Observable with backpressure support.

```java
Flowable<Integer> flowable = Flowable.range(1, 1000)
    .onBackpressureBuffer(); // Handle backpressure

flowable.subscribe(
    item -> System.out.println(item),
    error -> System.err.println(error),
    () -> System.out.println("Done")
);
```

**When to Use:**
- High-volume streams
- Need backpressure control
- Producer faster than consumer

### Creating Observables

#### 1. Observable.just()

```java
Observable<String> observable = Observable.just("Hello", "World");
```

#### 2. Observable.fromIterable()

```java
List<String> list = Arrays.asList("A", "B", "C");
Observable<String> observable = Observable.fromIterable(list);
```

#### 3. Observable.range()

```java
Observable<Integer> observable = Observable.range(1, 10);
// Emits: 1, 2, 3, ..., 10
```

#### 4. Observable.interval()

```java
Observable<Long> observable = Observable.interval(1, TimeUnit.SECONDS);
// Emits: 0, 1, 2, ... every second
```

#### 5. Observable.create()

```java
Observable<String> observable = Observable.create(emitter -> {
    try {
        emitter.onNext("Item 1");
        emitter.onNext("Item 2");
        emitter.onComplete();
    } catch (Exception e) {
        emitter.onError(e);
    }
});
```

#### 6. Observable.fromCallable()

```java
Observable<String> observable = Observable.fromCallable(() -> {
    return expensiveOperation();
});
```

#### 7. Observable.defer()

```java
Observable<String> observable = Observable.defer(() -> {
    return Observable.just(getCurrentTime());
});
```

### Hot vs Cold Observables

#### Cold Observable

**Lazy**: Starts emitting only when subscribed.

```java
Observable<Integer> cold = Observable.range(1, 5)
    .doOnSubscribe(d -> System.out.println("Subscribed"));

// No output yet
cold.subscribe(i -> System.out.println("Subscriber 1: " + i));
// Output: Subscribed, Subscriber 1: 1, 2, 3, 4, 5

cold.subscribe(i -> System.out.println("Subscriber 2: " + i));
// Output: Subscribed, Subscriber 2: 1, 2, 3, 4, 5
// Each subscriber gets its own sequence
```

**Characteristics:**
- Each subscriber gets its own sequence
- Data production starts on subscription
- Example: Database queries, HTTP requests

#### Hot Observable

**Eager**: Emits regardless of subscribers.

```java
ConnectableObservable<Integer> hot = Observable.range(1, 5)
    .publish(); // Convert to hot

hot.subscribe(i -> System.out.println("Subscriber 1: " + i));
// No output yet

hot.connect(); // Start emitting
// Output: Subscriber 1: 1, 2, 3, 4, 5

hot.subscribe(i -> System.out.println("Subscriber 2: " + i));
// Subscriber 2 misses items already emitted
```

**Characteristics:**
- All subscribers share the same sequence
- Data production independent of subscribers
- Example: Mouse clicks, stock prices

**Converting Cold to Hot:**
```java
Observable<Integer> cold = Observable.range(1, 5);
ConnectableObservable<Integer> hot = cold.publish();
hot.connect(); // Start emitting
```

---

## RxJava Operators

### Transformation Operators

#### 1. map()

Transforms each item.

```java
Observable<String> source = Observable.just("hello", "world");
Observable<String> upper = source.map(String::toUpperCase);
// Result: "HELLO", "WORLD"
```

#### 2. flatMap()

Transforms each item into an Observable, then merges.

```java
Observable<String> source = Observable.just("hello", "world");
Observable<Character> chars = source.flatMap(word -> 
    Observable.fromArray(word.split(""))
        .map(s -> s.charAt(0))
);
// Result: 'h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd'
```

#### 3. concatMap()

Like flatMap, but preserves order.

```java
Observable<String> source = Observable.just("hello", "world");
Observable<Character> chars = source.concatMap(word -> 
    Observable.fromArray(word.split(""))
        .map(s -> s.charAt(0))
);
// Result: 'h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd'
// Order preserved (unlike flatMap which may interleave)
```

#### 4. switchMap()

Cancels previous inner Observable when new item arrives.

```java
Observable<String> source = Observable.just("hello", "world");
Observable<Character> chars = source.switchMap(word -> 
    Observable.fromArray(word.split(""))
        .map(s -> s.charAt(0))
        .delay(100, TimeUnit.MILLISECONDS)
);
// Only emits from the latest word
```

#### 5. scan()

Applies accumulator function to each item.

```java
Observable<Integer> numbers = Observable.just(1, 2, 3, 4, 5);
Observable<Integer> sum = numbers.scan((acc, item) -> acc + item);
// Result: 1, 3, 6, 10, 15
```

### Filtering Operators

#### 1. filter()

Filters items based on predicate.

```java
Observable<Integer> numbers = Observable.range(1, 10);
Observable<Integer> evens = numbers.filter(n -> n % 2 == 0);
// Result: 2, 4, 6, 8, 10
```

#### 2. take()

Takes first n items.

```java
Observable<Integer> numbers = Observable.range(1, 10);
Observable<Integer> first5 = numbers.take(5);
// Result: 1, 2, 3, 4, 5
```

#### 3. skip()

Skips first n items.

```java
Observable<Integer> numbers = Observable.range(1, 10);
Observable<Integer> after5 = numbers.skip(5);
// Result: 6, 7, 8, 9, 10
```

#### 4. distinct()

Removes duplicates.

```java
Observable<Integer> numbers = Observable.just(1, 2, 2, 3, 3, 3, 4);
Observable<Integer> unique = numbers.distinct();
// Result: 1, 2, 3, 4
```

#### 5. debounce()

Emits item only after specified time has passed without another emission.

```java
Observable<String> source = Observable.just("a", "b", "c")
    .delay(100, TimeUnit.MILLISECONDS);
Observable<String> debounced = source.debounce(50, TimeUnit.MILLISECONDS);
// Only emits if 50ms passes without new item
```

### Combining Operators

#### 1. merge()

Merges multiple Observables.

```java
Observable<String> obs1 = Observable.just("A", "B");
Observable<String> obs2 = Observable.just("C", "D");
Observable<String> merged = Observable.merge(obs1, obs2);
// Result: "A", "B", "C", "D" (order may vary)
```

#### 2. concat()

Concatenates Observables (preserves order).

```java
Observable<String> obs1 = Observable.just("A", "B");
Observable<String> obs2 = Observable.just("C", "D");
Observable<String> concatenated = Observable.concat(obs1, obs2);
// Result: "A", "B", "C", "D" (order preserved)
```

#### 3. zip()

Combines items from multiple Observables.

```java
Observable<String> obs1 = Observable.just("A", "B", "C");
Observable<Integer> obs2 = Observable.just(1, 2, 3);
Observable<String> zipped = Observable.zip(obs1, obs2, 
    (str, num) -> str + num
);
// Result: "A1", "B2", "C3"
```

#### 4. combineLatest()

Combines latest items from multiple Observables.

```java
Observable<String> obs1 = Observable.just("A", "B");
Observable<Integer> obs2 = Observable.just(1, 2);
Observable<String> combined = Observable.combineLatest(obs1, obs2,
    (str, num) -> str + num
);
// Result: "A1", "B1", "B2"
```

### Utility Operators

#### 1. doOnNext()

Side effect for each item.

```java
Observable<Integer> numbers = Observable.range(1, 5);
numbers.doOnNext(i -> System.out.println("Processing: " + i))
    .subscribe();
```

#### 2. delay()

Delays emissions.

```java
Observable<String> source = Observable.just("Hello");
Observable<String> delayed = source.delay(1, TimeUnit.SECONDS);
```

#### 3. timeout()

Emits error if no item within time limit.

```java
Observable<String> source = Observable.just("Hello")
    .delay(2, TimeUnit.SECONDS);
Observable<String> timed = source.timeout(1, TimeUnit.SECONDS);
// Will error if source doesn't emit within 1 second
```

#### 4. retry()

Retries on error.

```java
Observable<String> source = Observable.error(new RuntimeException());
Observable<String> retried = source.retry(3);
// Retries up to 3 times
```

---

## RxJava Error Handling

### Error Propagation

By default, errors terminate the stream.

```java
Observable<Integer> source = Observable.just(1, 2, 3)
    .map(i -> {
        if (i == 2) throw new RuntimeException("Error");
        return i;
    });

source.subscribe(
    item -> System.out.println(item),
    error -> System.out.println("Error: " + error),
    () -> System.out.println("Complete")
);
// Output: 1, Error: RuntimeException
```

### Error Handling Operators

#### 1. onErrorReturn()

Returns a default value on error.

```java
Observable<Integer> source = Observable.just(1, 2, 3)
    .map(i -> {
        if (i == 2) throw new RuntimeException("Error");
        return i;
    })
    .onErrorReturn(error -> -1);

source.subscribe(item -> System.out.println(item));
// Output: 1, -1
```

#### 2. onErrorResumeNext()

Switches to another Observable on error.

```java
Observable<Integer> source = Observable.just(1, 2, 3)
    .map(i -> {
        if (i == 2) throw new RuntimeException("Error");
        return i;
    })
    .onErrorResumeNext(Observable.just(10, 20));

source.subscribe(item -> System.out.println(item));
// Output: 1, 10, 20
```

#### 3. onErrorReturnItem()

Returns a specific item on error.

```java
Observable<Integer> source = Observable.just(1, 2, 3)
    .map(i -> {
        if (i == 2) throw new RuntimeException("Error");
        return i;
    })
    .onErrorReturnItem(-1);

source.subscribe(item -> System.out.println(item));
// Output: 1, -1
```

#### 4. retry()

Retries the entire sequence.

```java
Observable<Integer> source = Observable.just(1, 2, 3)
    .map(i -> {
        if (i == 2) throw new RuntimeException("Error");
        return i;
    })
    .retry(2);

source.subscribe(
    item -> System.out.println(item),
    error -> System.out.println("Error: " + error)
);
// Retries entire sequence up to 2 times
```

#### 5. retryWhen()

Custom retry logic.

```java
Observable<Integer> source = Observable.just(1, 2, 3)
    .map(i -> {
        if (i == 2) throw new RuntimeException("Error");
        return i;
    })
    .retryWhen(errors -> errors
        .zipWith(Observable.range(1, 3), (error, retryCount) -> retryCount)
        .flatMap(retryCount -> {
            System.out.println("Retry attempt: " + retryCount);
            return Observable.timer(retryCount, TimeUnit.SECONDS);
        })
    );
```

---

## RxJava Schedulers

### What are Schedulers?

**Schedulers** control which thread executes work.

### Types of Schedulers

#### 1. Schedulers.io()

For I/O-bound work (network, file I/O).

```java
Observable<String> source = Observable.just("Hello")
    .subscribeOn(Schedulers.io())  // Execute on IO thread
    .observeOn(AndroidSchedulers.mainThread()); // Observe on main thread
```

#### 2. Schedulers.computation()

For CPU-intensive work.

```java
Observable<Integer> source = Observable.range(1, 1000)
    .subscribeOn(Schedulers.computation())
    .map(i -> i * i); // CPU-intensive
```

#### 3. Schedulers.newThread()

Creates new thread for each subscription.

```java
Observable<String> source = Observable.just("Hello")
    .subscribeOn(Schedulers.newThread());
```

#### 4. Schedulers.single()

Single thread for all work.

```java
Observable<String> source = Observable.just("Hello")
    .subscribeOn(Schedulers.single());
```

#### 5. Schedulers.trampoline()

Executes on current thread (for testing).

```java
Observable<String> source = Observable.just("Hello")
    .subscribeOn(Schedulers.trampoline());
```

### subscribeOn() vs observeOn()

#### subscribeOn()

Specifies which thread the Observable should execute on.

```java
Observable<String> source = Observable.create(emitter -> {
    System.out.println("Thread: " + Thread.currentThread().getName());
    emitter.onNext("Hello");
    emitter.onComplete();
})
.subscribeOn(Schedulers.io());

source.subscribe();
// Output: Thread: RxCachedThreadScheduler-1
```

#### observeOn()

Specifies which thread the Observer should receive on.

```java
Observable<String> source = Observable.just("Hello")
    .observeOn(Schedulers.io())
    .doOnNext(item -> 
        System.out.println("Thread: " + Thread.currentThread().getName())
    );

source.subscribe();
// Output: Thread: RxCachedThreadScheduler-1
```

### Example: Threading in RxJava

```java
Observable<String> source = Observable.create(emitter -> {
    System.out.println("Emit on: " + Thread.currentThread().getName());
    emitter.onNext("Hello");
    emitter.onComplete();
})
.subscribeOn(Schedulers.io())  // Emit on IO thread
.observeOn(Schedulers.computation())  // Process on computation thread
.map(s -> {
    System.out.println("Map on: " + Thread.currentThread().getName());
    return s.toUpperCase();
})
.observeOn(Schedulers.newThread())  // Observe on new thread
.doOnNext(s -> 
    System.out.println("Observe on: " + Thread.currentThread().getName())
);

source.subscribe();
```

---

## Summary of Part 1

**Key Concepts Covered:**
1. ✅ Reactive Programming fundamentals
2. ✅ Reactive Streams specification (Publisher, Subscriber, Subscription, Processor)
3. ✅ Backpressure mechanisms
4. ✅ RxJava core types (Observable, Single, Completable, Maybe, Flowable)
5. ✅ Creating Observables
6. ✅ Hot vs Cold Observables
7. ✅ RxJava operators (transformation, filtering, combining, utility)
8. ✅ Error handling strategies
9. ✅ Schedulers and threading

**Next in Part 2:**
- Project Reactor (Mono, Flux)
- Spring WebFlux integration
- Comparison: RxJava vs Reactor
- Advanced patterns and best practices
- Real-world examples and use cases

