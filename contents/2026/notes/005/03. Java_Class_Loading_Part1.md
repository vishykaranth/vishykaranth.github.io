# Java Class Loading - Part 1: Fundamentals and Mechanisms

## Table of Contents
1. [Basic Concepts](#basic-concepts)
2. [ClassLoader Hierarchy](#classloader-hierarchy)
3. [Class Loading Process](#class-loading-process)
4. [Built-in ClassLoaders](#built-in-classloaders)
5. [Custom ClassLoaders](#custom-classloaders)
6. [Delegation Model](#delegation-model)

---

## Basic Concepts

### Question 1: What is Class Loading in Java?

**Answer:**

Class loading is the process of finding and loading the bytecode of a class into the JVM's memory so that it can be used by the application. This happens dynamically at runtime, not at compile time.

**Key Points:**
- Classes are loaded **on-demand** (lazy loading)
- Class loading happens when a class is first referenced
- The JVM uses a **ClassLoader** to load classes
- Classes are loaded into the **Method Area** (part of heap in older JVMs, Metaspace in newer JVMs)

**Example:**
```java
// When this line executes, the JVM needs to load the String class
String name = "John";

// When this line executes, the JVM needs to load the ArrayList class
List<String> list = new ArrayList<>();
```

**Class Loading vs Class Initialization:**
- **Loading**: Reading bytecode from .class file into memory
- **Initialization**: Executing static initializers and assigning static variables

---

### Question 2: When Does Class Loading Occur?

**Answer:**

Class loading occurs in the following scenarios:

1. **First Reference to a Class**
   ```java
   // MyClass is loaded when first referenced
   MyClass obj = new MyClass();
   ```

2. **Accessing Static Members**
   ```java
   // Math class is loaded when accessing static method
   double result = Math.sqrt(16);
   
   // Constants class is loaded when accessing static field
   int value = Constants.MAX_VALUE;
   ```

3. **Using Reflection**
   ```java
   // MyClass is loaded when using reflection
   Class<?> clazz = Class.forName("com.example.MyClass");
   ```

4. **Subclass Loading Triggers Parent Class Loading**
   ```java
   // When Child is loaded, Parent is also loaded
   class Parent { }
   class Child extends Parent { }
   
   Child child = new Child(); // Both Parent and Child are loaded
   ```

5. **Interface Implementation**
   ```java
   // When MyClass is loaded, MyInterface is also loaded
   interface MyInterface { }
   class MyClass implements MyInterface { }
   ```

6. **Array Type Loading**
   ```java
   // Array type is loaded when array is created
   int[] arr = new int[10]; // Array type is loaded
   ```

**Important Note:** Classes are loaded only **once per ClassLoader**. Once loaded, the Class object is cached.

---

### Question 3: What is a ClassLoader?

**Answer:**

A **ClassLoader** is a Java class responsible for loading other classes into the JVM. It's an abstract class in `java.lang` package.

**Key Responsibilities:**
1. **Finding** the bytecode of a class
2. **Loading** the bytecode into memory
3. **Linking** the class (verification, preparation, resolution)
4. **Defining** the class in the JVM

**ClassLoader Hierarchy:**
```java
java.lang.Object
    └── java.lang.ClassLoader (abstract)
            ├── java.security.SecureClassLoader
            │       └── java.net.URLClassLoader
            │               └── java.net.URLClassLoader (Application ClassLoader)
            └── Custom ClassLoaders
```

**Basic ClassLoader Methods:**
```java
public abstract class ClassLoader {
    // Load a class by name
    protected Class<?> loadClass(String name) throws ClassNotFoundException;
    
    // Find a class (used by loadClass)
    protected Class<?> findClass(String name) throws ClassNotFoundException;
    
    // Define a class from bytecode
    protected final Class<?> defineClass(String name, byte[] b, int off, int len);
    
    // Get parent ClassLoader
    public final ClassLoader getParent();
    
    // Get resource
    public URL getResource(String name);
}
```

---

## ClassLoader Hierarchy

### Question 4: Explain the ClassLoader Hierarchy in Java

**Answer:**

Java has a **three-tier ClassLoader hierarchy** that follows a **parent-delegation model**:

```
1. Bootstrap ClassLoader (Primordial ClassLoader)
   │
   ├── Loads: Core Java classes (java.lang.*, java.util.*, etc.)
   ├── Location: rt.jar, $JAVA_HOME/jre/lib/*
   ├── Implementation: Native code (C/C++)
   └── Parent: null (top of hierarchy)
   
2. Extension ClassLoader (Platform ClassLoader in Java 9+)
   │
   ├── Loads: Extension libraries
   ├── Location: $JAVA_HOME/jre/lib/ext/* (Java 8)
   │            Platform classes (Java 9+)
   ├── Implementation: Java code (sun.misc.Launcher$ExtClassLoader)
   └── Parent: Bootstrap ClassLoader
   
3. Application ClassLoader (System ClassLoader)
   │
   ├── Loads: Application classes
   ├── Location: Classpath (CLASSPATH environment variable, -cp option)
   ├── Implementation: Java code (sun.misc.Launcher$AppClassLoader)
   └── Parent: Extension ClassLoader
```

**Visual Representation:**
```
                    Bootstrap ClassLoader
                           ↑
                    Extension ClassLoader
                           ↑
                   Application ClassLoader
                           ↑
                    Custom ClassLoader (if any)
```

**Code Example to Check ClassLoader Hierarchy:**
```java
public class ClassLoaderHierarchy {
    public static void main(String[] args) {
        // Get Application ClassLoader
        ClassLoader appClassLoader = ClassLoaderHierarchy.class.getClassLoader();
        System.out.println("Application ClassLoader: " + appClassLoader);
        System.out.println("Application ClassLoader class: " + appClassLoader.getClass());
        
        // Get Extension ClassLoader (parent of Application)
        ClassLoader extClassLoader = appClassLoader.getParent();
        System.out.println("Extension ClassLoader: " + extClassLoader);
        System.out.println("Extension ClassLoader class: " + extClassLoader.getClass());
        
        // Get Bootstrap ClassLoader (parent of Extension)
        ClassLoader bootstrapClassLoader = extClassLoader.getParent();
        System.out.println("Bootstrap ClassLoader: " + bootstrapClassLoader); // null
        
        // Check which ClassLoader loads different classes
        System.out.println("\nClassLoader for different classes:");
        System.out.println("String class: " + String.class.getClassLoader()); // null (Bootstrap)
        System.out.println("ArrayList class: " + ArrayList.class.getClassLoader()); // null (Bootstrap)
        System.out.println("This class: " + ClassLoaderHierarchy.class.getClassLoader()); // AppClassLoader
    }
}
```

**Output:**
```
Application ClassLoader: sun.misc.Launcher$AppClassLoader@18b4aac2
Application ClassLoader class: class sun.misc.Launcher$AppClassLoader
Extension ClassLoader: sun.misc.Launcher$ExtClassLoader@1b6d3586
Extension ClassLoader class: class sun.misc.Launcher$ExtClassLoader
Bootstrap ClassLoader: null

ClassLoader for different classes:
String class: null
ArrayList class: null
This class: sun.misc.Launcher$AppClassLoader@18b4aac2
```

---

### Question 5: What is the Parent-Delegation Model?

**Answer:**

The **Parent-Delegation Model** is a design pattern used by Java ClassLoaders where a ClassLoader first delegates the class loading request to its parent ClassLoader before attempting to load the class itself.

**How It Works:**

```
1. When a class loading request comes:
   └─> Application ClassLoader receives request
       │
       ├─> Delegates to Extension ClassLoader
       │   │
       │   ├─> Delegates to Bootstrap ClassLoader
       │   │   │
       │   │   ├─> Bootstrap tries to load from rt.jar
       │   │   │   ├─> Success? Return class
       │   │   │   └─> Failure? Return null
       │   │   │
       │   ├─> If Bootstrap returns null, Extension tries to load
       │   │   ├─> Success? Return class
       │   │   └─> Failure? Return null
       │   │
       ├─> If Extension returns null, Application tries to load
       │   ├─> Success? Return class
       │   └─> Failure? Throw ClassNotFoundException
```

**Code Example:**
```java
public class DelegationExample {
    public static void main(String[] args) throws ClassNotFoundException {
        ClassLoader appLoader = DelegationExample.class.getClassLoader();
        
        // When loading String class:
        // 1. AppLoader delegates to ExtLoader
        // 2. ExtLoader delegates to Bootstrap
        // 3. Bootstrap loads String from rt.jar
        Class<?> stringClass = appLoader.loadClass("java.lang.String");
        System.out.println("String loaded by: " + stringClass.getClassLoader()); // null (Bootstrap)
        
        // When loading our custom class:
        // 1. AppLoader delegates to ExtLoader
        // 2. ExtLoader delegates to Bootstrap
        // 3. Bootstrap returns null (not found)
        // 4. ExtLoader returns null (not found)
        // 5. AppLoader loads from classpath
        Class<?> myClass = appLoader.loadClass("com.example.MyClass");
        System.out.println("MyClass loaded by: " + myClass.getClassLoader()); // AppClassLoader
    }
}
```

**Benefits of Parent-Delegation:**
1. **Security**: Prevents custom classes from replacing core Java classes
2. **Consistency**: Ensures core classes are loaded from standard locations
3. **Performance**: Core classes are loaded once by Bootstrap ClassLoader
4. **Uniqueness**: Prevents same class from being loaded multiple times

**Example of Security Protection:**
```java
// Even if you create a class like this in your classpath:
package java.lang;

public class String {
    // This will NOT be loaded because Bootstrap ClassLoader
    // already loaded java.lang.String from rt.jar
    // Your custom String class will never be used
}
```

---

## Class Loading Process

### Question 6: Explain the Complete Class Loading Process

**Answer:**

The class loading process consists of **three main phases**:

#### Phase 1: Loading
- **Finding** the bytecode file (.class)
- **Reading** the bytecode into a byte array
- **Creating** a Class object in the Method Area

#### Phase 2: Linking
Linking has three sub-phases:

**2.1 Verification:**
- Checks bytecode validity
- Ensures it follows JVM specifications
- Verifies bytecode safety (no stack overflow, etc.)

**2.2 Preparation:**
- Allocates memory for static variables
- Initializes static variables to default values (0, null, false)
- **Does NOT execute** static initializers yet

**2.3 Resolution:**
- Resolves symbolic references to actual references
- Replaces symbolic names with direct memory addresses
- Can be done lazily (just-in-time)

#### Phase 3: Initialization
- Executes static initializers
- Assigns initial values to static variables
- Executes static blocks

**Detailed Flow:**
```java
public class ClassLoadingProcess {
    // Static variable - initialized in Phase 2 (Preparation) to default value 0
    // Then initialized in Phase 3 (Initialization) to 10
    static int value = 10;
    
    // Static block - executed in Phase 3 (Initialization)
    static {
        System.out.println("Static block executed");
        value = 20;
    }
    
    public static void main(String[] args) {
        System.out.println("Value: " + value); // Output: 20
    }
}
```

**Timeline:**
```
T1: Class first referenced
    ↓
T2: Loading Phase
    ├─ Find .class file
    ├─ Read bytecode
    └─ Create Class object
    ↓
T3: Linking Phase - Verification
    ├─ Verify bytecode
    └─ Check safety
    ↓
T4: Linking Phase - Preparation
    ├─ Allocate memory for static variables
    └─ Initialize to default values (value = 0)
    ↓
T5: Linking Phase - Resolution (can be lazy)
    ├─ Resolve symbolic references
    └─ Replace with direct references
    ↓
T6: Initialization Phase
    ├─ Execute static initializers (value = 10)
    ├─ Execute static blocks (value = 20)
    └─ Class is ready to use
```

---

### Question 7: What Happens During Class Initialization?

**Answer:**

Class initialization occurs when a class is **first actively used**. The JVM ensures initialization happens in a **thread-safe** manner.

**When Initialization Occurs:**
1. Creating an instance: `new MyClass()`
2. Accessing static field: `MyClass.staticField`
3. Calling static method: `MyClass.staticMethod()`
4. Using reflection: `Class.forName("MyClass")`
5. Initializing a subclass (parent is initialized first)
6. Designating a class as the main class

**Initialization Order:**
```java
public class InitializationOrder {
    // Step 1: Static variables initialized to default values (null, 0, false)
    static String name;
    static int count = 0;
    
    // Step 2: Static initializers executed in order
    static {
        System.out.println("Static block 1");
        name = "Initialized";
    }
    
    static {
        System.out.println("Static block 2");
        count = 10;
    }
    
    // Step 3: Instance variables initialized
    private int instanceVar = 5;
    
    // Step 4: Instance initializers executed
    {
        System.out.println("Instance block");
    }
    
    // Step 5: Constructor executed
    public InitializationOrder() {
        System.out.println("Constructor");
    }
    
    public static void main(String[] args) {
        System.out.println("Main method");
        new InitializationOrder();
    }
}
```

**Output:**
```
Static block 1
Static block 2
Main method
Instance block
Constructor
```

**Thread Safety:**
```java
public class ThreadSafeInitialization {
    private static ThreadSafeInitialization instance;
    
    // JVM ensures static initialization is thread-safe
    static {
        instance = new ThreadSafeInitialization();
        System.out.println("Initialized by thread: " + Thread.currentThread().getName());
    }
    
    public static ThreadSafeInitialization getInstance() {
        return instance;
    }
}
```

**Initialization of Parent Classes:**
```java
class Parent {
    static {
        System.out.println("Parent static block");
    }
    
    {
        System.out.println("Parent instance block");
    }
    
    Parent() {
        System.out.println("Parent constructor");
    }
}

class Child extends Parent {
    static {
        System.out.println("Child static block");
    }
    
    {
        System.out.println("Child instance block");
    }
    
    Child() {
        System.out.println("Child constructor");
    }
}

public class InheritanceInitialization {
    public static void main(String[] args) {
        new Child();
    }
}
```

**Output:**
```
Parent static block
Child static block
Parent instance block
Parent constructor
Child instance block
Child constructor
```

---

## Built-in ClassLoaders

### Question 8: Explain Bootstrap ClassLoader in Detail

**Answer:**

The **Bootstrap ClassLoader** (also called Primordial ClassLoader) is the root of the ClassLoader hierarchy. It's implemented in **native code** (C/C++) and is part of the JVM itself.

**Characteristics:**
1. **Native Implementation**: Written in C/C++, not Java
2. **No Parent**: It's the top of the hierarchy (getParent() returns null)
3. **Loads Core Classes**: All core Java classes (java.lang.*, java.util.*, etc.)
4. **Not Accessible**: Cannot be accessed directly from Java code
5. **High Priority**: First to attempt loading classes

**What It Loads:**
- `java.lang.*` packages (String, Object, Integer, etc.)
- `java.util.*` packages (ArrayList, HashMap, etc.)
- `java.io.*` packages
- `java.net.*` packages
- All classes in `rt.jar` (Java 8 and earlier)
- Platform classes (Java 9+)

**Location:**
- **Java 8 and earlier**: `$JAVA_HOME/jre/lib/rt.jar`
- **Java 9+**: Platform modules (no rt.jar)

**Code Example:**
```java
public class BootstrapClassLoaderDemo {
    public static void main(String[] args) {
        // Core Java classes are loaded by Bootstrap ClassLoader
        Class<?> stringClass = String.class;
        ClassLoader stringLoader = stringClass.getClassLoader();
        System.out.println("String ClassLoader: " + stringLoader); // null
        
        Class<?> integerClass = Integer.class;
        ClassLoader integerLoader = integerClass.getClassLoader();
        System.out.println("Integer ClassLoader: " + integerLoader); // null
        
        Class<?> arrayListClass = ArrayList.class;
        ClassLoader arrayListLoader = arrayListClass.getClassLoader();
        System.out.println("ArrayList ClassLoader: " + arrayListLoader); // null
        
        // null means Bootstrap ClassLoader
        // Bootstrap ClassLoader is not a Java object, so it returns null
    }
}
```

**Checking Bootstrap ClassLoader Path:**
```java
public class BootstrapPath {
    public static void main(String[] args) {
        // Get system property for bootstrap classpath
        String bootClassPath = System.getProperty("sun.boot.class.path");
        System.out.println("Bootstrap ClassPath:");
        if (bootClassPath != null) {
            String[] paths = bootClassPath.split(System.getProperty("path.separator"));
            for (String path : paths) {
                System.out.println("  - " + path);
            }
        } else {
            System.out.println("  (Not available in Java 9+)");
        }
    }
}
```

---

### Question 9: Explain Extension ClassLoader

**Answer:**

The **Extension ClassLoader** (called Platform ClassLoader in Java 9+) loads classes from extension directories. It's the child of Bootstrap ClassLoader and parent of Application ClassLoader.

**Characteristics:**
1. **Java Implementation**: Implemented as `sun.misc.Launcher$ExtClassLoader`
2. **Parent**: Bootstrap ClassLoader
3. **Loads Extensions**: Extension libraries and platform classes
4. **Accessible**: Can be accessed from Java code

**What It Loads:**
- **Java 8 and earlier**: Classes from `$JAVA_HOME/jre/lib/ext/` directory
- **Java 9+**: Platform classes (modules)

**Location:**
- **Java 8**: `$JAVA_HOME/jre/lib/ext/`
- **Java 9+**: Platform modules

**Code Example:**
```java
public class ExtensionClassLoaderDemo {
    public static void main(String[] args) {
        // Get Extension ClassLoader
        ClassLoader appLoader = ExtensionClassLoaderDemo.class.getClassLoader();
        ClassLoader extLoader = appLoader.getParent();
        
        System.out.println("Extension ClassLoader: " + extLoader);
        System.out.println("Extension ClassLoader class: " + extLoader.getClass());
        System.out.println("Extension ClassLoader parent: " + extLoader.getParent()); // null (Bootstrap)
        
        // Extension ClassLoader path
        String extDirs = System.getProperty("java.ext.dirs");
        System.out.println("\nExtension directories:");
        if (extDirs != null) {
            String[] dirs = extDirs.split(System.getProperty("path.separator"));
            for (String dir : dirs) {
                System.out.println("  - " + dir);
            }
        }
    }
}
```

**Adding Classes to Extension Path:**
```bash
# Java 8 and earlier
# Copy your JAR to: $JAVA_HOME/jre/lib/ext/

# Or set system property
java -Djava.ext.dirs=/path/to/extensions MyApp
```

---

### Question 10: Explain Application ClassLoader (System ClassLoader)

**Answer:**

The **Application ClassLoader** (also called System ClassLoader) is the default ClassLoader for loading application classes. It's the most commonly used ClassLoader.

**Characteristics:**
1. **Java Implementation**: Implemented as `sun.misc.Launcher$AppClassLoader`
2. **Parent**: Extension ClassLoader
3. **Loads Application Classes**: Classes from classpath
4. **Default ClassLoader**: Used by default for class loading

**What It Loads:**
- All classes from the **classpath**
- Classes specified with `-cp` or `-classpath` option
- Classes in `CLASSPATH` environment variable
- Current directory (if in classpath)

**Code Example:**
```java
public class ApplicationClassLoaderDemo {
    public static void main(String[] args) {
        // Get Application ClassLoader
        ClassLoader appLoader = ApplicationClassLoaderDemo.class.getClassLoader();
        
        System.out.println("Application ClassLoader: " + appLoader);
        System.out.println("Application ClassLoader class: " + appLoader.getClass());
        System.out.println("Application ClassLoader parent: " + appLoader.getParent());
        
        // Get classpath
        String classpath = System.getProperty("java.class.path");
        System.out.println("\nClasspath:");
        String[] paths = classpath.split(System.getProperty("path.separator"));
        for (String path : paths) {
            System.out.println("  - " + path);
        }
        
        // Application ClassLoader is the default
        ClassLoader defaultLoader = ClassLoader.getSystemClassLoader();
        System.out.println("\nSystem ClassLoader: " + defaultLoader);
        System.out.println("Same as app loader? " + (appLoader == defaultLoader)); // true
    }
}
```

**Getting System ClassLoader:**
```java
// Method 1: From a class
ClassLoader loader1 = MyClass.class.getClassLoader();

// Method 2: Using static method
ClassLoader loader2 = ClassLoader.getSystemClassLoader();

// Method 3: From current thread
ClassLoader loader3 = Thread.currentThread().getContextClassLoader();
```

---

## Custom ClassLoaders

### Question 11: How Do You Create a Custom ClassLoader?

**Answer:**

To create a custom ClassLoader, you need to extend the `ClassLoader` class and override the `findClass()` method. You can also override `loadClass()` to change the delegation behavior.

**Basic Custom ClassLoader:**
```java
import java.io.*;
import java.nio.file.*;

public class CustomClassLoader extends ClassLoader {
    private String classPath;
    
    public CustomClassLoader(String classPath) {
        this.classPath = classPath;
    }
    
    public CustomClassLoader(String classPath, ClassLoader parent) {
        super(parent);
        this.classPath = classPath;
    }
    
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        try {
            // Convert class name to file path
            String fileName = name.replace('.', File.separatorChar) + ".class";
            Path filePath = Paths.get(classPath, fileName);
            
            // Read bytecode from file
            byte[] bytecode = Files.readAllBytes(filePath);
            
            // Define the class
            return defineClass(name, bytecode, 0, bytecode.length);
        } catch (IOException e) {
            throw new ClassNotFoundException("Class not found: " + name, e);
        }
    }
}
```

**Usage Example:**
```java
public class CustomClassLoaderDemo {
    public static void main(String[] args) throws Exception {
        // Create custom ClassLoader
        CustomClassLoader loader = new CustomClassLoader("/path/to/classes");
        
        // Load class using custom ClassLoader
        Class<?> clazz = loader.loadClass("com.example.MyClass");
        
        // Create instance
        Object instance = clazz.newInstance();
        
        System.out.println("Class loaded by: " + clazz.getClassLoader());
        System.out.println("Class: " + clazz.getName());
    }
}
```

**Advanced Custom ClassLoader with Caching:**
```java
import java.io.*;
import java.nio.file.*;
import java.util.concurrent.*;

public class CachingClassLoader extends ClassLoader {
    private String classPath;
    private ConcurrentHashMap<String, Class<?>> cache = new ConcurrentHashMap<>();
    
    public CachingClassLoader(String classPath) {
        this.classPath = classPath;
    }
    
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        // Check cache first
        Class<?> cached = cache.get(name);
        if (cached != null) {
            return cached;
        }
        
        try {
            // Load class
            String fileName = name.replace('.', File.separatorChar) + ".class";
            Path filePath = Paths.get(classPath, fileName);
            byte[] bytecode = Files.readAllBytes(filePath);
            
            // Define class
            Class<?> clazz = defineClass(name, bytecode, 0, bytecode.length);
            
            // Cache it
            cache.put(name, clazz);
            
            return clazz;
        } catch (IOException e) {
            throw new ClassNotFoundException("Class not found: " + name, e);
        }
    }
    
    public void clearCache() {
        cache.clear();
    }
}
```

---

## Delegation Model

### Question 12: How Does the Delegation Model Work in Detail?

**Answer:**

The delegation model ensures that class loading requests are first delegated to parent ClassLoaders before the child attempts to load the class.

**Step-by-Step Process:**

```java
public class DelegationModelDemo {
    public static void main(String[] args) throws ClassNotFoundException {
        ClassLoader appLoader = DelegationModelDemo.class.getClassLoader();
        
        // When we call loadClass("java.lang.String"):
        Class<?> clazz = appLoader.loadClass("java.lang.String");
        
        // Here's what happens internally:
        /*
         * 1. AppClassLoader.loadClass("java.lang.String")
         *    └─> Checks if class already loaded (cached)
         *        └─> If yes, return cached class
         *        └─> If no, continue...
         *    
         * 2. AppClassLoader delegates to parent
         *    └─> ExtClassLoader.loadClass("java.lang.String")
         *        └─> Checks if class already loaded
         *            └─> If yes, return cached class
         *            └─> If no, continue...
         *    
         * 3. ExtClassLoader delegates to parent
         *    └─> Bootstrap ClassLoader (native code)
         *        └─> Tries to load from rt.jar
         *            └─> Success: Returns Class object
         *            └─> Failure: Returns null
         *    
         * 4. If Bootstrap returns null, ExtClassLoader tries
         *    └─> findClass("java.lang.String")
         *        └─> Not found, returns null
         *    
         * 5. If ExtClassLoader returns null, AppClassLoader tries
         *    └─> findClass("java.lang.String")
         *        └─> Loads from classpath
         */
    }
}
```

**Custom Implementation Showing Delegation:**
```java
public class DelegationDemoClassLoader extends ClassLoader {
    private String customPath;
    
    public DelegationDemoClassLoader(String customPath, ClassLoader parent) {
        super(parent); // Set parent
        this.customPath = customPath;
    }
    
    @Override
    protected Class<?> loadClass(String name, boolean resolve) 
            throws ClassNotFoundException {
        // Step 1: Check if already loaded
        Class<?> clazz = findLoadedClass(name);
        if (clazz != null) {
            return clazz;
        }
        
        // Step 2: Delegate to parent first
        try {
            if (getParent() != null) {
                clazz = getParent().loadClass(name);
                if (clazz != null) {
                    return clazz;
                }
            }
        } catch (ClassNotFoundException e) {
            // Parent couldn't load, continue to our findClass
        }
        
        // Step 3: If parent couldn't load, try our findClass
        return findClass(name);
    }
    
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        // Custom loading logic
        try {
            String fileName = name.replace('.', File.separatorChar) + ".class";
            Path filePath = Paths.get(customPath, fileName);
            byte[] bytecode = Files.readAllBytes(filePath);
            return defineClass(name, bytecode, 0, bytecode.length);
        } catch (IOException e) {
            throw new ClassNotFoundException("Class not found: " + name, e);
        }
    }
}
```

**Breaking the Delegation Model:**
```java
public class NonDelegatingClassLoader extends ClassLoader {
    private String customPath;
    
    public NonDelegatingClassLoader(String customPath) {
        super(null); // No parent - breaks delegation!
        this.customPath = customPath;
    }
    
    @Override
    protected Class<?> loadClass(String name, boolean resolve) 
            throws ClassNotFoundException {
        // Load directly without delegating
        Class<?> clazz = findLoadedClass(name);
        if (clazz != null) {
            return clazz;
        }
        
        // Try to load from custom path first
        try {
            clazz = findClass(name);
            if (resolve) {
                resolveClass(clazz);
            }
            return clazz;
        } catch (ClassNotFoundException e) {
            // If not found, delegate to system ClassLoader
            return ClassLoader.getSystemClassLoader().loadClass(name);
        }
    }
    
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        // Custom loading logic
        try {
            String fileName = name.replace('.', File.separatorChar) + ".class";
            Path filePath = Paths.get(customPath, fileName);
            byte[] bytecode = Files.readAllBytes(filePath);
            return defineClass(name, bytecode, 0, bytecode.length);
        } catch (IOException e) {
            throw new ClassNotFoundException("Class not found: " + name, e);
        }
    }
}
```

**When to Break Delegation:**
- **OSGi**: Module system that needs to load different versions
- **Application Servers**: Need to isolate applications
- **Hot Deployment**: Need to reload classes without restarting
- **Plugin Systems**: Need to load plugins independently

---

## Summary of Part 1

**Key Concepts Covered:**
1. ✅ What is class loading and when it occurs
2. ✅ ClassLoader hierarchy (Bootstrap, Extension, Application)
3. ✅ Class loading process (Loading, Linking, Initialization)
4. ✅ Built-in ClassLoaders and their roles
5. ✅ Custom ClassLoader creation
6. ✅ Parent-delegation model

**Important Points to Remember:**
- Classes are loaded **on-demand** (lazy loading)
- Each ClassLoader loads classes **once** and caches them
- **Parent-delegation** ensures security and consistency
- **Bootstrap ClassLoader** is native code and returns null
- **Initialization** happens after loading and linking
- **Custom ClassLoaders** can break delegation if needed

**Next in Part 2:**
- Class loading in different contexts (JARs, modules, web applications)
- Common issues and troubleshooting
- Performance considerations
- Advanced topics (class unloading, class versioning)
- Real-world scenarios and best practices

