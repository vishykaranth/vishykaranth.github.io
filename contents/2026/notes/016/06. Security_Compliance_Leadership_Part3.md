# Security and Compliance Leadership for Principal Engineers

## Part 3: Compliance Requirements (GDPR, HIPAA, SOC2, PCI-DSS)

---

## Table of Contents

1. [GDPR Compliance](#1-gdpr-compliance)
2. [HIPAA Compliance](#2-hipaa-compliance)
3. [SOC2 Compliance](#3-soc2-compliance)
4. [PCI-DSS Compliance](#4-pci-dss-compliance)
5. [Compliance Implementation Framework](#5-compliance-implementation-framework)
6. [Practical Examples](#6-practical-examples)

---

## 1. GDPR Compliance

### 1.1 GDPR Overview

**General Data Protection Regulation (GDPR)**:
- **Scope**: EU citizens' personal data
- **Effective**: May 25, 2018
- **Penalties**: Up to €20M or 4% of annual revenue
- **Key Principles**: Lawfulness, fairness, transparency, purpose limitation, data minimization, accuracy, storage limitation, integrity, accountability

### 1.2 GDPR Key Requirements

**Data Subject Rights**:

```java
/**
 * GDPR Data Subject Rights:
 * 
 * 1. Right to Access (Article 15)
 * 2. Right to Rectification (Article 16)
 * 3. Right to Erasure (Right to be Forgotten) (Article 17)
 * 4. Right to Restrict Processing (Article 18)
 * 5. Right to Data Portability (Article 20)
 * 6. Right to Object (Article 21)
 * 7. Rights Related to Automated Decision Making (Article 22)
 */
```

### 1.3 GDPR Implementation

**Data Subject Rights Service**:

```java
@Service
class GDPRDataSubjectRightsService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private DataProcessingLogRepository processingLogRepository;
    
    @Autowired
    private ConsentRepository consentRepository;
    
    @Autowired
    private AuditService auditService;
    
    /**
     * Right to Access (Article 15)
     * Data subject can request all personal data
     */
    public DataSubjectAccessResponse getDataSubjectAccess(String userId) {
        User user = userRepository.findById(userId);
        if (user == null) {
            throw new NotFoundException("User not found");
        }
        
        DataSubjectAccessResponse response = new DataSubjectAccessResponse();
        
        // Personal data
        response.setPersonalData(mapToPersonalData(user));
        
        // Processing purposes
        response.setProcessingPurposes(getProcessingPurposes(userId));
        
        // Data categories
        response.setDataCategories(getDataCategories(userId));
        
        // Recipients
        response.setRecipients(getDataRecipients(userId));
        
        // Retention period
        response.setRetentionPeriod(getRetentionPeriod(userId));
        
        // Rights
        response.setRights(getDataSubjectRights());
        
        // Consent records
        response.setConsents(getConsents(userId));
        
        // Processing logs
        response.setProcessingLogs(getProcessingLogs(userId));
        
        // Audit
        auditService.log("GDPR_DATA_ACCESS_REQUEST", userId);
        
        return response;
    }
    
    /**
     * Right to Rectification (Article 16)
     * Data subject can request correction of inaccurate data
     */
    public void rectifyData(String userId, DataRectificationRequest request) {
        User user = userRepository.findById(userId);
        if (user == null) {
            throw new NotFoundException("User not found");
        }
        
        // Update data
        if (request.getName() != null) {
            user.setName(request.getName());
        }
        if (request.getEmail() != null) {
            user.setEmail(request.getEmail());
        }
        if (request.getAddress() != null) {
            user.setAddress(request.getAddress());
        }
        
        userRepository.save(user);
        
        // Log processing
        processingLogRepository.save(new DataProcessingLog(
            userId,
            "DATA_RECTIFICATION",
            "Data corrected per data subject request",
            Instant.now()
        ));
        
        // Audit
        auditService.log("GDPR_DATA_RECTIFICATION", userId);
    }
    
    /**
     * Right to Erasure - Right to be Forgotten (Article 17)
     * Data subject can request deletion of personal data
     */
    public void eraseData(String userId, ErasureRequest request) {
        User user = userRepository.findById(userId);
        if (user == null) {
            throw new NotFoundException("User not found");
        }
        
        // Check if erasure is allowed
        if (!isErasureAllowed(userId, request.getReason())) {
            throw new ErasureNotAllowedException("Erasure not allowed due to legal obligations");
        }
        
        // Anonymize or delete data
        if (request.isAnonymize()) {
            anonymizeUserData(userId);
        } else {
            deleteUserData(userId);
        }
        
        // Log processing
        processingLogRepository.save(new DataProcessingLog(
            userId,
            "DATA_ERASURE",
            "Data erased per data subject request: " + request.getReason(),
            Instant.now()
        ));
        
        // Audit
        auditService.log("GDPR_DATA_ERASURE", userId);
    }
    
    private boolean isErasureAllowed(String userId, String reason) {
        // Check legal obligations
        // - Contractual obligations
        // - Legal compliance
        // - Public interest
        // - Health data
        // - Legal claims
        
        // Example: Check if user has active orders
        boolean hasActiveOrders = orderService.hasActiveOrders(userId);
        if (hasActiveOrders) {
            return false; // Cannot delete due to contractual obligations
        }
        
        // Check if user has pending legal claims
        boolean hasLegalClaims = legalService.hasPendingClaims(userId);
        if (hasLegalClaims) {
            return false; // Cannot delete due to legal claims
        }
        
        return true;
    }
    
    private void anonymizeUserData(String userId) {
        User user = userRepository.findById(userId);
        
        // Anonymize personal data
        user.setName("ANONYMIZED");
        user.setEmail("anonymized@" + UUID.randomUUID() + ".com");
        user.setPhone("ANONYMIZED");
        user.setAddress("ANONYMIZED");
        user.setSsn(null);
        user.setAnonymized(true);
        user.setAnonymizedAt(Instant.now());
        
        userRepository.save(user);
        
        // Anonymize related data
        anonymizeRelatedData(userId);
    }
    
    private void deleteUserData(String userId) {
        // Delete user data
        userRepository.deleteById(userId);
        
        // Delete related data
        deleteRelatedData(userId);
    }
    
    /**
     * Right to Data Portability (Article 20)
     * Data subject can request data in machine-readable format
     */
    public DataPortabilityResponse getDataPortability(String userId) {
        User user = userRepository.findById(userId);
        if (user == null) {
            throw new NotFoundException("User not found");
        }
        
        DataPortabilityResponse response = new DataPortabilityResponse();
        
        // Export data in JSON format
        Map<String, Object> data = new HashMap<>();
        data.put("personalInformation", mapToPersonalData(user));
        data.put("orders", orderService.getUserOrders(userId));
        data.put("preferences", preferenceService.getUserPreferences(userId));
        data.put("activityLogs", activityLogService.getUserActivityLogs(userId));
        
        response.setData(data);
        response.setFormat("JSON");
        response.setGeneratedAt(Instant.now());
        
        // Audit
        auditService.log("GDPR_DATA_PORTABILITY", userId);
        
        return response;
    }
    
    /**
     * Right to Restrict Processing (Article 18)
     * Data subject can request restriction of processing
     */
    public void restrictProcessing(String userId, RestrictionRequest request) {
        User user = userRepository.findById(userId);
        if (user == null) {
            throw new NotFoundException("User not found");
        }
        
        // Set processing restriction
        user.setProcessingRestricted(true);
        user.setProcessingRestrictionReason(request.getReason());
        user.setProcessingRestrictedAt(Instant.now());
        
        userRepository.save(user);
        
        // Stop automated processing
        stopAutomatedProcessing(userId);
        
        // Log processing
        processingLogRepository.save(new DataProcessingLog(
            userId,
            "PROCESSING_RESTRICTION",
            "Processing restricted: " + request.getReason(),
            Instant.now()
        ));
        
        // Audit
        auditService.log("GDPR_PROCESSING_RESTRICTION", userId);
    }
}
```

**Consent Management**:

```java
@Service
class GDPRConsentService {
    
    @Autowired
    private ConsentRepository consentRepository;
    
    @Autowired
    private AuditService auditService;
    
    /**
     * Record consent (Article 7)
     * Consent must be:
     * - Freely given
     * - Specific
     * - Informed
     * - Unambiguous
     * - Withdrawable
     */
    public void recordConsent(String userId, ConsentRequest request) {
        Consent consent = new Consent();
        consent.setUserId(userId);
        consent.setPurpose(request.getPurpose());
        consent.setConsentGiven(request.isConsentGiven());
        consent.setConsentMethod(request.getConsentMethod()); // e.g., "WEB_FORM", "EMAIL"
        consent.setIpAddress(request.getIpAddress());
        consent.setUserAgent(request.getUserAgent());
        consent.setTimestamp(Instant.now());
        consent.setVersion(request.getConsentVersion());
        
        consentRepository.save(consent);
        
        // Audit
        auditService.log("GDPR_CONSENT_RECORDED", userId, 
            "Purpose: " + request.getPurpose() + ", Given: " + request.isConsentGiven());
    }
    
    /**
     * Withdraw consent (Article 7)
     * Data subject can withdraw consent at any time
     */
    public void withdrawConsent(String userId, String purpose) {
        Consent consent = consentRepository.findByUserIdAndPurpose(userId, purpose);
        if (consent == null) {
            throw new NotFoundException("Consent not found");
        }
        
        consent.setConsentGiven(false);
        consent.setWithdrawnAt(Instant.now());
        consentRepository.save(consent);
        
        // Stop processing based on this consent
        stopProcessingBasedOnConsent(userId, purpose);
        
        // Audit
        auditService.log("GDPR_CONSENT_WITHDRAWN", userId, "Purpose: " + purpose);
    }
    
    /**
     * Check if consent is valid
     */
    public boolean hasValidConsent(String userId, String purpose) {
        Consent consent = consentRepository.findByUserIdAndPurpose(userId, purpose);
        if (consent == null) {
            return false;
        }
        
        // Check if consent is given and not withdrawn
        return consent.isConsentGiven() && consent.getWithdrawnAt() == null;
    }
}
```

**Data Processing Log**:

```java
@Entity
class DataProcessingLog {
    @Id
    private String id;
    private String userId;
    private String processingActivity;
    private String purpose;
    private String legalBasis; // e.g., "CONSENT", "CONTRACT", "LEGAL_OBLIGATION"
    private String description;
    private Instant timestamp;
    private String processor; // Who processed the data
    private String recipient; // Who received the data
    
    // Getters and setters
}
```

---

## 2. HIPAA Compliance

### 2.1 HIPAA Overview

**Health Insurance Portability and Accountability Act (HIPAA)**:
- **Scope**: Protected Health Information (PHI)
- **Key Rules**: Privacy Rule, Security Rule, Breach Notification Rule
- **Penalties**: $100 to $50,000 per violation, up to $1.5M per year
- **Key Requirements**: Administrative safeguards, Physical safeguards, Technical safeguards

### 2.2 HIPAA Technical Safeguards

**Access Control**:

```java
@Service
class HIPAAAccessControlService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private AuditService auditService;
    
    /**
     * Access Control (45 CFR § 164.312(a)(1))
     * Unique user identification, emergency access, automatic logoff
     */
    public boolean checkPHIAccess(String userId, String resourceId, String action) {
        User user = userRepository.findById(userId);
        if (user == null) {
            return false;
        }
        
        // Check if user is authorized
        if (!user.hasRole("HEALTHCARE_PROVIDER") && 
            !user.hasRole("ADMIN")) {
            auditService.log("HIPAA_ACCESS_DENIED", userId, resourceId, 
                "User does not have required role");
            return false;
        }
        
        // Check minimum necessary rule
        if (!isMinimumNecessary(user, resourceId, action)) {
            auditService.log("HIPAA_ACCESS_DENIED", userId, resourceId, 
                "Access exceeds minimum necessary");
            return false;
        }
        
        // Check if user has relationship with patient
        if (!hasPatientRelationship(user, resourceId)) {
            auditService.log("HIPAA_ACCESS_DENIED", userId, resourceId, 
                "No patient relationship");
            return false;
        }
        
        // Log access
        auditService.log("HIPAA_PHI_ACCESS", userId, resourceId, action);
        
        return true;
    }
    
    private boolean isMinimumNecessary(User user, String resourceId, String action) {
        // Implement minimum necessary rule
        // User should only access PHI necessary for their job function
        return true; // Simplified
    }
    
    private boolean hasPatientRelationship(User user, String patientId) {
        // Check if user has a treatment relationship with patient
        return patientService.hasTreatmentRelationship(user.getId(), patientId);
    }
}
```

**Encryption of PHI**:

```java
@Service
class HIPAADataEncryptionService {
    
    @Autowired
    private EncryptionService encryptionService;
    
    /**
     * Encryption (45 CFR § 164.312(a)(2)(iv))
     * PHI must be encrypted at rest and in transit
     */
    public void encryptPHI(PatientRecord record) {
        // Encrypt PHI fields
        if (record.getSsn() != null) {
            record.setSsn(encryptionService.encrypt(record.getSsn()));
        }
        if (record.getMedicalRecordNumber() != null) {
            record.setMedicalRecordNumber(
                encryptionService.encrypt(record.getMedicalRecordNumber()));
        }
        if (record.getDiagnosis() != null) {
            record.setDiagnosis(encryptionService.encrypt(record.getDiagnosis()));
        }
        if (record.getTreatment() != null) {
            record.setTreatment(encryptionService.encrypt(record.getTreatment()));
        }
    }
    
    public PatientRecord decryptPHI(PatientRecord record) {
        // Decrypt PHI fields
        if (record.getSsn() != null) {
            record.setSsn(encryptionService.decrypt(record.getSsn()));
        }
        if (record.getMedicalRecordNumber() != null) {
            record.setMedicalRecordNumber(
                encryptionService.decrypt(record.getMedicalRecordNumber()));
        }
        if (record.getDiagnosis() != null) {
            record.setDiagnosis(encryptionService.decrypt(record.getDiagnosis()));
        }
        if (record.getTreatment() != null) {
            record.setTreatment(encryptionService.decrypt(record.getTreatment()));
        }
        
        return record;
    }
}
```

**Audit Controls**:

```java
@Service
class HIPAAAuditService {
    
    @Autowired
    private AuditLogRepository auditLogRepository;
    
    /**
     * Audit Controls (45 CFR § 164.312(b))
     * Log all access to PHI
     */
    public void logPHIAccess(String userId, String patientId, String action, 
                            String resourceType, String resourceId) {
        HIPAAAuditLog log = new HIPAAAuditLog();
        log.setUserId(userId);
        log.setPatientId(patientId);
        log.setAction(action); // e.g., "VIEW", "CREATE", "UPDATE", "DELETE"
        log.setResourceType(resourceType); // e.g., "MEDICAL_RECORD", "LAB_RESULT"
        log.setResourceId(resourceId);
        log.setTimestamp(Instant.now());
        log.setIpAddress(getClientIpAddress());
        log.setUserAgent(getUserAgent());
        
        auditLogRepository.save(log);
    }
    
    /**
     * Get audit trail for patient
     */
    public List<HIPAAAuditLog> getPatientAuditTrail(String patientId, 
                                                    LocalDate startDate, 
                                                    LocalDate endDate) {
        return auditLogRepository.findByPatientIdAndTimestampBetween(
            patientId,
            startDate.atStartOfDay(),
            endDate.atTime(23, 59, 59)
        );
    }
}

@Entity
class HIPAAAuditLog {
    @Id
    private String id;
    private String userId;
    private String patientId;
    private String action;
    private String resourceType;
    private String resourceId;
    private Instant timestamp;
    private String ipAddress;
    private String userAgent;
    private String result; // "SUCCESS", "FAILURE"
    private String reason; // Reason for failure if applicable
    
    // Getters and setters
}
```

**Breach Notification**:

```java
@Service
class HIPAABreachNotificationService {
    
    @Autowired
    private PatientRepository patientRepository;
    
    @Autowired
    private NotificationService notificationService;
    
    /**
     * Breach Notification (45 CFR § 164.400-414)
     * Notify affected individuals, HHS, and media (if >500 affected)
     */
    public void handleBreach(SecurityBreach breach) {
        // Determine if breach occurred
        if (!isBreach(breach)) {
            return; // No breach
        }
        
        // Log breach
        breachRepository.save(breach);
        
        // Notify affected individuals (within 60 days)
        List<String> affectedPatientIds = getAffectedPatients(breach);
        for (String patientId : affectedPatientIds) {
            Patient patient = patientRepository.findById(patientId);
            notifyPatient(patient, breach);
        }
        
        // Notify HHS
        if (affectedPatientIds.size() >= 500) {
            // Notify HHS immediately (within 60 days)
            notifyHHS(breach, affectedPatientIds.size());
            
            // Notify media (if >500 affected)
            notifyMedia(breach, affectedPatientIds.size());
        } else {
            // Notify HHS annually (if <500 affected)
            scheduleAnnualHHSNotification(breach);
        }
        
        // Document breach
        documentBreach(breach);
    }
    
    private boolean isBreach(SecurityBreach breach) {
        // Breach = unauthorized access, use, or disclosure of PHI
        // Unless:
        // 1. Unintentional access by authorized person
        // 2. Inadvertent disclosure to another authorized person
        // 3. Person could not reasonably retain information
        
        return breach.isUnauthorized() && 
               breach.isUnintentional() == false &&
               breach.isRetained() == true;
    }
    
    private void notifyPatient(Patient patient, SecurityBreach breach) {
        String message = String.format(
            "We are writing to inform you of a security incident that may have " +
            "affected your protected health information. " +
            "Incident Date: %s, " +
            "Information Involved: %s, " +
            "What We're Doing: %s, " +
            "What You Can Do: %s",
            breach.getIncidentDate(),
            breach.getInformationInvolved(),
            breach.getRemediationSteps(),
            breach.getPatientActions()
        );
        
        notificationService.sendNotification(patient.getEmail(), 
            "Security Incident Notification", message);
    }
}
```

---

## 3. SOC2 Compliance

### 3.1 SOC2 Overview

**Service Organization Control 2 (SOC2)**:
- **Scope**: Service organizations handling customer data
- **Trust Service Criteria**: Security, Availability, Processing Integrity, Confidentiality, Privacy
- **Types**: SOC2 Type I (point in time), SOC2 Type II (over time)
- **Key Requirements**: Access controls, change management, system operations, risk management

### 3.2 SOC2 Trust Service Criteria

**Security (Common Criteria)**:

```java
@Service
class SOC2SecurityService {
    
    /**
     * CC6.1 - Logical and Physical Access Controls
     * Implement access controls to prevent unauthorized access
     */
    public void enforceAccessControls(String userId, String resource, String action) {
        // Authentication
        if (!isAuthenticated(userId)) {
            throw new UnauthorizedException("User not authenticated");
        }
        
        // Authorization
        if (!isAuthorized(userId, resource, action)) {
            throw new ForbiddenException("User not authorized");
        }
        
        // Log access
        auditService.log("ACCESS_CONTROL", userId, resource, action);
    }
    
    /**
     * CC6.2 - User Access Management
     * Manage user access lifecycle
     */
    public void manageUserAccess(String userId, AccessManagementRequest request) {
        User user = userRepository.findById(userId);
        
        // Provision access
        if (request.getAction() == AccessAction.PROVISION) {
            provisionAccess(user, request.getRoles(), request.getPermissions());
        }
        
        // Modify access
        if (request.getAction() == AccessAction.MODIFY) {
            modifyAccess(user, request.getRoles(), request.getPermissions());
        }
        
        // Revoke access
        if (request.getAction() == AccessAction.REVOKE) {
            revokeAccess(user);
        }
        
        // Review access (quarterly)
        reviewAccess(user);
    }
    
    /**
     * CC6.6 - Credential Management
     * Manage credentials securely
     */
    public void manageCredentials(String userId, CredentialRequest request) {
        User user = userRepository.findById(userId);
        
        // Password requirements
        validatePasswordPolicy(request.getPassword());
        
        // Hash password
        String hashedPassword = passwordEncoder.encode(request.getPassword());
        user.setPassword(hashedPassword);
        
        // Password expiration (90 days)
        user.setPasswordExpiresAt(Instant.now().plus(90, ChronoUnit.DAYS));
        
        // Password history (prevent reuse of last 5 passwords)
        addToPasswordHistory(user, hashedPassword);
        
        userRepository.save(user);
    }
    
    private void validatePasswordPolicy(String password) {
        // Minimum 12 characters
        if (password.length() < 12) {
            throw new InvalidPasswordException("Password must be at least 12 characters");
        }
        
        // Complexity requirements
        if (!password.matches(".*[A-Z].*")) {
            throw new InvalidPasswordException("Password must contain uppercase letter");
        }
        if (!password.matches(".*[a-z].*")) {
            throw new InvalidPasswordException("Password must contain lowercase letter");
        }
        if (!password.matches(".*[0-9].*")) {
            throw new InvalidPasswordException("Password must contain number");
        }
        if (!password.matches(".*[!@#$%^&*].*")) {
            throw new InvalidPasswordException("Password must contain special character");
        }
    }
}
```

**Availability**:

```java
@Service
class SOC2AvailabilityService {
    
    /**
     * A1.1 - Availability Commitments
     * Maintain system availability (e.g., 99.9% uptime)
     */
    public void monitorAvailability() {
        // Monitor system uptime
        double uptime = calculateUptime();
        
        // Alert if below SLA
        if (uptime < 0.999) { // 99.9%
            alertService.sendAlert("AVAILABILITY_SLA_BREACH", 
                "System uptime: " + (uptime * 100) + "%");
        }
        
        // Log availability metrics
        metricsService.recordMetric("system.availability", uptime);
    }
    
    /**
     * A1.2 - System Performance
     * Monitor and maintain system performance
     */
    public void monitorPerformance() {
        // Monitor response times
        double avgResponseTime = metricsService.getAverageResponseTime();
        
        // Alert if response time exceeds threshold
        if (avgResponseTime > 500) { // 500ms
            alertService.sendAlert("PERFORMANCE_DEGRADATION", 
                "Average response time: " + avgResponseTime + "ms");
        }
        
        // Monitor error rates
        double errorRate = metricsService.getErrorRate();
        if (errorRate > 0.01) { // 1%
            alertService.sendAlert("HIGH_ERROR_RATE", 
                "Error rate: " + (errorRate * 100) + "%");
        }
    }
}
```

**Processing Integrity**:

```java
@Service
class SOC2ProcessingIntegrityService {
    
    /**
     * PI1.1 - Processing Integrity
     * Ensure data is complete, valid, accurate, timely, and authorized
     */
    public void validateProcessingIntegrity(DataProcessingRequest request) {
        // Validate completeness
        if (!isComplete(request)) {
            throw new ProcessingIntegrityException("Data is incomplete");
        }
        
        // Validate validity
        if (!isValid(request)) {
            throw new ProcessingIntegrityException("Data is invalid");
        }
        
        // Validate accuracy
        if (!isAccurate(request)) {
            throw new ProcessingIntegrityException("Data is inaccurate");
        }
        
        // Validate timeliness
        if (!isTimely(request)) {
            throw new ProcessingIntegrityException("Data is not timely");
        }
        
        // Validate authorization
        if (!isAuthorized(request)) {
            throw new ProcessingIntegrityException("Processing not authorized");
        }
        
        // Log processing
        auditService.log("PROCESSING_INTEGRITY_VALIDATED", request.getId());
    }
    
    /**
     * PI1.2 - Data Validation
     * Validate data inputs and outputs
     */
    public void validateData(String data, DataValidationRules rules) {
        // Input validation
        if (!rules.validateInput(data)) {
            throw new ValidationException("Input validation failed");
        }
        
        // Output validation
        String processedData = processData(data);
        if (!rules.validateOutput(processedData)) {
            throw new ValidationException("Output validation failed");
        }
    }
}
```

**Confidentiality**:

```java
@Service
class SOC2ConfidentialityService {
    
    /**
     * C1.1 - Confidentiality Commitments
     * Protect confidential information
     */
    public void protectConfidentialData(String data, String classification) {
        // Encrypt based on classification
        if (classification.equals("CONFIDENTIAL")) {
            data = encryptionService.encrypt(data);
        }
        
        // Access controls
        enforceAccessControls(data, classification);
        
        // Log access
        auditService.log("CONFIDENTIAL_DATA_ACCESS", data, classification);
    }
    
    /**
     * C1.2 - Confidentiality Controls
     * Implement controls to protect confidential information
     */
    public void enforceConfidentialityControls(String userId, String resource) {
        // Check if user has clearance
        if (!hasClearance(userId, resource)) {
            throw new UnauthorizedException("User does not have required clearance");
        }
        
        // Encrypt data in transit
        enforceTLS();
        
        // Encrypt data at rest
        enforceEncryptionAtRest();
        
        // Log access
        auditService.log("CONFIDENTIAL_DATA_ACCESS", userId, resource);
    }
}
```

---

## 4. PCI-DSS Compliance

### 4.1 PCI-DSS Overview

**Payment Card Industry Data Security Standard (PCI-DSS)**:
- **Scope**: Organizations handling cardholder data
- **Levels**: 1-4 (based on transaction volume)
- **Key Requirements**: 12 requirements across 6 categories
- **Penalties**: $5,000 to $100,000 per month for non-compliance

### 4.2 PCI-DSS Requirements

**Requirement 1-2: Network Security**:

```java
@Service
class PCIDSSNetworkSecurityService {
    
    /**
     * Requirement 1: Install and maintain firewall configuration
     * Requirement 2: Do not use vendor-supplied defaults
     */
    public void enforceNetworkSecurity() {
        // Firewall rules
        configureFirewallRules();
        
        // Default credentials
        ensureNoDefaultCredentials();
        
        // Network segmentation
        segmentCardholderDataEnvironment();
    }
    
    private void segmentCardholderDataEnvironment() {
        // Isolate cardholder data environment (CDE)
        // - Separate network segment
        // - Restricted access
        // - Monitoring
    }
}
```

**Requirement 3: Protect Stored Cardholder Data**:

```java
@Service
class PCIDSSDataProtectionService {
    
    /**
     * Requirement 3: Protect stored cardholder data
     * - Never store full card numbers
     * - Use tokenization
     * - Encrypt sensitive data
     */
    public String tokenizeCardNumber(String cardNumber) {
        // Never store full card number
        // Use tokenization service
        String token = tokenizationService.tokenize(cardNumber);
        
        // Store only last 4 digits for display
        String last4 = cardNumber.substring(cardNumber.length() - 4);
        
        return token;
    }
    
    public void storePaymentMethod(String userId, PaymentMethodRequest request) {
        // Tokenize card number
        String token = tokenizeCardNumber(request.getCardNumber());
        
        // Encrypt sensitive data (CVV, expiry)
        String encryptedCvv = encryptionService.encrypt(request.getCvv());
        String encryptedExpiry = encryptionService.encrypt(request.getExpiryDate());
        
        PaymentMethod method = new PaymentMethod();
        method.setUserId(userId);
        method.setToken(token); // Store token, not card number
        method.setLast4(request.getCardNumber().substring(
            request.getCardNumber().length() - 4));
        method.setEncryptedCvv(encryptedCvv);
        method.setEncryptedExpiry(encryptedExpiry);
        
        paymentMethodRepository.save(method);
    }
    
    /**
     * Requirement 3.4: Render PAN unreadable
     * - One-way hashes
     * - Truncation
     * - Index tokens
     * - Strong cryptography
     */
    public String hashPAN(String pan) {
        // Use strong one-way hash (SHA-256 or stronger)
        return DigestUtils.sha256Hex(pan);
    }
}
```

**Requirement 4: Encrypt Transmission**:

```java
@Service
class PCIDSSTransmissionSecurityService {
    
    /**
     * Requirement 4: Encrypt cardholder data across open, public networks
     * - Use TLS 1.2 or higher
     * - Never send cardholder data via email, instant messaging, etc.
     */
    public void enforceTransmissionSecurity() {
        // TLS configuration
        configureTLS();
        
        // Prohibit insecure transmission
        prohibitInsecureTransmission();
    }
    
    private void configureTLS() {
        // Use TLS 1.2 or higher
        System.setProperty("https.protocols", "TLSv1.2,TLSv1.3");
        
        // Disable weak ciphers
        // Enable strong ciphers only
    }
    
    private void prohibitInsecureTransmission() {
        // Never send cardholder data via:
        // - Email
        // - Instant messaging
        // - Unencrypted channels
    }
}
```

**Requirement 7-8: Access Control**:

```java
@Service
class PCIDSSAccessControlService {
    
    /**
     * Requirement 7: Restrict access to cardholder data by business need-to-know
     * Requirement 8: Identify and authenticate access
     */
    public void enforceAccessControl(String userId, String resource) {
        // Check business need-to-know
        if (!hasBusinessNeedToKnow(userId, resource)) {
            throw new AccessDeniedException("No business need-to-know");
        }
        
        // Strong authentication
        if (!isStronglyAuthenticated(userId)) {
            throw new AuthenticationException("Strong authentication required");
        }
        
        // Unique user IDs
        if (!hasUniqueUserId(userId)) {
            throw new SecurityException("User ID must be unique");
        }
        
        // Log access
        auditService.log("PCI_ACCESS", userId, resource);
    }
    
    private boolean hasBusinessNeedToKnow(String userId, String resource) {
        // Check if user's job function requires access
        User user = userRepository.findById(userId);
        return user.getJobFunction().requiresAccessTo(resource);
    }
    
    private boolean isStronglyAuthenticated(String userId) {
        // Multi-factor authentication required
        User user = userRepository.findById(userId);
        return user.isMfaEnabled() && user.isAuthenticated();
    }
}
```

**Requirement 10: Logging and Monitoring**:

```java
@Service
class PCIDSSLoggingService {
    
    /**
     * Requirement 10: Track and monitor all access to cardholder data
     * - Log all access
     * - Review logs daily
     * - Retain logs for at least 1 year
     */
    public void logCardholderDataAccess(String userId, String action, 
                                       String resource, String cardToken) {
        PCIAuditLog log = new PCIAuditLog();
        log.setUserId(userId);
        log.setAction(action);
        log.setResource(resource);
        log.setCardToken(cardToken); // Log token, not card number
        log.setTimestamp(Instant.now());
        log.setIpAddress(getClientIpAddress());
        log.setUserAgent(getUserAgent());
        log.setResult("SUCCESS");
        
        auditLogRepository.save(log);
    }
    
    /**
     * Requirement 10.5: Secure audit trails
     * - Protect logs from modification
     * - Back up logs
     * - Time synchronization
     */
    public void secureAuditTrails() {
        // Write-only logs (append-only)
        configureAppendOnlyLogs();
        
        // Backup logs
        backupLogs();
        
        // Time synchronization (NTP)
        synchronizeTime();
    }
}
```

---

## 5. Compliance Implementation Framework

### 5.1 Compliance Framework

```java
@Service
class ComplianceFrameworkService {
    
    /**
     * Compliance Implementation Framework:
     * 
     * 1. Assessment:
     *    - Identify applicable regulations
     *    - Assess current state
     *    - Identify gaps
     * 
     * 2. Planning:
     *    - Define compliance requirements
     *    - Create implementation plan
     *    - Assign responsibilities
     * 
     * 3. Implementation:
     *    - Implement controls
     *    - Configure systems
     *    - Train staff
     * 
     * 4. Monitoring:
     *    - Continuous monitoring
     *    - Regular audits
     *    - Compliance reporting
     * 
     * 5. Remediation:
     *    - Identify issues
     *    - Remediate gaps
     *    - Verify fixes
     */
    
    public ComplianceAssessment assessCompliance(String regulation) {
        ComplianceAssessment assessment = new ComplianceAssessment();
        assessment.setRegulation(regulation);
        assessment.setAssessmentDate(Instant.now());
        
        // Assess controls
        List<ComplianceControl> controls = getControlsForRegulation(regulation);
        for (ComplianceControl control : controls) {
            ComplianceStatus status = assessControl(control);
            assessment.addControlStatus(control, status);
        }
        
        // Calculate compliance score
        double complianceScore = calculateComplianceScore(assessment);
        assessment.setComplianceScore(complianceScore);
        
        // Identify gaps
        List<ComplianceGap> gaps = identifyGaps(assessment);
        assessment.setGaps(gaps);
        
        return assessment;
    }
    
    private ComplianceStatus assessControl(ComplianceControl control) {
        // Check if control is implemented
        boolean implemented = isControlImplemented(control);
        
        // Check if control is effective
        boolean effective = isControlEffective(control);
        
        // Check if control is documented
        boolean documented = isControlDocumented(control);
        
        if (implemented && effective && documented) {
            return ComplianceStatus.COMPLIANT;
        } else if (implemented && documented) {
            return ComplianceStatus.PARTIALLY_COMPLIANT;
        } else {
            return ComplianceStatus.NON_COMPLIANT;
        }
    }
}
```

### 5.2 Compliance Dashboard

```java
@RestController
@RequestMapping("/api/compliance")
class ComplianceDashboardController {
    
    @Autowired
    private ComplianceFrameworkService complianceService;
    
    @GetMapping("/status")
    public ComplianceDashboard getComplianceStatus() {
        ComplianceDashboard dashboard = new ComplianceDashboard();
        
        // GDPR status
        ComplianceAssessment gdpr = complianceService.assessCompliance("GDPR");
        dashboard.setGdprStatus(gdpr.getComplianceScore());
        
        // HIPAA status
        ComplianceAssessment hipaa = complianceService.assessCompliance("HIPAA");
        dashboard.setHipaaStatus(hipaa.getComplianceScore());
        
        // SOC2 status
        ComplianceAssessment soc2 = complianceService.assessCompliance("SOC2");
        dashboard.setSoc2Status(soc2.getComplianceScore());
        
        // PCI-DSS status
        ComplianceAssessment pci = complianceService.assessCompliance("PCI-DSS");
        dashboard.setPciStatus(pci.getComplianceScore());
        
        // Overall compliance score
        double overallScore = (gdpr.getComplianceScore() + 
                              hipaa.getComplianceScore() + 
                              soc2.getComplianceScore() + 
                              pci.getComplianceScore()) / 4;
        dashboard.setOverallScore(overallScore);
        
        // Open gaps
        List<ComplianceGap> openGaps = getAllOpenGaps();
        dashboard.setOpenGaps(openGaps);
        
        return dashboard;
    }
}
```

---

## Summary: Part 3

### Key Concepts

1. **GDPR**: Data subject rights, consent management, data portability
2. **HIPAA**: PHI protection, access controls, breach notification
3. **SOC2**: Trust service criteria (Security, Availability, Processing Integrity, Confidentiality, Privacy)
4. **PCI-DSS**: Cardholder data protection, tokenization, encryption, access controls

### Next Steps

**Part 4** will cover:
- Security Code Review
- Secure Coding Practices
- Vulnerability Assessment
- Security Testing

---

**Master compliance requirements to protect data and avoid costly violations!**

