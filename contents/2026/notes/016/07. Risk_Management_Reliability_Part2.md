# Risk Management and Reliability Engineering: Master Guide for Principal Engineers

## Part 2: Disaster Recovery Planning (RTO/RPO) and Reliability Patterns

---

## Table of Contents

1. [Disaster Recovery Fundamentals](#1-disaster-recovery-fundamentals)
2. [RTO and RPO Planning](#2-rto-and-rpo-planning)
3. [Backup and Recovery Strategies](#3-backup-and-recovery-strategies)
4. [Reliability Patterns](#4-reliability-patterns)
5. [Circuit Breaker Pattern](#5-circuit-breaker-pattern)
6. [Retry Pattern with Exponential Backoff](#6-retry-pattern-with-exponential-backoff)
7. [Graceful Degradation](#7-graceful-degradation)
8. [Practical Examples](#8-practical-examples)

---

## 1. Disaster Recovery Fundamentals

### 1.1 What is Disaster Recovery?

**Disaster Recovery (DR)** is the process of restoring systems and data after a catastrophic failure or disaster.

### 1.2 Types of Disasters

```java
/**
 * Disaster Categories:
 * 
 * 1. Natural Disasters:
 *    - Earthquakes
 *    - Floods
 *    - Hurricanes
 *    - Fires
 * 
 * 2. Technical Failures:
 *    - Hardware failures
 *    - Software bugs
 *    - Network outages
 *    - Data corruption
 * 
 * 3. Human Errors:
 *    - Accidental deletions
 *    - Configuration mistakes
 *    - Deployment errors
 * 
 * 4. Cyber Attacks:
 *    - Ransomware
 *    - DDoS attacks
 *    - Data breaches
 * 
 * 5. Provider Failures:
 *    - Cloud provider outages
 *    - Third-party service failures
 */
```

### 1.3 Disaster Recovery Plan Components

```java
/**
 * DR Plan Components:
 * 
 * 1. Risk Assessment:
 *    - Identify potential disasters
 *    - Assess impact
 *    - Prioritize scenarios
 * 
 * 2. Recovery Objectives:
 *    - RTO (Recovery Time Objective)
 *    - RPO (Recovery Point Objective)
 * 
 * 3. Backup Strategy:
 *    - What to backup
 *    - How often to backup
 *    - Where to store backups
 * 
 * 4. Recovery Procedures:
 *    - Step-by-step recovery
 *    - Roles and responsibilities
 *    - Communication plan
 * 
 * 5. Testing and Validation:
 *    - Regular DR drills
 *    - Recovery testing
 *    - Plan updates
 */
```

---

## 2. RTO and RPO Planning

### 2.1 Recovery Time Objective (RTO)

**RTO** is the maximum acceptable time to restore service after a disaster.

```java
/**
 * RTO Examples:
 * 
 * Critical Systems:    RTO < 1 hour
 * Important Systems:   RTO < 4 hours
 * Standard Systems:   RTO < 24 hours
 * Low Priority:        RTO < 72 hours
 */
```

### 2.2 Recovery Point Objective (RPO)

**RPO** is the maximum acceptable data loss measured in time.

```java
/**
 * RPO Examples:
 * 
 * Critical Data:       RPO < 15 minutes (Near-zero data loss)
 * Important Data:     RPO < 1 hour
 * Standard Data:      RPO < 24 hours
 * Low Priority Data:  RPO < 7 days
 */
```

### 2.3 RTO/RPO Matrix

```java
class RTORPOMatrix {
    
    /**
     * RTO/RPO Matrix by System Criticality:
     * 
     * System Type          RTO          RPO          Strategy
     * ──────────────────────────────────────────────────────────
     * Payment System      < 15 min     < 1 min      Hot standby, sync replication
     * Order System       < 1 hour     < 5 min      Warm standby, async replication
     * User Service       < 4 hours    < 1 hour     Backup restore, daily backups
     * Analytics          < 24 hours    < 24 hours   Backup restore, weekly backups
     */
    
    public DRStrategy determineStrategy(String systemType) {
        Map<String, DRStrategy> strategies = Map.of(
            "payment", new DRStrategy(
                Duration.ofMinutes(15),  // RTO
                Duration.ofMinutes(1),    // RPO
                "Hot standby with synchronous replication",
                DRType.HOT_STANDBY
            ),
            "order", new DRStrategy(
                Duration.ofHours(1),
                Duration.ofMinutes(5),
                "Warm standby with asynchronous replication",
                DRType.WARM_STANDBY
            ),
            "user", new DRStrategy(
                Duration.ofHours(4),
                Duration.ofHours(1),
                "Backup restore with daily backups",
                DRType.BACKUP_RESTORE
            ),
            "analytics", new DRStrategy(
                Duration.ofHours(24),
                Duration.ofHours(24),
                "Backup restore with weekly backups",
                DRType.BACKUP_RESTORE
            )
        );
        
        return strategies.getOrDefault(systemType, strategies.get("user"));
    }
}

class DRStrategy {
    private Duration rto;
    private Duration rpo;
    private String description;
    private DRType type;
    
    // Constructor and getters
}

enum DRType {
    HOT_STANDBY,      // Active-active, zero downtime
    WARM_STANDBY,     // Standby ready, minimal downtime
    COLD_STANDBY,     // Infrastructure ready, restore needed
    BACKUP_RESTORE    // Restore from backups
}
```

### 2.4 RTO/RPO Calculation

```java
@Service
class RTORPOCalculator {
    
    /**
     * Calculate RTO based on:
     * - System criticality
     * - Business impact
     * - Recovery complexity
     * - Available resources
     */
    
    public Duration calculateRTO(SystemCriticality criticality, 
                                BusinessImpact impact,
                                RecoveryComplexity complexity) {
        Map<SystemCriticality, Duration> baseRTO = Map.of(
            SystemCriticality.CRITICAL, Duration.ofMinutes(15),
            SystemCriticality.HIGH, Duration.ofHours(1),
            SystemCriticality.MEDIUM, Duration.ofHours(4),
            SystemCriticality.LOW, Duration.ofHours(24)
        );
        
        Duration base = baseRTO.get(criticality);
        
        // Adjust based on business impact
        if (impact == BusinessImpact.HIGH) {
            base = base.dividedBy(2);
        }
        
        // Adjust based on recovery complexity
        if (complexity == RecoveryComplexity.HIGH) {
            base = base.multipliedBy(2);
        }
        
        return base;
    }
    
    /**
     * Calculate RPO based on:
     * - Data criticality
     * - Data change frequency
     * - Backup capabilities
     */
    
    public Duration calculateRPO(DataCriticality criticality,
                                 DataChangeFrequency frequency) {
        Map<DataCriticality, Duration> baseRPO = Map.of(
            DataCriticality.CRITICAL, Duration.ofMinutes(1),
            DataCriticality.HIGH, Duration.ofMinutes(15),
            DataCriticality.MEDIUM, Duration.ofHours(1),
            DataCriticality.LOW, Duration.ofHours(24)
        );
        
        Duration base = baseRPO.get(criticality);
        
        // Adjust based on change frequency
        if (frequency == DataChangeFrequency.HIGH) {
            base = base.dividedBy(2);
        }
        
        return base;
    }
}

enum SystemCriticality {
    CRITICAL, HIGH, MEDIUM, LOW
}

enum BusinessImpact {
    HIGH, MEDIUM, LOW
}

enum RecoveryComplexity {
    HIGH, MEDIUM, LOW
}

enum DataCriticality {
    CRITICAL, HIGH, MEDIUM, LOW
}

enum DataChangeFrequency {
    HIGH, MEDIUM, LOW
}
```

---

## 3. Backup and Recovery Strategies

### 3.1 Backup Types

```java
/**
 * Backup Types:
 * 
 * 1. Full Backup:
 *    - Complete system backup
 *    - Slow, requires most storage
 *    - Fastest restore
 * 
 * 2. Incremental Backup:
 *    - Only changed data since last backup
 *    - Fast, requires less storage
 *    - Slower restore (need all increments)
 * 
 * 3. Differential Backup:
 *    - All changes since last full backup
 *    - Medium speed and storage
 *    - Medium restore time
 * 
 * 4. Continuous Backup:
 *    - Real-time replication
 *    - Near-zero RPO
 *    - Requires replication infrastructure
 */
```

### 3.2 Backup Strategy Implementation

```java
@Service
class BackupService {
    
    @Autowired
    private DatabaseService databaseService;
    
    @Autowired
    private StorageService storageService;
    
    /**
     * Backup Strategy:
     * 
     * - Full backup: Daily at 2 AM
     * - Incremental backup: Every 6 hours
     * - Backup retention: 30 days
     * - Offsite backup: Weekly
     */
    
    @Scheduled(cron = "0 0 2 * * ?") // Daily at 2 AM
    public void performFullBackup() {
        String backupId = UUID.randomUUID().toString();
        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME);
        
        try {
            // Create full database backup
            String backupPath = databaseService.createFullBackup();
            
            // Upload to storage
            String storagePath = storageService.uploadBackup(backupPath, 
                "full-backup-" + timestamp + ".sql");
            
            // Store backup metadata
            BackupMetadata metadata = new BackupMetadata(
                backupId,
                BackupType.FULL,
                storagePath,
                timestamp,
                calculateBackupSize(backupPath)
            );
            
            backupRepository.save(metadata);
            
            // Cleanup old backups
            cleanupOldBackups(30); // Keep 30 days
            
            log.info("Full backup completed: {}", backupId);
        } catch (Exception e) {
            log.error("Full backup failed", e);
            alertService.sendAlert("Backup failed: " + e.getMessage());
        }
    }
    
    @Scheduled(cron = "0 0 */6 * * ?") // Every 6 hours
    public void performIncrementalBackup() {
        String backupId = UUID.randomUUID().toString();
        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME);
        
        try {
            // Get last backup timestamp
            BackupMetadata lastBackup = backupRepository.findLatestBackup();
            
            // Create incremental backup
            String backupPath = databaseService.createIncrementalBackup(
                lastBackup.getTimestamp());
            
            // Upload to storage
            String storagePath = storageService.uploadBackup(backupPath,
                "incremental-backup-" + timestamp + ".sql");
            
            // Store backup metadata
            BackupMetadata metadata = new BackupMetadata(
                backupId,
                BackupType.INCREMENTAL,
                storagePath,
                timestamp,
                calculateBackupSize(backupPath)
            );
            
            backupRepository.save(metadata);
            
            log.info("Incremental backup completed: {}", backupId);
        } catch (Exception e) {
            log.error("Incremental backup failed", e);
            alertService.sendAlert("Incremental backup failed: " + e.getMessage());
        }
    }
    
    public void restoreFromBackup(String backupId, RestoreOptions options) {
        BackupMetadata backup = backupRepository.findById(backupId)
            .orElseThrow(() -> new BackupNotFoundException(backupId));
        
        try {
            // Download backup from storage
            String backupPath = storageService.downloadBackup(backup.getStoragePath());
            
            // Restore database
            if (backup.getType() == BackupType.FULL) {
                databaseService.restoreFullBackup(backupPath, options);
            } else {
                // For incremental, need to restore full backup first
                BackupMetadata fullBackup = findFullBackupBefore(backup.getTimestamp());
                restoreFromBackup(fullBackup.getId(), options);
                databaseService.restoreIncrementalBackup(backupPath, options);
            }
            
            log.info("Restore completed from backup: {}", backupId);
        } catch (Exception e) {
            log.error("Restore failed", e);
            throw new RestoreException("Failed to restore from backup: " + backupId, e);
        }
    }
    
    private void cleanupOldBackups(int retentionDays) {
        LocalDateTime cutoff = LocalDateTime.now().minusDays(retentionDays);
        List<BackupMetadata> oldBackups = backupRepository.findByTimestampBefore(cutoff);
        
        for (BackupMetadata backup : oldBackups) {
            storageService.deleteBackup(backup.getStoragePath());
            backupRepository.delete(backup);
        }
    }
}

enum BackupType {
    FULL, INCREMENTAL, DIFFERENTIAL
}

class BackupMetadata {
    private String id;
    private BackupType type;
    private String storagePath;
    private String timestamp;
    private long size;
    // Getters and setters
}
```

### 3.3 Database Replication for DR

```java
@Configuration
class DatabaseReplicationConfig {
    
    /**
     * Database Replication Strategy:
     * 
     * Primary Region (us-east-1):
     *   - Primary database (writes)
     *   - Synchronous replication to secondary region
     * 
     * Secondary Region (us-west-2):
     *   - Standby database (read-only)
     *   - Automatic failover capability
     */
    
    @Bean
    @Primary
    public DataSource primaryDataSource() {
        // Primary database in us-east-1
        return DataSourceBuilder.create()
            .url("jdbc:postgresql://primary-db.us-east-1.rds.amazonaws.com:5432/mydb")
            .username("admin")
            .password("password")
            .build();
    }
    
    @Bean
    public DataSource standbyDataSource() {
        // Standby database in us-west-2
        return DataSourceBuilder.create()
            .url("jdbc:postgresql://standby-db.us-west-2.rds.amazonaws.com:5432/mydb")
            .username("admin")
            .password("password")
            .build();
    }
    
    @Bean
    public ReplicationDataSource replicationDataSource() {
        ReplicationRoutingDataSource routing = new ReplicationRoutingDataSource();
        
        Map<Object, Object> dataSourceMap = new HashMap<>();
        dataSourceMap.put("primary", primaryDataSource());
        dataSourceMap.put("standby", standbyDataSource());
        
        routing.setTargetDataSources(dataSourceMap);
        routing.setDefaultTargetDataSource(primaryDataSource());
        
        return routing;
    }
}

class ReplicationRoutingDataSource extends AbstractRoutingDataSource {
    
    @Autowired
    private HealthCheckService healthCheckService;
    
    @Override
    protected Object determineCurrentLookupKey() {
        // Check if primary is healthy
        if (healthCheckService.isPrimaryHealthy()) {
            return "primary";
        } else {
            // Failover to standby
            log.warn("Primary database unhealthy, failing over to standby");
            return "standby";
        }
    }
}
```

---

## 4. Reliability Patterns

### 4.1 Reliability Pattern Overview

```java
/**
 * Reliability Patterns:
 * 
 * 1. Circuit Breaker:
 *    - Prevents cascading failures
 *    - Fails fast when service is down
 *    - Allows recovery attempts
 * 
 * 2. Retry with Backoff:
 *    - Handles transient failures
 *    - Exponential backoff
 *    - Jitter to avoid thundering herd
 * 
 * 3. Timeout:
 *    - Prevents hanging requests
 *    - Resource cleanup
 *    - Fast failure detection
 * 
 * 4. Bulkhead:
 *    - Isolates failures
 *    - Resource isolation
 *    - Prevents cascading failures
 * 
 * 5. Graceful Degradation:
 *    - Partial functionality
 *    - Fallback mechanisms
 *    - User experience preservation
 */
```

---

## 5. Circuit Breaker Pattern

### 5.1 Circuit Breaker States

```java
/**
 * Circuit Breaker States:
 * 
 * 1. CLOSED (Normal):
 *    - Requests pass through
 *    - Monitor failures
 *    - Open circuit if threshold exceeded
 * 
 * 2. OPEN (Failing):
 *    - Requests fail immediately
 *    - No calls to failing service
 *    - After timeout, move to HALF_OPEN
 * 
 * 3. HALF_OPEN (Testing):
 *    - Allow limited requests
 *    - If successful, close circuit
 *    - If failed, open circuit again
 */
```

### 5.2 Circuit Breaker Implementation

```java
@Service
class CircuitBreakerService {
    
    @Autowired
    private CircuitBreakerRegistry circuitBreakerRegistry;
    
    private CircuitBreaker paymentCircuitBreaker;
    private CircuitBreaker inventoryCircuitBreaker;
    
    @PostConstruct
    public void init() {
        // Payment Gateway Circuit Breaker
        paymentCircuitBreaker = circuitBreakerRegistry.circuitBreaker("payment-gateway",
            CircuitBreakerConfig.custom()
                .failureRateThreshold(50)              // Open after 50% failures
                .waitDurationInOpenState(Duration.ofSeconds(30))  // Wait 30s before half-open
                .slidingWindowSize(10)                 // Last 10 calls
                .minimumNumberOfCalls(5)               // Need at least 5 calls
                .permittedNumberOfCallsInHalfOpenState(3)  // Allow 3 calls in half-open
                .automaticTransitionFromOpenToHalfOpenEnabled(true)
                .recordExceptions(IOException.class, TimeoutException.class)
                .ignoreExceptions(BusinessException.class)  // Don't count business exceptions
                .build());
        
        // Inventory Service Circuit Breaker
        inventoryCircuitBreaker = circuitBreakerRegistry.circuitBreaker("inventory-service",
            CircuitBreakerConfig.custom()
                .failureRateThreshold(60)
                .waitDurationInOpenState(Duration.ofSeconds(60))
                .slidingWindowSize(20)
                .minimumNumberOfCalls(10)
                .build());
    }
    
    public PaymentResult processPayment(PaymentRequest request) {
        return paymentCircuitBreaker.executeSupplier(() -> {
            // Call payment gateway
            return paymentGateway.charge(request);
        }, throwable -> {
            // Fallback when circuit is open
            return handlePaymentFallback(request, throwable);
        });
    }
    
    private PaymentResult handlePaymentFallback(PaymentRequest request, Throwable throwable) {
        log.warn("Payment gateway unavailable, using fallback", throwable);
        
        // Fallback strategies:
        // 1. Queue for later processing
        queuePaymentForRetry(request);
        
        // 2. Return cached payment method
        // 3. Use alternative payment provider
        // 4. Return error with retry suggestion
        
        return new PaymentResult(false, "Payment queued for processing");
    }
    
    public InventoryStatus checkInventory(String productId, int quantity) {
        return inventoryCircuitBreaker.executeSupplier(() -> {
            return inventoryService.checkAvailability(productId, quantity);
        }, throwable -> {
            // Fallback: Assume available (optimistic)
            log.warn("Inventory service unavailable, assuming available", throwable);
            return new InventoryStatus(true, "Service unavailable, assuming available");
        });
    }
}
```

### 5.3 Circuit Breaker with Resilience4j

```java
@Configuration
class Resilience4jConfig {
    
    @Bean
    public CircuitBreakerRegistry circuitBreakerRegistry() {
        return CircuitBreakerRegistry.ofDefaults();
    }
    
    @Bean
    public RetryRegistry retryRegistry() {
        return RetryRegistry.ofDefaults();
    }
    
    @Bean
    public TimeLimiterRegistry timeLimiterRegistry() {
        return TimeLimiterRegistry.ofDefaults();
    }
    
    @Bean
    public BulkheadRegistry bulkheadRegistry() {
        return BulkheadRegistry.ofDefaults();
    }
}

@Service
class ResilientService {
    
    @Autowired
    private CircuitBreakerRegistry circuitBreakerRegistry;
    
    @Autowired
    private RetryRegistry retryRegistry;
    
    @Autowired
    private TimeLimiterRegistry timeLimiterRegistry;
    
    @Autowired
    private BulkheadRegistry bulkheadRegistry;
    
    private CircuitBreaker circuitBreaker;
    private Retry retry;
    private TimeLimiter timeLimiter;
    private Bulkhead bulkhead;
    
    @PostConstruct
    public void init() {
        // Circuit Breaker
        circuitBreaker = circuitBreakerRegistry.circuitBreaker("external-service",
            CircuitBreakerConfig.custom()
                .failureRateThreshold(50)
                .waitDurationInOpenState(Duration.ofSeconds(30))
                .slidingWindowSize(10)
                .build());
        
        // Retry
        retry = retryRegistry.retry("external-service",
            RetryConfig.custom()
                .maxAttempts(3)
                .waitDuration(Duration.ofSeconds(1))
                .exponentialBackoffMultiplier(2)
                .build());
        
        // Time Limiter
        timeLimiter = timeLimiterRegistry.timeLimiter("external-service",
            TimeLimiterConfig.custom()
                .timeoutDuration(Duration.ofSeconds(5))
                .build());
        
        // Bulkhead
        bulkhead = bulkheadRegistry.bulkhead("external-service",
            BulkheadConfig.custom()
                .maxConcurrentCalls(10)
                .maxWaitDuration(Duration.ofSeconds(1))
                .build());
    }
    
    public String callExternalService(String data) {
        // Combine all resilience patterns
        Supplier<String> decoratedSupplier = CircuitBreaker.decorateSupplier(
            circuitBreaker,
            Retry.decorateSupplier(
                retry,
                TimeLimiter.decorateSupplier(
                    timeLimiter,
                    Bulkhead.decorateSupplier(
                        bulkhead,
                        () -> externalService.call(data)
                    )
                )
            )
        );
        
        return Try.ofSupplier(decoratedSupplier)
            .recover(throwable -> {
                log.error("All resilience patterns failed", throwable);
                return "Fallback response";
            })
            .get();
    }
}
```

---

## 6. Retry Pattern with Exponential Backoff

### 6.1 Retry Strategy

```java
/**
 * Retry Strategy Components:
 * 
 * 1. Max Attempts:
 *    - Maximum number of retries
 *    - Prevent infinite loops
 * 
 * 2. Backoff Strategy:
 *    - Fixed: Same delay between retries
 *    - Exponential: Delay doubles each retry
 *    - Linear: Delay increases linearly
 * 
 * 3. Jitter:
 *    - Random variation in delay
 *    - Prevents thundering herd
 *    - Spreads retry attempts
 * 
 * 4. Retryable Exceptions:
 *    - Which exceptions to retry
 *    - Transient vs permanent failures
 */
```

### 6.2 Retry Implementation

```java
@Service
class RetryService {
    
    @Autowired
    private RetryRegistry retryRegistry;
    
    private Retry retry;
    
    @PostConstruct
    public void init() {
        retry = retryRegistry.retry("external-service",
            RetryConfig.custom()
                .maxAttempts(3)
                .waitDuration(Duration.ofSeconds(1))
                .exponentialBackoffMultiplier(2)  // 1s, 2s, 4s
                .randomizedWaitFactor(0.5)        // Add jitter
                .retryExceptions(IOException.class, TimeoutException.class)
                .ignoreExceptions(BusinessException.class)
                .build());
    }
    
    public String callWithRetry(String endpoint) {
        return retry.executeSupplier(() -> {
            return restTemplate.getForObject(endpoint, String.class);
        });
    }
    
    // Custom retry with exponential backoff
    public <T> T executeWithRetry(Supplier<T> operation, int maxAttempts) {
        int attempt = 0;
        Exception lastException = null;
        
        while (attempt < maxAttempts) {
            try {
                return operation.get();
            } catch (Exception e) {
                lastException = e;
                attempt++;
                
                if (attempt < maxAttempts && isRetryable(e)) {
                    long delay = calculateBackoff(attempt);
                    log.warn("Retry attempt {} after {}ms", attempt, delay, e);
                    
                    try {
                        Thread.sleep(delay);
                    } catch (InterruptedException ie) {
                        Thread.currentThread().interrupt();
                        throw new RuntimeException(ie);
                    }
                } else {
                    throw new RuntimeException("Max retries exceeded", lastException);
                }
            }
        }
        
        throw new RuntimeException("Max retries exceeded", lastException);
    }
    
    private boolean isRetryable(Exception e) {
        return e instanceof IOException ||
               e instanceof TimeoutException ||
               e instanceof HttpServerErrorException;
    }
    
    private long calculateBackoff(int attempt) {
        // Exponential backoff: 2^attempt seconds
        long baseDelay = (long) Math.pow(2, attempt) * 1000; // milliseconds
        
        // Add jitter: ±25%
        double jitter = (Math.random() - 0.5) * 0.5;
        long jitteredDelay = (long) (baseDelay * (1 + jitter));
        
        // Cap at 30 seconds
        return Math.min(jitteredDelay, 30000);
    }
}
```

### 6.3 Retry with Circuit Breaker

```java
@Service
class ResilientExternalService {
    
    @Autowired
    private CircuitBreakerRegistry circuitBreakerRegistry;
    
    @Autowired
    private RetryRegistry retryRegistry;
    
    public String callService(String data) {
        CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker("service");
        Retry retry = retryRegistry.retry("service");
        
        // Combine retry with circuit breaker
        Supplier<String> decorated = Retry.decorateSupplier(
            retry,
            CircuitBreaker.decorateSupplier(
                circuitBreaker,
                () -> externalService.call(data)
            )
        );
        
        return Try.ofSupplier(decorated)
            .recover(throwable -> {
                log.error("Service call failed after retries", throwable);
                return "Fallback response";
            })
            .get();
    }
}
```

---

## 7. Graceful Degradation

### 7.1 Graceful Degradation Strategy

```java
/**
 * Graceful Degradation Levels:
 * 
 * 1. Full Functionality:
 *    - All features available
 *    - Optimal performance
 * 
 * 2. Reduced Functionality:
 *    - Core features available
 *    - Non-essential features disabled
 * 
 * 3. Minimal Functionality:
 *    - Critical features only
 *    - Read-only mode
 * 
 * 4. Maintenance Mode:
 *    - System unavailable
 *    - Display maintenance message
 */
```

### 7.2 Graceful Degradation Implementation

```java
@Service
class OrderServiceWithDegradation {
    
    @Autowired
    private PaymentService paymentService;
    
    @Autowired
    private InventoryService inventoryService;
    
    @Autowired
    private RecommendationService recommendationService;
    
    @Autowired
    private CircuitBreakerRegistry circuitBreakerRegistry;
    
    public OrderResponse createOrder(OrderRequest request) {
        OrderResponse response = new OrderResponse();
        
        // Core functionality: Create order
        Order order = orderRepository.save(new Order(request));
        response.setOrder(order);
        
        // Feature 1: Payment processing (Critical)
        try {
            PaymentResult payment = paymentService.processPayment(
                new PaymentRequest(order.getId(), order.getTotal()));
            response.setPaymentStatus(payment.getStatus());
        } catch (Exception e) {
            log.error("Payment processing failed", e);
            // Degrade: Queue payment for later
            paymentQueue.enqueue(order.getId());
            response.setPaymentStatus("QUEUED");
            response.addWarning("Payment will be processed shortly");
        }
        
        // Feature 2: Inventory check (Important)
        try {
            InventoryStatus inventory = inventoryService.checkAvailability(
                order.getProductId(), order.getQuantity());
            if (!inventory.isAvailable()) {
                throw new InsufficientInventoryException();
            }
        } catch (Exception e) {
            log.error("Inventory check failed", e);
            // Degrade: Skip inventory check, process anyway
            response.addWarning("Inventory check unavailable, order will be verified later");
        }
        
        // Feature 3: Recommendations (Nice to have)
        try {
            List<Product> recommendations = recommendationService.getRecommendations(
                order.getUserId());
            response.setRecommendations(recommendations);
        } catch (Exception e) {
            log.warn("Recommendations unavailable", e);
            // Degrade: Return empty recommendations
            response.setRecommendations(Collections.emptyList());
            // No warning needed for non-critical feature
        }
        
        return response;
    }
}

@Service
class ProductServiceWithDegradation {
    
    @Autowired
    private ProductRepository productRepository;
    
    @Autowired
    private ReviewService reviewService;
    
    @Autowired
    private ImageService imageService;
    
    public ProductResponse getProduct(String productId) {
        ProductResponse response = new ProductResponse();
        
        // Core: Product data (Always available)
        Product product = productRepository.findById(productId)
            .orElseThrow(() -> new ProductNotFoundException(productId));
        response.setProduct(product);
        
        // Feature 1: Reviews (Important)
        try {
            List<Review> reviews = reviewService.getReviews(productId);
            response.setReviews(reviews);
        } catch (Exception e) {
            log.warn("Reviews unavailable", e);
            response.setReviews(Collections.emptyList());
            response.addInfo("Reviews temporarily unavailable");
        }
        
        // Feature 2: High-res images (Nice to have)
        try {
            List<String> highResImages = imageService.getHighResImages(productId);
            response.setHighResImages(highResImages);
        } catch (Exception e) {
            log.warn("High-res images unavailable", e);
            // Fallback to low-res images
            response.setHighResImages(product.getDefaultImages());
        }
        
        return response;
    }
}
```

### 7.3 Feature Flags for Degradation

```java
@Service
class FeatureFlagService {
    
    @Autowired
    private FeatureFlagRepository featureFlagRepository;
    
    public boolean isFeatureEnabled(String featureName, String userId) {
        FeatureFlag flag = featureFlagRepository.findByName(featureName);
        
        if (flag == null || !flag.isEnabled()) {
            return false;
        }
        
        // Check user-specific rules
        if (flag.getUserIds() != null && flag.getUserIds().contains(userId)) {
            return true;
        }
        
        // Check percentage rollout
        if (flag.getRolloutPercentage() > 0) {
            int hash = userId.hashCode();
            return Math.abs(hash % 100) < flag.getRolloutPercentage();
        }
        
        return flag.isEnabled();
    }
    
    public void enableDegradationMode(String featureName) {
        FeatureFlag flag = featureFlagRepository.findByName(featureName);
        if (flag != null) {
            flag.setEnabled(false);
            featureFlagRepository.save(flag);
            log.info("Feature {} disabled for graceful degradation", featureName);
        }
    }
}

@Service
class OrderServiceWithFeatureFlags {
    
    @Autowired
    private FeatureFlagService featureFlagService;
    
    @Autowired
    private RecommendationService recommendationService;
    
    public OrderResponse createOrder(OrderRequest request) {
        OrderResponse response = new OrderResponse();
        
        // Check if recommendations are enabled
        if (featureFlagService.isFeatureEnabled("recommendations", request.getUserId())) {
            try {
                List<Product> recommendations = recommendationService.getRecommendations(
                    request.getUserId());
                response.setRecommendations(recommendations);
            } catch (Exception e) {
                log.error("Recommendations failed, disabling feature", e);
                // Disable feature flag to prevent further failures
                featureFlagService.enableDegradationMode("recommendations");
            }
        }
        
        return response;
    }
}
```

---

## 8. Practical Examples

### 8.1 Complete Resilience Implementation

```java
@Configuration
class ResilienceConfiguration {
    
    @Bean
    public CircuitBreakerRegistry circuitBreakerRegistry() {
        return CircuitBreakerRegistry.ofDefaults();
    }
    
    @Bean
    public RetryRegistry retryRegistry() {
        return RetryRegistry.ofDefaults();
    }
    
    @Bean
    public TimeLimiterRegistry timeLimiterRegistry() {
        return TimeLimiterRegistry.ofDefaults();
    }
}

@Service
class ResilientOrderService {
    
    @Autowired
    private CircuitBreakerRegistry circuitBreakerRegistry;
    
    @Autowired
    private RetryRegistry retryRegistry;
    
    @Autowired
    private TimeLimiterRegistry timeLimiterRegistry;
    
    private CircuitBreaker paymentCircuitBreaker;
    private Retry paymentRetry;
    private TimeLimiter paymentTimeLimiter;
    
    @PostConstruct
    public void init() {
        // Payment service resilience
        paymentCircuitBreaker = circuitBreakerRegistry.circuitBreaker("payment-service",
            CircuitBreakerConfig.custom()
                .failureRateThreshold(50)
                .waitDurationInOpenState(Duration.ofSeconds(30))
                .slidingWindowSize(10)
                .build());
        
        paymentRetry = retryRegistry.retry("payment-service",
            RetryConfig.custom()
                .maxAttempts(3)
                .waitDuration(Duration.ofSeconds(1))
                .exponentialBackoffMultiplier(2)
                .build());
        
        paymentTimeLimiter = timeLimiterRegistry.timeLimiter("payment-service",
            TimeLimiterConfig.custom()
                .timeoutDuration(Duration.ofSeconds(5))
                .build());
    }
    
    public Order createOrder(OrderRequest request) {
        // Create order
        Order order = orderRepository.save(new Order(request));
        
        // Process payment with resilience
        try {
            PaymentResult payment = processPaymentWithResilience(order);
            order.setPaymentStatus(payment.getStatus());
        } catch (Exception e) {
            log.error("Payment processing failed after all retries", e);
            // Graceful degradation: Queue for later
            order.setPaymentStatus("QUEUED");
            paymentQueue.enqueue(order.getId());
        }
        
        return order;
    }
    
    private PaymentResult processPaymentWithResilience(Order order) {
        Supplier<PaymentResult> paymentSupplier = () -> 
            paymentService.processPayment(new PaymentRequest(order.getId(), order.getTotal()));
        
        // Combine all resilience patterns
        Supplier<PaymentResult> decorated = TimeLimiter.decorateSupplier(
            paymentTimeLimiter,
            Retry.decorateSupplier(
                paymentRetry,
                CircuitBreaker.decorateSupplier(
                    paymentCircuitBreaker,
                    paymentSupplier
                )
            )
        );
        
        return Try.ofSupplier(decorated)
            .recover(throwable -> {
                log.error("Payment failed", throwable);
                throw new PaymentException("Payment processing failed", throwable);
            })
            .get();
    }
}
```

---

## Summary: Part 2

### Key Takeaways

1. **RTO/RPO**: Define recovery objectives based on business needs
2. **Backup Strategy**: Full, incremental, continuous backups
3. **Circuit Breaker**: Prevent cascading failures
4. **Retry Pattern**: Handle transient failures with exponential backoff
5. **Graceful Degradation**: Maintain partial functionality during failures

### Next Steps

**Part 3** will cover:
- Chaos Engineering
- Resilience Testing
- Failure Injection
- Chaos Monkey Implementation

---

**Master disaster recovery and reliability patterns for resilient systems!**

