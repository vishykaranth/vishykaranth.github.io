# Principal Engineer: Mastering Performance and Scalability Optimization

## Part 1: Performance Profiling and Optimization Fundamentals

---

## Table of Contents

1. [Understanding Performance Optimization](#1-understanding-performance-optimization)
2. [Performance Profiling Tools and Techniques](#2-performance-profiling-tools-and-techniques)
3. [JVM Performance Tuning](#3-jvm-performance-tuning)
4. [Application-Level Optimization](#4-application-level-optimization)
5. [Code-Level Performance Patterns](#5-code-level-performance-patterns)
6. [Practical Examples and Case Studies](#6-practical-examples-and-case-studies)

---

## 1. Understanding Performance Optimization

### 1.1 Performance Metrics

**Key Performance Indicators (KPIs)**:

```java
/**
 * Performance Metrics to Track:
 * 
 * 1. Latency (Response Time):
 *    - P50 (Median): 50% of requests
 *    - P95: 95% of requests
 *    - P99: 99% of requests
 *    - P99.9: 99.9% of requests (tail latency)
 * 
 * 2. Throughput:
 *    - Requests per second (RPS)
 *    - Transactions per second (TPS)
 *    - Operations per second (OPS)
 * 
 * 3. Resource Utilization:
 *    - CPU usage (%)
 *    - Memory usage (MB/GB)
 *    - Network I/O (Mbps)
 *    - Disk I/O (IOPS)
 * 
 * 4. Error Rates:
 *    - Error percentage
 *    - Timeout rate
 *    - Failure rate
 * 
 * 5. Business Metrics:
 *    - User experience (page load time)
 *    - Conversion rate
 *    - Revenue impact
 */
```

### 1.2 Performance Optimization Principles

**The 80/20 Rule (Pareto Principle)**:
```java
/**
 * Performance Optimization Strategy:
 * 
 * 1. Measure First:
 *    - Profile before optimizing
 *    - Identify bottlenecks (80% of time in 20% of code)
 *    - Don't optimize prematurely
 * 
 * 2. Focus on Hot Paths:
 *    - Optimize frequently executed code
 *    - Critical path optimization
 *    - High-impact changes
 * 
 * 3. Trade-offs:
 *    - Performance vs. Maintainability
 *    - Performance vs. Complexity
 *    - Performance vs. Cost
 * 
 * 4. Iterative Approach:
 *    - Measure → Optimize → Measure
 *    - Continuous improvement
 *    - A/B testing
 */
```

### 1.3 Performance Optimization Lifecycle

```java
/**
 * Performance Optimization Lifecycle:
 * 
 * Phase 1: Baseline Measurement
 *   - Establish current performance metrics
 *   - Identify performance goals
 *   - Set SLAs/SLOs
 * 
 * Phase 2: Profiling
 *   - Identify bottlenecks
 *   - CPU profiling
 *   - Memory profiling
 *   - I/O profiling
 * 
 * Phase 3: Analysis
 *   - Root cause analysis
 *   - Performance bottleneck identification
 *   - Impact assessment
 * 
 * Phase 4: Optimization
 *   - Implement optimizations
 *   - Code changes
 *   - Configuration tuning
 *   - Architecture changes
 * 
 * Phase 5: Validation
 *   - Performance testing
 *   - Load testing
 *   - Stress testing
 *   - Compare with baseline
 * 
 * Phase 6: Monitoring
 *   - Continuous monitoring
 *   - Performance regression detection
 *   - Alerting
 */
```

---

## 2. Performance Profiling Tools and Techniques

### 2.1 JVM Profiling Tools

**1. Java Flight Recorder (JFR)**

```java
/**
 * Java Flight Recorder Setup:
 * 
 * 1. Enable JFR at JVM startup:
 *    -XX:+FlightRecorder
 *    -XX:StartFlightRecording=duration=60s,filename=profile.jfr
 * 
 * 2. Programmatic Recording:
 */
public class JFRProfiling {
    
    public void startProfiling() {
        try (Recording recording = new Recording()) {
            recording.setName("Performance Profile");
            recording.start();
            
            // Your application code
            performOperation();
            
            recording.stop();
            recording.dump(Paths.get("profile.jfr"));
        }
    }
    
    private void performOperation() {
        // Code to profile
    }
}

/**
 * 3. Analyze with JMC (Java Mission Control):
 *    - CPU usage
 *    - Memory allocation
 *    - Method profiling
 *    - Thread analysis
 */
```

**2. VisualVM**

```java
/**
 * VisualVM Profiling:
 * 
 * Features:
 * - CPU profiling
 * - Memory profiling
 * - Thread analysis
 * - Heap dump analysis
 * - MBean browser
 * 
 * Usage:
 * 1. Connect to running JVM
 * 2. Enable profiling
 * 3. Analyze results
 */
```

**3. Async Profiler**

```java
/**
 * Async Profiler Setup:
 * 
 * 1. Download async-profiler
 * 2. Attach to running JVM:
 *    java -jar async-profiler.jar -e cpu -d 60 -f profile.html <pid>
 * 
 * 3. Flame Graph Generation:
 *    - CPU flame graphs
 *    - Memory allocation flame graphs
 *    - Lock contention flame graphs
 */
```

### 2.2 Application Performance Monitoring (APM)

**New Relic Integration**:
```java
@Configuration
class NewRelicConfig {
    
    /**
     * New Relic APM:
     * 
     * - Automatic instrumentation
     * - Transaction tracing
     * - Database query analysis
     * - External service calls
     * - Error tracking
     */
}

// Custom instrumentation
@Service
class InstrumentedService {
    
    @NewRelicTransaction
    public void performOperation() {
        // Automatically traced
    }
    
    @Trace(dispatcher = true)
    public String criticalMethod() {
        // Custom trace
        return "result";
    }
}
```

**Datadog APM**:
```java
@Configuration
class DatadogConfig {
    
    /**
     * Datadog APM:
     * 
     * - Distributed tracing
     * - Service maps
     * - Performance metrics
     * - Error tracking
     */
}

@Service
class TracedService {
    
    @Trace
    public void tracedMethod() {
        // Automatically traced by Datadog
    }
}
```

### 2.3 Custom Performance Monitoring

**Custom Metrics Collection**:
```java
@Component
class PerformanceMonitor {
    
    private final MeterRegistry meterRegistry;
    private final Timer requestTimer;
    private final Counter errorCounter;
    private final Gauge activeConnections;
    
    public PerformanceMonitor(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.requestTimer = Timer.builder("http.requests")
            .description("HTTP request duration")
            .publishPercentiles(0.5, 0.95, 0.99, 0.999)
            .register(meterRegistry);
        this.errorCounter = Counter.builder("http.errors")
            .description("HTTP errors")
            .register(meterRegistry);
        this.activeConnections = Gauge.builder("db.connections.active")
            .description("Active database connections")
            .register(meterRegistry, this, PerformanceMonitor::getActiveConnections);
    }
    
    public <T> T measure(String operation, Supplier<T> supplier) {
        Timer.Sample sample = Timer.start(meterRegistry);
        try {
            return supplier.get();
        } finally {
            sample.stop(requestTimer);
        }
    }
    
    public void recordError() {
        errorCounter.increment();
    }
    
    private double getActiveConnections() {
        return dataSource.getActiveConnections();
    }
}

// Usage
@Service
class MonitoredService {
    
    @Autowired
    private PerformanceMonitor monitor;
    
    public User getUser(String id) {
        return monitor.measure("getUser", () -> {
            try {
                return userRepository.findById(id);
            } catch (Exception e) {
                monitor.recordError();
                throw e;
            }
        });
    }
}
```

**Method-Level Profiling**:
```java
@Aspect
@Component
class PerformanceProfilingAspect {
    
    private static final Logger logger = LoggerFactory.getLogger(PerformanceProfilingAspect.class);
    private static final long SLOW_METHOD_THRESHOLD = 100; // milliseconds
    
    @Around("@annotation(Profiled)")
    public Object profileMethod(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().toShortString();
        long startTime = System.currentTimeMillis();
        
        try {
            Object result = joinPoint.proceed();
            long duration = System.currentTimeMillis() - startTime;
            
            if (duration > SLOW_METHOD_THRESHOLD) {
                logger.warn("Slow method detected: {} took {}ms", methodName, duration);
            }
            
            // Record metric
            recordMetric(methodName, duration);
            
            return result;
        } catch (Throwable e) {
            long duration = System.currentTimeMillis() - startTime;
            logger.error("Method {} failed after {}ms", methodName, duration, e);
            throw e;
        }
    }
    
    private void recordMetric(String methodName, long duration) {
        // Record to metrics system
    }
}

// Usage
@Service
class ProfiledService {
    
    @Profiled
    public void performOperation() {
        // Automatically profiled
    }
}
```

---

## 3. JVM Performance Tuning

### 3.1 Garbage Collection Tuning

**G1 GC Configuration**:
```bash
# G1 GC Tuning for High-Throughput Applications
-XX:+UseG1GC
-XX:MaxGCPauseMillis=200          # Target pause time
-XX:G1HeapRegionSize=16m          # Region size
-XX:InitiatingHeapOccupancyPercent=45  # When to start GC
-XX:ConcGCThreads=4               # Concurrent GC threads
-XX:ParallelGCThreads=8          # Parallel GC threads
-XX:G1ReservePercent=10           # Reserve for promotion
```

**ZGC Configuration (Low Latency)**:
```bash
# ZGC for Ultra-Low Latency
-XX:+UseZGC
-XX:+UnlockExperimentalVMOptions
-Xmx16g
-Xms16g
-XX:+UseLargePages
```

**Shenandoah GC Configuration**:
```bash
# Shenandoah for Low Pause Times
-XX:+UseShenandoahGC
-XX:ShenandoahGCHeuristics=adaptive
-XX:ShenandoahGuaranteedGCInterval=10000
```

### 3.2 Memory Tuning

**Heap Size Configuration**:
```java
/**
 * Memory Tuning Guidelines:
 * 
 * 1. Initial Heap Size (-Xms):
 *    - Set equal to max heap (-Xmx)
 *    - Prevents heap resizing overhead
 *    - Example: -Xms4g -Xmx4g
 * 
 * 2. Heap Size Calculation:
 *    - Old Generation: 2/3 of heap
 *    - Young Generation: 1/3 of heap
 *    - Eden: 80% of Young
 *    - Survivor: 10% each
 * 
 * 3. Metaspace:
 *    - -XX:MetaspaceSize=256m
 *    - -XX:MaxMetaspaceSize=512m
 * 
 * 4. Direct Memory:
 *    - -XX:MaxDirectMemorySize=1g
 */
```

**Memory Profiling**:
```java
@Component
class MemoryProfiler {
    
    private final MemoryMXBean memoryBean;
    private final List<GarbageCollectorMXBean> gcBeans;
    
    public MemoryProfiler() {
        this.memoryBean = ManagementFactory.getMemoryMXBean();
        this.gcBeans = ManagementFactory.getGarbageCollectorMXBeans();
    }
    
    public void logMemoryUsage() {
        MemoryUsage heapUsage = memoryBean.getHeapMemoryUsage();
        MemoryUsage nonHeapUsage = memoryBean.getNonHeapMemoryUsage();
        
        logger.info("Heap Memory: {} / {} ({}%)",
            formatBytes(heapUsage.getUsed()),
            formatBytes(heapUsage.getMax()),
            (heapUsage.getUsed() * 100 / heapUsage.getMax()));
        
        logger.info("Non-Heap Memory: {} / {}",
            formatBytes(nonHeapUsage.getUsed()),
            formatBytes(nonHeapUsage.getMax()));
        
        // GC Statistics
        for (GarbageCollectorMXBean gcBean : gcBeans) {
            logger.info("GC {}: Count={}, Time={}ms",
                gcBean.getName(),
                gcBean.getCollectionCount(),
                gcBean.getCollectionTime());
        }
    }
    
    public void generateHeapDump() {
        try {
            String fileName = "heap-dump-" + System.currentTimeMillis() + ".hprof";
            memoryBean.dumpHeap(fileName, true);
            logger.info("Heap dump created: {}", fileName);
        } catch (IOException e) {
            logger.error("Failed to create heap dump", e);
        }
    }
}
```

### 3.3 Thread and Concurrency Tuning

**Thread Pool Configuration**:
```java
@Configuration
class ThreadPoolConfig {
    
    /**
     * Thread Pool Sizing:
     * 
     * CPU-bound tasks:
     *   threads = CPU cores + 1
     * 
     * I/O-bound tasks:
     *   threads = CPU cores * (1 + wait_time / service_time)
     * 
     * Example: 8 cores, 50ms wait, 5ms service
     *   threads = 8 * (1 + 50/5) = 8 * 11 = 88
     */
    
    @Bean
    public ThreadPoolTaskExecutor cpuBoundExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        int cores = Runtime.getRuntime().availableProcessors();
        executor.setCorePoolSize(cores);
        executor.setMaxPoolSize(cores + 1);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("cpu-bound-");
        executor.initialize();
        return executor;
    }
    
    @Bean
    public ThreadPoolTaskExecutor ioBoundExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        int cores = Runtime.getRuntime().availableProcessors();
        // For I/O-bound: cores * (1 + wait/service)
        executor.setCorePoolSize(cores * 2);
        executor.setMaxPoolSize(cores * 10);
        executor.setQueueCapacity(500);
        executor.setThreadNamePrefix("io-bound-");
        executor.initialize();
        return executor;
    }
}
```

**Lock Contention Profiling**:
```java
@Component
class LockContentionProfiler {
    
    private final Map<String, AtomicLong> lockWaitTimes = new ConcurrentHashMap<>();
    
    public <T> T profileLock(String lockName, Supplier<T> operation) {
        long startTime = System.nanoTime();
        try {
            return operation.get();
        } finally {
            long waitTime = System.nanoTime() - startTime;
            lockWaitTimes.computeIfAbsent(lockName, k -> new AtomicLong())
                .addAndGet(waitTime);
        }
    }
    
    public void logLockStatistics() {
        lockWaitTimes.forEach((lockName, totalWait) -> {
            logger.warn("Lock {}: Total wait time = {}ms",
                lockName, totalWait.get() / 1_000_000);
        });
    }
}
```

---

## 4. Application-Level Optimization

### 4.1 Caching Strategies

**Multi-Level Caching**:
```java
@Service
class OptimizedProductService {
    
    @Autowired
    private ProductRepository productRepository;
    
    @Autowired
    private RedisTemplate<String, Product> redisTemplate;
    
    @Autowired
    private CaffeineCache localCache;
    
    private static final String CACHE_KEY_PREFIX = "product:";
    private static final Duration REDIS_TTL = Duration.ofHours(1);
    private static final Duration LOCAL_TTL = Duration.ofMinutes(5);
    
    /**
     * Multi-Level Cache Strategy:
     * 
     * L1: Local Cache (Caffeine) - Fastest, limited size
     * L2: Redis Cache - Distributed, larger size
     * L3: Database - Source of truth
     */
    
    public Product getProduct(String id) {
        // L1: Check local cache
        Product cached = localCache.getIfPresent(id);
        if (cached != null) {
            return cached; // Cache hit
        }
        
        // L2: Check Redis
        String cacheKey = CACHE_KEY_PREFIX + id;
        cached = redisTemplate.opsForValue().get(cacheKey);
        if (cached != null) {
            // Populate L1 cache
            localCache.put(id, cached);
            return cached;
        }
        
        // L3: Database
        Product product = productRepository.findById(id)
            .orElseThrow(() -> new NotFoundException("Product not found"));
        
        // Populate both caches
        localCache.put(id, product);
        redisTemplate.opsForValue().set(cacheKey, product, REDIS_TTL);
        
        return product;
    }
}
```

**Cache Warming**:
```java
@Component
class CacheWarmer {
    
    @Autowired
    private ProductService productService;
    
    @PostConstruct
    public void warmCache() {
        // Warm cache on startup
        List<String> popularProductIds = getPopularProductIds();
        
        popularProductIds.parallelStream()
            .forEach(productId -> {
                try {
                    productService.getProduct(productId);
                } catch (Exception e) {
                    logger.warn("Failed to warm cache for product: {}", productId);
                }
            });
    }
    
    private List<String> getPopularProductIds() {
        // Get from analytics or configuration
        return Arrays.asList("product1", "product2", "product3");
    }
}
```

### 4.2 Database Query Optimization

**Query Optimization Techniques**:
```java
@Repository
class OptimizedUserRepository {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    /**
     * Query Optimization Techniques:
     * 
     * 1. Use Indexes:
     *    - Create indexes on frequently queried columns
     *    - Composite indexes for multi-column queries
     *    - Covering indexes for SELECT queries
     * 
     * 2. Avoid N+1 Queries:
     *    - Use JOINs instead of multiple queries
     *    - Batch fetching
     *    - Eager loading for related entities
     * 
     * 3. Pagination:
     *    - Use LIMIT/OFFSET or cursor-based pagination
     *    - Avoid deep pagination
     * 
     * 4. Query Caching:
     *    - Cache frequently executed queries
     *    - Invalidate on updates
     */
    
    // Optimized: Single query with JOIN
    public List<UserWithOrders> getUsersWithOrders() {
        String sql = """
            SELECT u.id, u.name, u.email, o.id as order_id, o.total
            FROM users u
            LEFT JOIN orders o ON u.id = o.user_id
            WHERE u.status = 'ACTIVE'
            """;
        
        return jdbcTemplate.query(sql, new UserWithOrdersRowMapper());
    }
    
    // Optimized: Batch insert
    public void saveAll(List<User> users) {
        String sql = "INSERT INTO users (id, name, email) VALUES (?, ?, ?)";
        
        jdbcTemplate.batchUpdate(sql, users, 100, (ps, user) -> {
            ps.setString(1, user.getId());
            ps.setString(2, user.getName());
            ps.setString(3, user.getEmail());
        });
    }
    
    // Optimized: Cursor-based pagination
    public List<User> getUsersAfter(String lastId, int limit) {
        String sql = "SELECT * FROM users WHERE id > ? ORDER BY id LIMIT ?";
        return jdbcTemplate.query(sql, new Object[]{lastId, limit}, new UserRowMapper());
    }
}
```

**Connection Pool Optimization**:
```java
@Configuration
class DatabaseConfig {
    
    @Bean
    public DataSource dataSource() {
        HikariConfig config = new HikariConfig();
        
        // Connection pool sizing
        // Formula: connections = ((core_count * 2) + effective_spindle_count)
        int cores = Runtime.getRuntime().availableProcessors();
        config.setMaximumPoolSize(cores * 2 + 1);
        config.setMinimumIdle(cores);
        
        // Performance settings
        config.setConnectionTimeout(30000);
        config.setIdleTimeout(600000);
        config.setMaxLifetime(1800000);
        config.setLeakDetectionThreshold(60000);
        
        // Query optimization
        config.addDataSourceProperty("cachePrepStmts", "true");
        config.addDataSourceProperty("prepStmtCacheSize", "250");
        config.addDataSourceProperty("prepStmtCacheSqlLimit", "2048");
        config.addDataSourceProperty("useServerPrepStmts", "true");
        config.addDataSourceProperty("rewriteBatchedStatements", "true");
        
        return new HikariDataSource(config);
    }
}
```

### 4.3 Async Processing

**Async Operations**:
```java
@Service
class AsyncOrderService {
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private EmailService emailService;
    
    @Autowired
    private NotificationService notificationService;
    
    /**
     * Async Processing Strategy:
     * 
     * 1. Identify non-critical operations
     * 2. Move to async processing
     * 3. Use thread pools
     * 4. Handle errors gracefully
     */
    
    public Order createOrder(OrderRequest request) {
        // Synchronous: Critical path
        Order order = orderRepository.save(new Order(request));
        
        // Asynchronous: Non-critical operations
        CompletableFuture.runAsync(() -> {
            try {
                emailService.sendOrderConfirmation(order);
            } catch (Exception e) {
                logger.error("Failed to send email", e);
            }
        });
        
        CompletableFuture.runAsync(() -> {
            try {
                notificationService.sendPushNotification(order);
            } catch (Exception e) {
                logger.error("Failed to send notification", e);
            }
        });
        
        return order;
    }
}
```

---

## 5. Code-Level Performance Patterns

### 5.1 Object Creation Optimization

**Object Pooling**:
```java
@Component
class ObjectPoolManager {
    
    private final Map<Class<?>, GenericObjectPool<?>> pools = new ConcurrentHashMap<>();
    
    @SuppressWarnings("unchecked")
    public <T> T borrowObject(Class<T> clazz, Supplier<T> factory) {
        GenericObjectPool<T> pool = (GenericObjectPool<T>) pools.computeIfAbsent(
            clazz,
            k -> new GenericObjectPool<>(new BasePooledObjectFactory<T>() {
                @Override
                public T create() throws Exception {
                    return factory.get();
                }
                
                @Override
                public PooledObject<T> wrap(T obj) {
                    return new DefaultPooledObject<>(obj);
                }
            })
        );
        
        try {
            return pool.borrowObject();
        } catch (Exception e) {
            throw new RuntimeException("Failed to borrow object", e);
        }
    }
    
    public <T> void returnObject(Class<T> clazz, T obj) {
        @SuppressWarnings("unchecked")
        GenericObjectPool<T> pool = (GenericObjectPool<T>) pools.get(clazz);
        if (pool != null) {
            pool.returnObject(obj);
        }
    }
}
```

**String Optimization**:
```java
class StringOptimization {
    
    /**
     * String Optimization Techniques:
     * 
     * 1. Use StringBuilder for concatenation in loops
     * 2. Avoid string concatenation with +
     * 3. Use String.format() sparingly
     * 4. Reuse String objects when possible
     */
    
    // Bad: Creates many intermediate strings
    public String badConcatenation(List<String> items) {
        String result = "";
        for (String item : items) {
            result += item; // Creates new string each time
        }
        return result;
    }
    
    // Good: Uses StringBuilder
    public String goodConcatenation(List<String> items) {
        StringBuilder sb = new StringBuilder();
        for (String item : items) {
            sb.append(item);
        }
        return sb.toString();
    }
    
    // Best: Use String.join() for simple cases
    public String bestConcatenation(List<String> items) {
        return String.join("", items);
    }
}
```

### 5.2 Collection Optimization

**Collection Selection**:
```java
class CollectionOptimization {
    
    /**
     * Collection Selection Guide:
     * 
     * 1. ArrayList: Random access, frequent iteration
     * 2. LinkedList: Frequent insertions/deletions in middle
     * 3. HashSet: Fast lookups, no duplicates
     * 4. TreeSet: Sorted, range queries
     * 5. HashMap: Fast key-value lookups
     * 6. ConcurrentHashMap: Thread-safe HashMap
     */
    
    // Optimize initial capacity
    public void optimizedListCreation(int expectedSize) {
        // Pre-size to avoid resizing
        List<String> list = new ArrayList<>(expectedSize);
    }
    
    // Use appropriate collection
    public Set<String> optimizedSet(int expectedSize) {
        // HashSet for O(1) lookups
        return new HashSet<>(expectedSize);
    }
    
    // Use ConcurrentHashMap for thread-safe operations
    public Map<String, Object> threadSafeMap() {
        return new ConcurrentHashMap<>();
    }
}
```

### 5.3 Algorithm Optimization

**Algorithm Selection**:
```java
class AlgorithmOptimization {
    
    /**
     * Algorithm Optimization:
     * 
     * 1. Choose right algorithm for problem
     * 2. Optimize hot paths
     * 3. Use efficient data structures
     * 4. Avoid unnecessary computations
     */
    
    // O(n log n) sorting
    public List<Integer> sortList(List<Integer> list) {
        return list.stream()
            .sorted()
            .collect(Collectors.toList());
    }
    
    // O(n) for finding max
    public int findMax(List<Integer> list) {
        return list.stream()
            .mapToInt(Integer::intValue)
            .max()
            .orElse(0);
    }
    
    // O(1) lookup with HashMap
    public boolean containsFast(Map<String, String> map, String key) {
        return map.containsKey(key);
    }
}
```

---

## 6. Practical Examples and Case Studies

### 6.1 Performance Optimization Case Study: API Response Time

**Problem**: API response time was 2 seconds, target is <200ms

**Analysis**:
```java
/**
 * Performance Analysis:
 * 
 * 1. Profiling revealed:
 *    - Database query: 1500ms (75%)
 *    - External API call: 400ms (20%)
 *    - Business logic: 100ms (5%)
 * 
 * 2. Root causes:
 *    - N+1 query problem
 *    - Missing database indexes
 *    - Synchronous external calls
 *    - No caching
 */
```

**Solution**:
```java
@Service
class OptimizedApiService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private ExternalServiceClient externalServiceClient;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    // Before: 2000ms
    public UserResponse getUserData(String userId) {
        // N+1 queries
        User user = userRepository.findById(userId);
        List<Order> orders = orderRepository.findByUserId(userId);
        for (Order order : orders) {
            order.setItems(itemRepository.findByOrderId(order.getId()));
        }
        
        // Synchronous external call
        ExternalData data = externalServiceClient.getData(userId);
        
        return new UserResponse(user, orders, data);
    }
    
    // After: 150ms (13x improvement)
    @Cacheable(value = "users", key = "#userId")
    public UserResponse getUserDataOptimized(String userId) {
        // Single query with JOIN
        UserWithOrders user = userRepository.findUserWithOrders(userId);
        
        // Async external call
        CompletableFuture<ExternalData> externalDataFuture = 
            CompletableFuture.supplyAsync(() -> 
                externalServiceClient.getData(userId));
        
        // Process in parallel
        UserResponse response = new UserResponse(user, user.getOrders());
        
        // Get external data (non-blocking)
        ExternalData data = externalDataFuture.join();
        response.setExternalData(data);
        
        return response;
    }
}
```

### 6.2 Memory Optimization Case Study

**Problem**: OutOfMemoryError, high GC pressure

**Analysis**:
```java
/**
 * Memory Analysis:
 * 
 * 1. Heap dump analysis revealed:
 *    - Large object arrays (50% of heap)
 *    - String duplication (20% of heap)
 *    - Unclosed resources (10% of heap)
 * 
 * 2. GC analysis:
 *    - Frequent Full GC (every 30 seconds)
 *    - Long GC pauses (500ms)
 */
```

**Solution**:
```java
@Service
class MemoryOptimizedService {
    
    // Before: High memory usage
    public void processLargeDataset(List<Data> data) {
        // Loads all data into memory
        List<ProcessedData> processed = data.stream()
            .map(this::process)
            .collect(Collectors.toList());
        
        // Process all at once
        saveAll(processed);
    }
    
    // After: Streaming, lower memory
    public void processLargeDatasetOptimized(List<Data> data) {
        // Stream processing
        data.stream()
            .map(this::process)
            .forEach(batch -> {
                // Process in batches
                if (batch.size() >= 1000) {
                    saveBatch(batch);
                    batch.clear();
                }
            });
    }
    
    // Use object pooling for frequently created objects
    @Autowired
    private ObjectPoolManager objectPool;
    
    public void processWithPooling() {
        ExpensiveObject obj = objectPool.borrowObject(ExpensiveObject.class, 
            ExpensiveObject::new);
        try {
            // Use object
            obj.process();
        } finally {
            objectPool.returnObject(ExpensiveObject.class, obj);
        }
    }
}
```

---

## Summary: Part 1

### Key Takeaways

1. **Measure First**: Profile before optimizing
2. **Identify Bottlenecks**: 80% of time in 20% of code
3. **Use Right Tools**: JFR, VisualVM, APM tools
4. **JVM Tuning**: GC selection, memory configuration
5. **Application Optimization**: Caching, async processing, query optimization
6. **Code Patterns**: Object pooling, string optimization, algorithm selection

### Next Steps

**Part 2** will cover:
- Scalability Patterns (Horizontal, Vertical, Caching)
- Database Optimization (Queries, Indexing, Connection Pooling)
- Load Testing and Capacity Planning
- System Architecture for Scale

---

**Master performance profiling and optimization to achieve 5-10x performance improvements!**

