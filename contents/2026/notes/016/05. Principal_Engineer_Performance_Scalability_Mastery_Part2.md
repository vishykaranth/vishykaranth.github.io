# Principal Engineer: Mastering Performance and Scalability Optimization

## Part 2: Scalability Patterns (Horizontal, Vertical, Caching)

---

## Table of Contents

1. [Horizontal Scaling Patterns](#1-horizontal-scaling-patterns)
2. [Vertical Scaling Strategies](#2-vertical-scaling-strategies)
3. [Advanced Caching Patterns](#3-advanced-caching-patterns)
4. [Stateless Design Patterns](#4-stateless-design-patterns)
5. [Load Distribution Strategies](#5-load-distribution-strategies)
6. [Practical Implementation Examples](#6-practical-implementation-examples)

---

## 1. Horizontal Scaling Patterns

### 1.1 Understanding Horizontal Scaling

**Horizontal Scaling Architecture**:
```
Before Scaling:
┌─────────────────┐
│  Single Server  │
│  1000 req/s      │
└─────────────────┘

After Horizontal Scaling:
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│ Server1 │  │ Server2 │  │ Server3 │  │ Server4 │
│ 250/s   │  │ 250/s   │  │ 250/s   │  │ 250/s   │
└────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘
     └────────────┼────────────┼────────────┘
                  ▼
         ┌──────────────┐
         │ Load Balancer│
         └──────────────┘
```

**Key Principles**:
```java
/**
 * Horizontal Scaling Requirements:
 * 
 * 1. Stateless Application:
 *    - No server-side sessions
 *    - State in external store (Redis, DB)
 *    - Any server can handle any request
 * 
 * 2. Shared State:
 *    - Database (shared)
 *    - Cache (Redis cluster)
 *    - Message queue (Kafka)
 * 
 * 3. Load Balancing:
 *    - Distribute requests evenly
 *    - Health checks
 *    - Session affinity (if needed)
 * 
 * 4. Auto-Scaling:
 *    - Scale based on metrics
 *    - CPU, memory, request rate
 *    - Predictive scaling
 */
```

### 1.2 Stateless Application Design

**Session Management**:
```java
/**
 * Stateless Session Management:
 * 
 * Option 1: JWT Tokens (Recommended)
 * Option 2: Redis Session Store
 * Option 3: Database Session Store
 */

// JWT Token Approach
@Service
class StatelessAuthService {
    
    private final JwtTokenProvider tokenProvider;
    
    public String authenticate(String username, String password) {
        User user = userService.authenticate(username, password);
        
        // Generate JWT token (stateless)
        return tokenProvider.generateToken(user);
    }
    
    public User validateToken(String token) {
        return tokenProvider.validateToken(token);
    }
}

// Redis Session Store (Alternative)
@Service
class RedisSessionService {
    
    @Autowired
    private RedisTemplate<String, SessionData> redisTemplate;
    
    public String createSession(User user) {
        String sessionId = UUID.randomUUID().toString();
        SessionData sessionData = new SessionData(user);
        
        // Store in Redis (shared across servers)
        redisTemplate.opsForValue().set(
            "session:" + sessionId,
            sessionData,
            Duration.ofHours(24)
        );
        
        return sessionId;
    }
    
    public SessionData getSession(String sessionId) {
        return redisTemplate.opsForValue().get("session:" + sessionId);
    }
}
```

**State Externalization**:
```java
@Service
class StatelessOrderService {
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private RedisTemplate<String, ShoppingCart> redisTemplate;
    
    /**
     * Stateless Design:
     * 
     * 1. No in-memory state
     * 2. All state in database/cache
     * 3. Any server can process any request
     */
    
    public void addToCart(String userId, String productId, int quantity) {
        // Store cart in Redis (shared state)
        String cartKey = "cart:" + userId;
        ShoppingCart cart = redisTemplate.opsForValue().get(cartKey);
        
        if (cart == null) {
            cart = new ShoppingCart(userId);
        }
        
        cart.addItem(productId, quantity);
        redisTemplate.opsForValue().set(cartKey, cart, Duration.ofDays(7));
    }
    
    public Order checkout(String userId) {
        // Get cart from Redis
        String cartKey = "cart:" + userId;
        ShoppingCart cart = redisTemplate.opsForValue().get(cartKey);
        
        if (cart == null || cart.isEmpty()) {
            throw new EmptyCartException();
        }
        
        // Create order (stateless operation)
        Order order = new Order(userId, cart.getItems());
        order = orderRepository.save(order);
        
        // Clear cart
        redisTemplate.delete(cartKey);
        
        return order;
    }
}
```

### 1.3 Auto-Scaling Implementation

**Kubernetes Horizontal Pod Autoscaler**:
```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: user-service-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: user-service
  minReplicas: 2
  maxReplicas: 20
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  - type: Pods
    pods:
      metric:
        name: http_requests_per_second
      target:
        type: AverageValue
        averageValue: "100"
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 0
      policies:
      - type: Percent
        value: 100
        periodSeconds: 15
      - type: Pods
        value: 4
        periodSeconds: 15
      selectPolicy: Max
```

**AWS Auto Scaling Group**:
```java
@Configuration
class AutoScalingConfig {
    
    /**
     * Auto-Scaling Configuration:
     * 
     * 1. Scaling Policies:
     *    - Target Tracking: Maintain target metric
     *    - Step Scaling: Scale by steps
     *    - Scheduled Scaling: Time-based scaling
     * 
     * 2. Metrics:
     *    - CPU utilization
     *    - Memory utilization
     *    - Request count
     *    - Custom metrics
     * 
     * 3. Cooldown Periods:
     *    - Scale-up cooldown: 2 minutes
     *    - Scale-down cooldown: 5 minutes
     */
}

// CloudFormation/CFN Template
/*
AutoScalingGroup:
  MinSize: 2
  MaxSize: 20
  DesiredCapacity: 4
  TargetTrackingScalingPolicy:
    PredefinedMetricSpecification:
      PredefinedMetricType: ASGAverageCPUUtilization
    TargetValue: 70.0
    ScaleInCooldown: 300
    ScaleOutCooldown: 60
*/
```

**Custom Auto-Scaling Logic**:
```java
@Component
class CustomAutoScaler {
    
    @Autowired
    private KubernetesClient kubernetesClient;
    
    @Autowired
    private MetricsService metricsService;
    
    @Scheduled(fixedRate = 30000) // Check every 30 seconds
    public void checkAndScale() {
        // Get current metrics
        double cpuUtilization = metricsService.getAverageCpuUtilization();
        int requestRate = metricsService.getRequestRate();
        int currentReplicas = getCurrentReplicas();
        
        // Scaling decision logic
        if (shouldScaleUp(cpuUtilization, requestRate, currentReplicas)) {
            scaleUp();
        } else if (shouldScaleDown(cpuUtilization, requestRate, currentReplicas)) {
            scaleDown();
        }
    }
    
    private boolean shouldScaleUp(double cpu, int requests, int replicas) {
        return (cpu > 70 || requests > replicas * 100) && replicas < 20;
    }
    
    private boolean shouldScaleDown(double cpu, int requests, int replicas) {
        return cpu < 30 && requests < replicas * 50 && replicas > 2;
    }
    
    private void scaleUp() {
        int current = getCurrentReplicas();
        setReplicas(Math.min(current + 2, 20));
    }
    
    private void scaleDown() {
        int current = getCurrentReplicas();
        setReplicas(Math.max(current - 1, 2));
    }
}
```

---

## 2. Vertical Scaling Strategies

### 2.1 When to Use Vertical Scaling

**Vertical Scaling Use Cases**:
```java
/**
 * Vertical Scaling Scenarios:
 * 
 * 1. Single-Instance Applications:
 *    - Legacy applications
 *    - Applications with stateful connections
 *    - Applications not designed for horizontal scaling
 * 
 * 2. Resource-Intensive Tasks:
 *    - CPU-intensive computations
 *    - Memory-intensive processing
 *    - Large dataset processing
 * 
 * 3. Cost Optimization:
 *    - Lower cost for steady workloads
 *    - Reserved instances
 *    - No load balancer needed
 * 
 * 4. Quick Scaling:
 *    - Faster than horizontal scaling
 *    - No code changes required
 *    - Immediate resource increase
 */
```

**Vertical Scaling Configuration**:
```java
@Configuration
class VerticalScalingConfig {
    
    /**
     * Vertical Scaling Strategy:
     * 
     * 1. CPU Scaling:
     *    - 2 cores → 4 cores → 8 cores → 16 cores
     *    - Monitor CPU utilization
     *    - Scale when consistently > 80%
     * 
     * 2. Memory Scaling:
     *    - 4GB → 8GB → 16GB → 32GB
     *    - Monitor memory usage
     *    - Scale when > 85% utilization
     * 
     * 3. Storage Scaling:
     *    - Increase disk size
     *    - Use faster storage (SSD)
     *    - Add more IOPS
     */
}

// JVM Memory Configuration
/*
# Small Instance
-Xms2g -Xmx2g

# Medium Instance
-Xms4g -Xmx4g

# Large Instance
-Xms8g -Xmx8g

# Extra Large Instance
-Xms16g -Xmx16g
*/
```

### 2.2 Vertical Scaling Implementation

**Dynamic Resource Adjustment**:
```java
@Component
class VerticalScalingManager {
    
    @Autowired
    private CloudProviderClient cloudClient;
    
    @Autowired
    private MetricsService metricsService;
    
    /**
     * Vertical Scaling Decision Logic:
     * 
     * Scale Up When:
     * - CPU > 80% for 5 minutes
     * - Memory > 85% for 5 minutes
     * - Request queue depth > threshold
     * 
     * Scale Down When:
     * - CPU < 40% for 15 minutes
     * - Memory < 50% for 15 minutes
     * - Low request rate
     */
    
    @Scheduled(fixedRate = 60000) // Check every minute
    public void evaluateScaling() {
        double cpuUtilization = metricsService.getCpuUtilization();
        double memoryUtilization = metricsService.getMemoryUtilization();
        int queueDepth = metricsService.getQueueDepth();
        
        if (shouldScaleUp(cpuUtilization, memoryUtilization, queueDepth)) {
            scaleUp();
        } else if (shouldScaleDown(cpuUtilization, memoryUtilization)) {
            scaleDown();
        }
    }
    
    private boolean shouldScaleUp(double cpu, double memory, int queue) {
        return (cpu > 80 || memory > 85 || queue > 1000);
    }
    
    private boolean shouldScaleDown(double cpu, double memory) {
        return cpu < 40 && memory < 50;
    }
    
    private void scaleUp() {
        InstanceType currentType = getCurrentInstanceType();
        InstanceType nextType = getNextLargerType(currentType);
        
        if (nextType != null) {
            cloudClient.resizeInstance(getInstanceId(), nextType);
            logger.info("Scaling up to: {}", nextType);
        }
    }
    
    private void scaleDown() {
        InstanceType currentType = getCurrentInstanceType();
        InstanceType nextType = getNextSmallerType(currentType);
        
        if (nextType != null && canScaleDown()) {
            cloudClient.resizeInstance(getInstanceId(), nextType);
            logger.info("Scaling down to: {}", nextType);
        }
    }
}
```

---

## 3. Advanced Caching Patterns

### 3.1 Multi-Layer Caching Architecture

**Caching Hierarchy**:
```java
/**
 * Multi-Layer Caching:
 * 
 * L1: Browser Cache (Client-side)
 *    - Static assets
 *    - Long TTL (1 year)
 * 
 * L2: CDN Cache (Edge)
 *    - Geographic distribution
 *    - Medium TTL (1 hour)
 * 
 * L3: Application Cache (In-Memory)
 *    - Caffeine/Guava
 *    - Short TTL (5 minutes)
 *    - Fast access
 * 
 * L4: Distributed Cache (Redis)
 *    - Shared across servers
 *    - Medium TTL (1 hour)
 * 
 * L5: Database Query Cache
 *    - Query result cache
 *    - Short TTL (1 minute)
 */
```

**Implementation**:
```java
@Service
class MultiLayerCacheService {
    
    @Autowired
    private ProductRepository productRepository;
    
    @Autowired
    private RedisTemplate<String, Product> redisTemplate;
    
    @Autowired
    private CaffeineCache localCache;
    
    private static final String CACHE_KEY_PREFIX = "product:";
    
    /**
     * Multi-Layer Cache Strategy:
     * 
     * 1. Check L3 (Local Cache) - Fastest
     * 2. Check L4 (Redis) - Fast
     * 3. Check L5 (Database Query Cache) - Medium
     * 4. Query Database - Slowest
     * 5. Populate all caches
     */
    
    public Product getProduct(String id) {
        // L3: Local cache
        Product cached = localCache.getIfPresent(id);
        if (cached != null) {
            return cached;
        }
        
        // L4: Redis cache
        String cacheKey = CACHE_KEY_PREFIX + id;
        cached = redisTemplate.opsForValue().get(cacheKey);
        if (cached != null) {
            // Populate L3
            localCache.put(id, cached);
            return cached;
        }
        
        // L5: Database (with query cache if enabled)
        Product product = productRepository.findById(id)
            .orElseThrow(() -> new NotFoundException("Product not found"));
        
        // Populate all caches
        localCache.put(id, product);
        redisTemplate.opsForValue().set(cacheKey, product, Duration.ofHours(1));
        
        return product;
    }
}
```

### 3.2 Cache-Aside Pattern

**Implementation**:
```java
@Service
class CacheAsideService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private RedisTemplate<String, User> redisTemplate;
    
    private static final String CACHE_KEY_PREFIX = "user:";
    private static final Duration CACHE_TTL = Duration.ofHours(1);
    
    /**
     * Cache-Aside Pattern:
     * 
     * Read:
     * 1. Check cache
     * 2. If miss, read from database
     * 3. Write to cache
     * 
     * Write:
     * 1. Write to database
     * 2. Invalidate cache
     */
    
    public User getUser(String id) {
        // 1. Check cache
        String cacheKey = CACHE_KEY_PREFIX + id;
        User cached = redisTemplate.opsForValue().get(cacheKey);
        
        if (cached != null) {
            return cached; // Cache hit
        }
        
        // 2. Cache miss - read from database
        User user = userRepository.findById(id)
            .orElseThrow(() -> new NotFoundException("User not found"));
        
        // 3. Write to cache
        redisTemplate.opsForValue().set(cacheKey, user, CACHE_TTL);
        
        return user;
    }
    
    public User updateUser(User user) {
        // 1. Update database
        User updated = userRepository.save(user);
        
        // 2. Invalidate cache
        String cacheKey = CACHE_KEY_PREFIX + user.getId();
        redisTemplate.delete(cacheKey);
        
        return updated;
    }
    
    public void deleteUser(String id) {
        // 1. Delete from database
        userRepository.deleteById(id);
        
        // 2. Delete from cache
        String cacheKey = CACHE_KEY_PREFIX + id;
        redisTemplate.delete(cacheKey);
    }
}
```

### 3.3 Write-Through Pattern

```java
@Service
class WriteThroughService {
    
    @Autowired
    private ProductRepository productRepository;
    
    @Autowired
    private RedisTemplate<String, Product> redisTemplate;
    
    /**
     * Write-Through Pattern:
     * 
     * Write:
     * 1. Write to cache
     * 2. Write to database
     * 3. Both must succeed
     * 
     * Read:
     * 1. Read from cache (always fresh)
     */
    
    public Product createProduct(Product product) {
        // 1. Write to cache first
        String cacheKey = "product:" + product.getId();
        redisTemplate.opsForValue().set(cacheKey, product, Duration.ofHours(1));
        
        // 2. Write to database
        Product saved = productRepository.save(product);
        
        return saved;
    }
    
    public Product updateProduct(Product product) {
        // 1. Update cache
        String cacheKey = "product:" + product.getId();
        redisTemplate.opsForValue().set(cacheKey, product, Duration.ofHours(1));
        
        // 2. Update database
        return productRepository.save(product);
    }
}
```

### 3.4 Write-Behind Pattern

```java
@Service
class WriteBehindService {
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private RedisTemplate<String, Order> redisTemplate;
    
    private final BlockingQueue<Order> writeQueue = new LinkedBlockingQueue<>();
    
    @PostConstruct
    public void init() {
        // Background thread for batch writes
        new Thread(this::batchWriteToDatabase).start();
    }
    
    /**
     * Write-Behind Pattern:
     * 
     * Write:
     * 1. Write to cache immediately
     * 2. Queue for database write
     * 3. Batch write to database asynchronously
     * 
     * Benefits:
     * - Fast writes (cache only)
     * - Reduced database load
     * - Better performance
     */
    
    public Order createOrder(Order order) {
        // 1. Write to cache immediately
        String cacheKey = "order:" + order.getId();
        redisTemplate.opsForValue().set(cacheKey, order, Duration.ofDays(7));
        
        // 2. Queue for database write
        writeQueue.offer(order);
        
        return order;
    }
    
    private void batchWriteToDatabase() {
        List<Order> batch = new ArrayList<>();
        
        while (true) {
            try {
                // Collect orders for batch write
                Order order = writeQueue.poll(5, TimeUnit.SECONDS);
                if (order != null) {
                    batch.add(order);
                }
                
                // Batch write when size reaches threshold or timeout
                if (batch.size() >= 100 || (order == null && !batch.isEmpty())) {
                    orderRepository.saveAll(batch);
                    batch.clear();
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }
}
```

### 3.5 Cache Invalidation Strategies

**Time-Based Expiration**:
```java
@Service
class TimeBasedCacheService {
    
    @Cacheable(value = "products", 
               key = "#id",
               unless = "#result == null")
    public Product getProduct(String id) {
        return productRepository.findById(id).orElse(null);
    }
    
    // Cache expires after configured TTL
}

@Configuration
class CacheConfig {
    
    @Bean
    public CacheManager cacheManager() {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofHours(1)) // TTL
            .serializeValuesWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new GenericJackson2JsonRedisSerializer()));
        
        return RedisCacheManager.builder(redisConnectionFactory())
            .cacheDefaults(config)
            .build();
    }
}
```

**Event-Based Invalidation**:
```java
@Component
class CacheInvalidationListener {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @EventListener
    public void handleProductUpdated(ProductUpdatedEvent event) {
        // Invalidate specific cache
        redisTemplate.delete("product:" + event.getProductId());
        
        // Invalidate related caches
        redisTemplate.delete("products:list");
        redisTemplate.delete("products:category:" + event.getCategoryId());
    }
    
    @EventListener
    public void handleUserUpdated(UserUpdatedEvent event) {
        // Invalidate user cache
        redisTemplate.delete("user:" + event.getUserId());
        
        // Invalidate user-related caches
        redisTemplate.delete("user:" + event.getUserId() + ":orders");
    }
}
```

**Manual Invalidation**:
```java
@Service
class ManualCacheService {
    
    @CacheEvict(value = "products", key = "#product.id")
    public Product updateProduct(Product product) {
        return productRepository.save(product);
    }
    
    @CacheEvict(value = "products", allEntries = true)
    public void clearAllProductsCache() {
        // All product caches cleared
    }
    
    @CacheEvict(value = "products", key = "#id")
    public void deleteProduct(String id) {
        productRepository.deleteById(id);
    }
}
```

---

## 4. Stateless Design Patterns

### 4.1 Session Management

**JWT-Based Authentication**:
```java
@Service
class JwtAuthService {
    
    private final JwtTokenProvider tokenProvider;
    
    public String authenticate(String username, String password) {
        User user = userService.authenticate(username, password);
        
        // Generate stateless JWT token
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", user.getId());
        claims.put("roles", user.getRoles());
        
        return tokenProvider.generateToken(claims);
    }
    
    public User validateToken(String token) {
        Claims claims = tokenProvider.validateToken(token);
        String userId = claims.get("userId", String.class);
        return userService.getUser(userId);
    }
}
```

**Redis Session Store**:
```java
@Service
class RedisSessionService {
    
    @Autowired
    private RedisTemplate<String, SessionData> redisTemplate;
    
    public String createSession(User user) {
        String sessionId = UUID.randomUUID().toString();
        SessionData sessionData = new SessionData(user);
        
        // Store in Redis (shared across servers)
        redisTemplate.opsForValue().set(
            "session:" + sessionId,
            sessionData,
            Duration.ofHours(24)
        );
        
        return sessionId;
    }
    
    public SessionData getSession(String sessionId) {
        return redisTemplate.opsForValue().get("session:" + sessionId);
    }
    
    public void invalidateSession(String sessionId) {
        redisTemplate.delete("session:" + sessionId);
    }
}
```

### 4.2 State Externalization

**Shopping Cart in Redis**:
```java
@Service
class StatelessCartService {
    
    @Autowired
    private RedisTemplate<String, ShoppingCart> redisTemplate;
    
    public void addToCart(String userId, String productId, int quantity) {
        // Get cart from Redis (shared state)
        String cartKey = "cart:" + userId;
        ShoppingCart cart = redisTemplate.opsForValue().get(cartKey);
        
        if (cart == null) {
            cart = new ShoppingCart(userId);
        }
        
        cart.addItem(productId, quantity);
        
        // Save back to Redis
        redisTemplate.opsForValue().set(cartKey, cart, Duration.ofDays(7));
    }
    
    public ShoppingCart getCart(String userId) {
        String cartKey = "cart:" + userId;
        return redisTemplate.opsForValue().get(cartKey);
    }
}
```

---

## 5. Load Distribution Strategies

### 5.1 Load Balancing Algorithms

**Round Robin**:
```java
class RoundRobinLoadBalancer {
    private List<String> servers;
    private AtomicInteger currentIndex = new AtomicInteger(0);
    
    public RoundRobinLoadBalancer(List<String> servers) {
        this.servers = new ArrayList<>(servers);
    }
    
    public String getNextServer() {
        int index = currentIndex.getAndIncrement() % servers.size();
        return servers.get(index);
    }
}
```

**Least Connections**:
```java
class LeastConnectionsLoadBalancer {
    private Map<String, AtomicInteger> serverConnections = new ConcurrentHashMap<>();
    
    public LeastConnectionsLoadBalancer(List<String> servers) {
        servers.forEach(server -> 
            serverConnections.put(server, new AtomicInteger(0)));
    }
    
    public String getNextServer() {
        return serverConnections.entrySet().stream()
            .min(Map.Entry.comparingByValue(Comparator.comparing(AtomicInteger::get)))
            .map(Map.Entry::getKey)
            .orElse(null);
    }
    
    public void incrementConnections(String server) {
        serverConnections.get(server).incrementAndGet();
    }
    
    public void decrementConnections(String server) {
        serverConnections.get(server).decrementAndGet();
    }
}
```

**Weighted Round Robin**:
```java
class WeightedRoundRobinLoadBalancer {
    private List<ServerWeight> servers;
    private AtomicInteger currentWeight = new AtomicInteger(0);
    private AtomicInteger currentIndex = new AtomicInteger(-1);
    
    static class ServerWeight {
        String server;
        int weight;
        AtomicInteger currentWeight = new AtomicInteger(0);
        
        ServerWeight(String server, int weight) {
            this.server = server;
            this.weight = weight;
        }
    }
    
    public String getNextServer() {
        int totalWeight = servers.stream()
            .mapToInt(s -> s.weight)
            .sum();
        
        while (true) {
            int index = currentIndex.incrementAndGet() % servers.size();
            
            if (index == 0) {
                int weight = currentWeight.addAndGet(-totalWeight);
                if (weight <= 0) {
                    currentWeight.set(totalWeight);
                }
            }
            
            ServerWeight server = servers.get(index);
            int serverWeight = server.currentWeight.addAndGet(server.weight);
            
            if (serverWeight >= currentWeight.get()) {
                return server.server;
            }
        }
    }
}
```

---

## 6. Practical Implementation Examples

### 6.1 Scalable E-Commerce Platform

**Complete Architecture**:
```java
/**
 * Scalable E-Commerce Platform:
 * 
 * 1. Load Balancer:
 *    - Application Load Balancer
 *    - Health checks
 *    - SSL termination
 * 
 * 2. Application Servers (Horizontal Scaling):
 *    - Stateless design
 *    - Auto-scaling (2-20 instances)
 *    - Session in Redis
 * 
 * 3. Caching Layer:
 *    - Redis cluster
 *    - Multi-layer caching
 *    - Cache invalidation
 * 
 * 4. Database:
 *    - Primary (writes)
 *    - Read replicas (reads)
 *    - Connection pooling
 */
```

**Implementation**:
```java
@SpringBootApplication
public class ScalableECommerceApp {
    
    public static void main(String[] args) {
        SpringApplication.run(ScalableECommerceApp.class, args);
    }
}

@RestController
@RequestMapping("/api")
class ProductController {
    
    @Autowired
    private ProductService productService;
    
    @GetMapping("/products/{id}")
    public ResponseEntity<Product> getProduct(@PathVariable String id) {
        Product product = productService.getProduct(id);
        return ResponseEntity.ok(product);
    }
}

@Service
class ProductService {
    
    @Autowired
    private ProductRepository productRepository;
    
    @Autowired
    private RedisTemplate<String, Product> redisTemplate;
    
    @Cacheable(value = "products", key = "#id")
    public Product getProduct(String id) {
        // Multi-layer cache handled by Spring Cache
        return productRepository.findById(id)
            .orElseThrow(() -> new NotFoundException("Product not found"));
    }
}
```

---

## Summary: Part 2

### Key Takeaways

1. **Horizontal Scaling**: Stateless design, load balancing, auto-scaling
2. **Vertical Scaling**: Resource-intensive tasks, quick scaling
3. **Caching**: Multi-layer caching, cache patterns, invalidation
4. **Stateless Design**: JWT, Redis sessions, state externalization
5. **Load Distribution**: Round robin, least connections, weighted

### Next Steps

**Part 3** will cover:
- Database Optimization (Queries, Indexing, Connection Pooling)
- Query Performance Tuning
- Index Strategy
- Connection Pool Optimization

---

**Master scalability patterns to enable 30-50% infrastructure cost reduction!**

