# Security and Compliance Leadership for Principal Engineers

## Part 1: Security Architecture and Threat Modeling

---

## Table of Contents

1. [Security Architecture Fundamentals](#1-security-architecture-fundamentals)
2. [Threat Modeling Process](#2-threat-modeling-process)
3. [Security Design Patterns](#3-security-design-patterns)
4. [Secure System Architecture](#4-secure-system-architecture)
5. [Practical Examples](#5-practical-examples)

---

## 1. Security Architecture Fundamentals

### 1.1 Security Architecture Principles

**Core Principles**:

```java
/**
 * Security Architecture Principles:
 * 
 * 1. Defense in Depth:
 *    - Multiple layers of security
 *    - No single point of failure
 *    - Fail-secure defaults
 * 
 * 2. Least Privilege:
 *    - Minimum necessary permissions
 *    - Principle of least access
 *    - Role-based access control
 * 
 * 3. Zero Trust:
 *    - Never trust, always verify
 *    - Verify every request
 *    - Continuous authentication
 * 
 * 4. Secure by Default:
 *    - Secure configurations
 *    - Encryption by default
 *    - Security built-in
 * 
 * 5. Fail Securely:
 *    - Fail closed, not open
 *    - Error handling doesn't leak info
 *    - Secure error messages
 */
```

### 1.2 Security Architecture Layers

**Multi-Layer Security Architecture**:

```java
/**
 * Security Architecture Layers:
 * 
 * Layer 1: Network Security
 *    - Firewalls
 *    - DDoS protection
 *    - Network segmentation
 *    - VPN/Private networks
 * 
 * Layer 2: Application Security
 *    - Authentication
 *    - Authorization
 *    - Input validation
 *    - Output encoding
 * 
 * Layer 3: Data Security
 *    - Encryption at rest
 *    - Encryption in transit
 *    - Data masking
 *    - Access controls
 * 
 * Layer 4: Infrastructure Security
 *    - Secure configurations
 *    - Patch management
 *    - Security monitoring
 *    - Incident response
 */
```

### 1.3 Security Architecture Implementation

**Secure Application Architecture**:

```java
@Configuration
class SecurityArchitectureConfig {
    
    /**
     * Security Architecture Components:
     * 
     * 1. Authentication Layer
     * 2. Authorization Layer
     * 3. Input Validation Layer
     * 4. Encryption Layer
     * 5. Logging and Monitoring Layer
     */
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            // Authentication
            .authenticationProvider(authenticationProvider())
            
            // Authorization
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/public/**").permitAll()
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                .requestMatchers("/api/user/**").hasAnyRole("USER", "ADMIN")
                .anyRequest().authenticated()
            )
            
            // Session management
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .maximumSessions(1)
                .maxSessionsPreventsLogin(true)
            )
            
            // CSRF protection
            .csrf(csrf -> csrf
                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
            )
            
            // Headers security
            .headers(headers -> headers
                .contentSecurityPolicy("default-src 'self'")
                .frameOptions(FrameOptionsMode.DENY)
                .xssProtection(XssProtectionConfig::and)
            )
            
            // HTTPS enforcement
            .requiresChannel(channel -> channel
                .requestMatchers(r -> r.getHeader("X-Forwarded-Proto") != null)
                .requiresSecure()
            );
        
        return http.build();
    }
}
```

---

## 2. Threat Modeling Process

### 2.1 Threat Modeling Methodology

**STRIDE Threat Model**:

```java
/**
 * STRIDE Threat Model:
 * 
 * S - Spoofing:
 *    - Impersonating users or systems
 *    - Mitigation: Authentication, certificates
 * 
 * T - Tampering:
 *    - Modifying data or code
 *    - Mitigation: Integrity checks, signatures
 * 
 * R - Repudiation:
 *    - Denying actions
 *    - Mitigation: Logging, audit trails
 * 
 * I - Information Disclosure:
 *    - Exposing sensitive data
 *    - Mitigation: Encryption, access controls
 * 
 * D - Denial of Service:
 *    - Making system unavailable
 *    - Mitigation: Rate limiting, resource limits
 * 
 * E - Elevation of Privilege:
 *    - Gaining unauthorized access
 *    - Mitigation: Authorization, least privilege
 */
```

### 2.2 Threat Modeling Process

**Step-by-Step Threat Modeling**:

```java
/**
 * Threat Modeling Process:
 * 
 * Step 1: Identify Assets
 *    - Data assets (PII, financial data)
 *    - System assets (servers, databases)
 *    - Business assets (reputation, revenue)
 * 
 * Step 2: Create Architecture Diagram
 *    - System components
 *    - Data flows
 *    - Trust boundaries
 *    - External dependencies
 * 
 * Step 3: Identify Threats
 *    - Use STRIDE model
 *    - Attack trees
 *    - Threat intelligence
 * 
 * Step 4: Assess Risks
 *    - Likelihood (High/Medium/Low)
 *    - Impact (High/Medium/Low)
 *    - Risk = Likelihood Ã— Impact
 * 
 * Step 5: Mitigate Threats
 *    - Security controls
 *    - Design changes
 *    - Security requirements
 * 
 * Step 6: Validate
 *    - Security testing
 *    - Penetration testing
 *    - Code review
 */
```

### 2.3 Threat Modeling Example

**E-Commerce Application Threat Model**:

```java
/**
 * E-Commerce Application Threat Model:
 * 
 * Assets:
 *    - Customer PII (names, addresses, emails)
 *    - Payment card data (PCI-DSS)
 *    - Order history
 *    - User credentials
 * 
 * Threats:
 * 
 * 1. Spoofing:
 *    - Threat: Attacker impersonates user
 *    - Impact: Unauthorized access, data theft
 *    - Mitigation: Multi-factor authentication, strong passwords
 * 
 * 2. Tampering:
 *    - Threat: Modify order data, prices
 *    - Impact: Financial loss, data integrity
 *    - Mitigation: Input validation, authorization checks
 * 
 * 3. Repudiation:
 *    - Threat: User denies placing order
 *    - Impact: Disputes, financial loss
 *    - Mitigation: Audit logs, digital signatures
 * 
 * 4. Information Disclosure:
 *    - Threat: Expose customer PII, payment data
 *    - Impact: Compliance violation, reputation damage
 *    - Mitigation: Encryption, access controls, data masking
 * 
 * 5. Denial of Service:
 *    - Threat: Overwhelm system with requests
 *    - Impact: Service unavailability, revenue loss
 *    - Mitigation: Rate limiting, DDoS protection
 * 
 * 6. Elevation of Privilege:
 *    - Threat: Regular user gains admin access
 *    - Impact: Unauthorized actions, data breach
 *    - Mitigation: Role-based access control, privilege separation
 */
```

**Threat Modeling Implementation**:

```java
@Service
class ThreatModelingService {
    
    /**
     * Threat Modeling for User Authentication
     */
    public ThreatModel analyzeAuthenticationThreats() {
        ThreatModel model = new ThreatModel();
        
        // Asset: User credentials
        Asset credentials = new Asset("User Credentials", "HIGH");
        model.addAsset(credentials);
        
        // Threat 1: Credential Theft
        Threat credentialTheft = new Threat(
            "Credential Theft",
            ThreatType.SPOOFING,
            "Attacker steals user credentials",
            Impact.HIGH,
            Likelihood.MEDIUM
        );
        credentialTheft.addMitigation("Password hashing (bcrypt, Argon2)");
        credentialTheft.addMitigation("Rate limiting on login attempts");
        credentialTheft.addMitigation("Account lockout after failed attempts");
        model.addThreat(credentialTheft);
        
        // Threat 2: Session Hijacking
        Threat sessionHijacking = new Threat(
            "Session Hijacking",
            ThreatType.SPOOFING,
            "Attacker steals session token",
            Impact.HIGH,
            Likelihood.MEDIUM
        );
        sessionHijacking.addMitigation("Secure session tokens (JWT with expiration)");
        sessionHijacking.addMitigation("HTTPS only");
        sessionHijacking.addMitigation("HttpOnly, Secure cookie flags");
        model.addThreat(sessionHijacking);
        
        // Threat 3: Brute Force Attack
        Threat bruteForce = new Threat(
            "Brute Force Attack",
            ThreatType.DENIAL_OF_SERVICE,
            "Attacker attempts multiple login attempts",
            Impact.MEDIUM,
            Likelihood.HIGH
        );
        bruteForce.addMitigation("Rate limiting (5 attempts per minute)");
        bruteForce.addMitigation("CAPTCHA after 3 failed attempts");
        bruteForce.addMitigation("Account lockout after 5 failed attempts");
        model.addThreat(bruteForce);
        
        return model;
    }
}

class ThreatModel {
    private List<Asset> assets = new ArrayList<>();
    private List<Threat> threats = new ArrayList<>();
    
    public void addAsset(Asset asset) {
        assets.add(asset);
    }
    
    public void addThreat(Threat threat) {
        threats.add(threat);
    }
    
    public List<Threat> getHighRiskThreats() {
        return threats.stream()
            .filter(t -> t.getRisk() == Risk.HIGH)
            .collect(Collectors.toList());
    }
}

enum ThreatType {
    SPOOFING, TAMPERING, REPUDIATION, 
    INFORMATION_DISCLOSURE, DENIAL_OF_SERVICE, ELEVATION_OF_PRIVILEGE
}

enum Impact { LOW, MEDIUM, HIGH }
enum Likelihood { LOW, MEDIUM, HIGH }
enum Risk { LOW, MEDIUM, HIGH }

class Threat {
    private String name;
    private ThreatType type;
    private String description;
    private Impact impact;
    private Likelihood likelihood;
    private List<String> mitigations = new ArrayList<>();
    
    public Threat(String name, ThreatType type, String description, 
                  Impact impact, Likelihood likelihood) {
        this.name = name;
        this.type = type;
        this.description = description;
        this.impact = impact;
        this.likelihood = likelihood;
    }
    
    public void addMitigation(String mitigation) {
        mitigations.add(mitigation);
    }
    
    public Risk getRisk() {
        if (impact == Impact.HIGH && likelihood == Likelihood.HIGH) return Risk.HIGH;
        if (impact == Impact.HIGH && likelihood == Likelihood.MEDIUM) return Risk.HIGH;
        if (impact == Impact.MEDIUM && likelihood == Likelihood.HIGH) return Risk.HIGH;
        if (impact == Impact.HIGH || likelihood == Likelihood.HIGH) return Risk.MEDIUM;
        return Risk.LOW;
    }
}
```

---

## 3. Security Design Patterns

### 3.1 Authentication Patterns

**Multi-Factor Authentication (MFA)**:

```java
@Service
class MultiFactorAuthenticationService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private TOTPService totpService;
    
    @Autowired
    private EmailService emailService;
    
    @Autowired
    private SMSService smsService;
    
    public AuthenticationResult authenticate(String username, String password, String mfaCode) {
        // Step 1: Verify password
        User user = userRepository.findByUsername(username);
        if (user == null || !passwordEncoder.matches(password, user.getPassword())) {
            return AuthenticationResult.failed("Invalid credentials");
        }
        
        // Step 2: Verify MFA
        if (user.isMfaEnabled()) {
            if (!verifyMFA(user, mfaCode)) {
                return AuthenticationResult.failed("Invalid MFA code");
            }
        }
        
        // Step 3: Generate session token
        String sessionToken = generateSecureSessionToken(user);
        
        return AuthenticationResult.success(sessionToken, user);
    }
    
    private boolean verifyMFA(User user, String code) {
        // TOTP verification
        if (user.getMfaType() == MFAType.TOTP) {
            return totpService.verify(user.getMfaSecret(), code);
        }
        
        // Email verification
        if (user.getMfaType() == MFAType.EMAIL) {
            return emailService.verifyCode(user.getEmail(), code);
        }
        
        // SMS verification
        if (user.getMfaType() == MFAType.SMS) {
            return smsService.verifyCode(user.getPhone(), code);
        }
        
        return false;
    }
    
    public void enableMFA(String userId, MFAType type) {
        User user = userRepository.findById(userId);
        
        if (type == MFAType.TOTP) {
            String secret = totpService.generateSecret();
            user.setMfaSecret(secret);
            user.setMfaType(MFAType.TOTP);
        } else if (type == MFAType.EMAIL) {
            String code = emailService.sendVerificationCode(user.getEmail());
            user.setMfaType(MFAType.EMAIL);
        } else if (type == MFAType.SMS) {
            String code = smsService.sendVerificationCode(user.getPhone());
            user.setMfaType(MFAType.SMS);
        }
        
        user.setMfaEnabled(true);
        userRepository.save(user);
    }
}
```

**OAuth 2.0 / OpenID Connect**:

```java
@Configuration
class OAuth2SecurityConfig {
    
    @Bean
    public ClientRegistrationRepository clientRegistrationRepository() {
        return new InMemoryClientRegistrationRepository(
            googleClientRegistration(),
            githubClientRegistration()
        );
    }
    
    private ClientRegistration googleClientRegistration() {
        return ClientRegistration.withRegistrationId("google")
            .clientId("google-client-id")
            .clientSecret("google-client-secret")
            .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
            .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
            .redirectUri("{baseUrl}/login/oauth2/code/{registrationId}")
            .scope("openid", "profile", "email")
            .authorizationUri("https://accounts.google.com/o/oauth2/v2/auth")
            .tokenUri("https://www.googleapis.com/oauth2/v4/token")
            .userInfoUri("https://www.googleapis.com/oauth2/v3/userinfo")
            .userNameAttributeName(IdTokenClaimNames.SUB)
            .jwkSetUri("https://www.googleapis.com/oauth2/v3/certs")
            .clientName("Google")
            .build();
    }
}
```

### 3.2 Authorization Patterns

**Role-Based Access Control (RBAC)**:

```java
@Service
class RoleBasedAccessControlService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private RoleRepository roleRepository;
    
    @Autowired
    private PermissionRepository permissionRepository;
    
    public boolean hasPermission(String userId, String resource, String action) {
        User user = userRepository.findById(userId);
        if (user == null) return false;
        
        // Get user roles
        Set<Role> roles = user.getRoles();
        
        // Check if any role has permission
        for (Role role : roles) {
            if (role.hasPermission(resource, action)) {
                return true;
            }
        }
        
        return false;
    }
    
    public void assignRole(String userId, String roleName) {
        User user = userRepository.findById(userId);
        Role role = roleRepository.findByName(roleName);
        
        user.addRole(role);
        userRepository.save(user);
    }
    
    public void grantPermission(String roleName, String resource, String action) {
        Role role = roleRepository.findByName(roleName);
        Permission permission = permissionRepository.findByResourceAndAction(resource, action);
        
        role.addPermission(permission);
        roleRepository.save(role);
    }
}

@Entity
class User {
    @Id
    private String id;
    private String username;
    
    @ManyToMany
    private Set<Role> roles = new HashSet<>();
    
    public void addRole(Role role) {
        roles.add(role);
    }
}

@Entity
class Role {
    @Id
    private String id;
    private String name;
    
    @ManyToMany
    private Set<Permission> permissions = new HashSet<>();
    
    public boolean hasPermission(String resource, String action) {
        return permissions.stream()
            .anyMatch(p -> p.getResource().equals(resource) && 
                          p.getAction().equals(action));
    }
}

@Entity
class Permission {
    @Id
    private String id;
    private String resource; // e.g., "order", "user", "product"
    private String action;   // e.g., "read", "write", "delete"
}
```

**Attribute-Based Access Control (ABAC)**:

```java
@Service
class AttributeBasedAccessControlService {
    
    public boolean checkAccess(User user, Resource resource, String action) {
        // Get user attributes
        Map<String, Object> userAttributes = getUserAttributes(user);
        
        // Get resource attributes
        Map<String, Object> resourceAttributes = getResourceAttributes(resource);
        
        // Get environment attributes
        Map<String, Object> environmentAttributes = getEnvironmentAttributes();
        
        // Evaluate policy
        return evaluatePolicy(userAttributes, resourceAttributes, 
                            environmentAttributes, action);
    }
    
    private boolean evaluatePolicy(Map<String, Object> userAttrs,
                                   Map<String, Object> resourceAttrs,
                                   Map<String, Object> envAttrs,
                                   String action) {
        // Example policy: User can access resource if:
        // 1. User's department matches resource's department
        // 2. Action is allowed for user's role
        // 3. Access is during business hours
        
        String userDept = (String) userAttrs.get("department");
        String resourceDept = (String) resourceAttrs.get("department");
        
        if (!userDept.equals(resourceDept)) {
            return false; // Different departments
        }
        
        String userRole = (String) userAttrs.get("role");
        if (!isActionAllowedForRole(userRole, action)) {
            return false; // Role doesn't allow action
        }
        
        LocalTime currentTime = LocalTime.now();
        if (currentTime.isBefore(LocalTime.of(9, 0)) || 
            currentTime.isAfter(LocalTime.of(17, 0))) {
            return false; // Outside business hours
        }
        
        return true;
    }
}
```

### 3.3 Data Protection Patterns

**Encryption at Rest**:

```java
@Service
class EncryptionService {
    
    @Value("${encryption.key}")
    private String encryptionKey;
    
    private Cipher cipher;
    
    @PostConstruct
    public void init() throws Exception {
        SecretKeySpec keySpec = new SecretKeySpec(
            encryptionKey.getBytes(), "AES");
        cipher = Cipher.getInstance("AES/GCM/NoPadding");
        cipher.init(Cipher.ENCRYPT_MODE, keySpec);
    }
    
    public String encrypt(String plaintext) throws Exception {
        byte[] encrypted = cipher.doFinal(plaintext.getBytes());
        return Base64.getEncoder().encodeToString(encrypted);
    }
    
    public String decrypt(String ciphertext) throws Exception {
        byte[] decoded = Base64.getDecoder().decode(ciphertext);
        cipher.init(Cipher.DECRYPT_MODE, 
                   new SecretKeySpec(encryptionKey.getBytes(), "AES"));
        byte[] decrypted = cipher.doFinal(decoded);
        return new String(decrypted);
    }
}

// Database encryption
@Entity
class User {
    @Id
    private String id;
    
    @Convert(converter = EncryptionConverter.class)
    private String ssn; // Encrypted at rest
    
    @Convert(converter = EncryptionConverter.class)
    private String creditCard; // Encrypted at rest
}

@Converter
class EncryptionConverter implements AttributeConverter<String, String> {
    
    @Autowired
    private EncryptionService encryptionService;
    
    @Override
    public String convertToDatabaseColumn(String attribute) {
        if (attribute == null) return null;
        try {
            return encryptionService.encrypt(attribute);
        } catch (Exception e) {
            throw new RuntimeException("Encryption failed", e);
        }
    }
    
    @Override
    public String convertToEntityAttribute(String dbData) {
        if (dbData == null) return null;
        try {
            return encryptionService.decrypt(dbData);
        } catch (Exception e) {
            throw new RuntimeException("Decryption failed", e);
        }
    }
}
```

**Encryption in Transit (TLS)**:

```java
@Configuration
class TLSConfig {
    
    @Bean
    public TomcatServletWebServerFactory servletContainer() {
        TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();
        factory.addConnectorCustomizers(connector -> {
            connector.setSecure(true);
            connector.setScheme("https");
            connector.setProperty("SSLEnabled", "true");
            connector.setProperty("sslProtocol", "TLS");
            connector.setProperty("keystoreFile", "keystore.jks");
            connector.setProperty("keystorePass", "password");
            connector.setProperty("keystoreType", "JKS");
            connector.setProperty("clientAuth", "false");
        });
        return factory;
    }
}
```

**Data Masking**:

```java
@Service
class DataMaskingService {
    
    public String maskEmail(String email) {
        if (email == null || !email.contains("@")) return email;
        String[] parts = email.split("@");
        String username = parts[0];
        String domain = parts[1];
        
        if (username.length() <= 2) {
            return "**@" + domain;
        }
        
        String masked = username.charAt(0) + 
                       "*".repeat(username.length() - 2) + 
                       username.charAt(username.length() - 1);
        return masked + "@" + domain;
    }
    
    public String maskSSN(String ssn) {
        if (ssn == null || ssn.length() != 9) return ssn;
        return "***-**-" + ssn.substring(5);
    }
    
    public String maskCreditCard(String cardNumber) {
        if (cardNumber == null || cardNumber.length() < 4) return cardNumber;
        return "****-****-****-" + cardNumber.substring(cardNumber.length() - 4);
    }
}

// Usage in API responses
@RestController
class UserController {
    
    @Autowired
    private DataMaskingService dataMaskingService;
    
    @GetMapping("/users/{id}")
    public UserResponse getUser(@PathVariable String id, 
                               @AuthenticationPrincipal User currentUser) {
        User user = userService.getUser(id);
        
        UserResponse response = new UserResponse();
        response.setId(user.getId());
        response.setName(user.getName());
        
        // Mask sensitive data for non-admin users
        if (!currentUser.hasRole("ADMIN")) {
            response.setEmail(dataMaskingService.maskEmail(user.getEmail()));
            response.setSsn(dataMaskingService.maskSSN(user.getSsn()));
        } else {
            response.setEmail(user.getEmail());
            response.setSsn(user.getSsn());
        }
        
        return response;
    }
}
```

---

## 4. Secure System Architecture

### 4.1 Secure Microservices Architecture

**Security Layers in Microservices**:

```java
/**
 * Secure Microservices Architecture:
 * 
 * 1. API Gateway:
 *    - Authentication
 *    - Authorization
 *    - Rate limiting
 *    - SSL termination
 * 
 * 2. Service Mesh:
 *    - mTLS between services
 *    - Service-to-service authentication
 *    - Traffic encryption
 * 
 * 3. Service Level:
 *    - Input validation
 *    - Output encoding
 *    - Secure configurations
 * 
 * 4. Data Layer:
 *    - Encryption at rest
 *    - Database access controls
 *    - Audit logging
 */
```

**Service-to-Service Authentication**:

```java
@Configuration
class ServiceToServiceAuthConfig {
    
    @Bean
    public RestTemplate restTemplate() {
        RestTemplate restTemplate = new RestTemplate();
        
        // Add service-to-service authentication interceptor
        restTemplate.getInterceptors().add(new ServiceAuthInterceptor());
        
        return restTemplate;
    }
}

class ServiceAuthInterceptor implements ClientHttpRequestInterceptor {
    
    @Autowired
    private ServiceTokenProvider tokenProvider;
    
    @Override
    public ClientHttpResponse intercept(
            HttpRequest request, 
            byte[] body, 
            ClientHttpRequestExecution execution) throws IOException {
        
        // Add service token to request
        String token = tokenProvider.getServiceToken();
        request.getHeaders().set("X-Service-Token", token);
        
        return execution.execute(request, body);
    }
}

@Service
class ServiceTokenProvider {
    
    @Value("${service.name}")
    private String serviceName;
    
    @Value("${service.secret}")
    private String serviceSecret;
    
    public String getServiceToken() {
        // Generate JWT token for service-to-service communication
        return Jwts.builder()
            .setSubject(serviceName)
            .setIssuedAt(new Date())
            .setExpiration(new Date(System.currentTimeMillis() + 3600000)) // 1 hour
            .signWith(SignatureAlgorithm.HS256, serviceSecret)
            .compact();
    }
}
```

### 4.2 Secure API Design

**API Security Best Practices**:

```java
@RestController
@RequestMapping("/api/v1")
class SecureAPIController {
    
    @Autowired
    private RateLimitingService rateLimitingService;
    
    @Autowired
    private InputValidationService inputValidationService;
    
    @PostMapping("/users")
    @PreAuthorize("hasRole('ADMIN')")
    @RateLimit(requests = 100, window = 60) // 100 requests per minute
    public ResponseEntity<User> createUser(@Valid @RequestBody UserRequest request) {
        // Input validation
        inputValidationService.validate(request);
        
        // Sanitize input
        String sanitizedEmail = sanitizeEmail(request.getEmail());
        
        // Create user
        User user = userService.createUser(request);
        
        // Audit log
        auditService.log("USER_CREATED", user.getId());
        
        return ResponseEntity.ok(user);
    }
    
    @GetMapping("/users/{id}")
    @PreAuthorize("hasRole('USER') or hasRole('ADMIN')")
    public ResponseEntity<UserResponse> getUser(
            @PathVariable @ValidUUID String id,
            @AuthenticationPrincipal User currentUser) {
        
        // Authorization check
        if (!currentUser.hasRole("ADMIN") && !currentUser.getId().equals(id)) {
            throw new AccessDeniedException("Not authorized");
        }
        
        User user = userService.getUser(id);
        UserResponse response = mapToResponse(user, currentUser);
        
        return ResponseEntity.ok()
            .cacheControl(CacheControl.maxAge(5, TimeUnit.MINUTES))
            .body(response);
    }
    
    private String sanitizeEmail(String email) {
        // Remove potentially dangerous characters
        return email.replaceAll("[^a-zA-Z0-9@._-]", "");
    }
}
```

---

## 5. Practical Examples

### 5.1 Secure Authentication System

**Complete Authentication Implementation**:

```java
@Service
class SecureAuthenticationService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    @Autowired
    private TokenService tokenService;
    
    @Autowired
    private RateLimitingService rateLimitingService;
    
    @Autowired
    private AuditService auditService;
    
    public AuthenticationResult authenticate(AuthenticationRequest request) {
        String clientIp = getClientIp();
        
        // Rate limiting
        if (!rateLimitingService.isAllowed(clientIp, "login", 5, 15)) {
            auditService.log("LOGIN_RATE_LIMIT_EXCEEDED", clientIp);
            throw new RateLimitExceededException("Too many login attempts");
        }
        
        // Find user
        User user = userRepository.findByUsername(request.getUsername());
        if (user == null) {
            auditService.log("LOGIN_FAILED", request.getUsername(), "User not found");
            return AuthenticationResult.failed("Invalid credentials");
        }
        
        // Check account status
        if (user.isLocked()) {
            auditService.log("LOGIN_FAILED", request.getUsername(), "Account locked");
            return AuthenticationResult.failed("Account is locked");
        }
        
        // Verify password
        if (!passwordEncoder.matches(request.getPassword(), user.getPassword())) {
            user.incrementFailedLoginAttempts();
            userRepository.save(user);
            
            if (user.getFailedLoginAttempts() >= 5) {
                user.lockAccount();
                userRepository.save(user);
                auditService.log("ACCOUNT_LOCKED", user.getId());
            }
            
            auditService.log("LOGIN_FAILED", request.getUsername(), "Invalid password");
            return AuthenticationResult.failed("Invalid credentials");
        }
        
        // Reset failed attempts
        user.resetFailedLoginAttempts();
        user.setLastLoginTime(Instant.now());
        userRepository.save(user);
        
        // Generate tokens
        String accessToken = tokenService.generateAccessToken(user);
        String refreshToken = tokenService.generateRefreshToken(user);
        
        auditService.log("LOGIN_SUCCESS", user.getId());
        
        return AuthenticationResult.success(accessToken, refreshToken, user);
    }
}
```

### 5.2 Secure Data Handling

**PCI-DSS Compliant Payment Processing**:

```java
@Service
class SecurePaymentService {
    
    @Autowired
    private PaymentGatewayClient paymentGateway;
    
    @Autowired
    private EncryptionService encryptionService;
    
    @Autowired
    private TokenizationService tokenizationService;
    
    @Autowired
    private AuditService auditService;
    
    public PaymentResult processPayment(PaymentRequest request) {
        // Never store full card number
        // Use tokenization instead
        
        // Step 1: Tokenize card number
        String token = tokenizationService.tokenize(request.getCardNumber());
        
        // Step 2: Encrypt sensitive data
        String encryptedCvv = encryptionService.encrypt(request.getCvv());
        
        // Step 3: Send to payment gateway (never store)
        PaymentGatewayRequest gatewayRequest = new PaymentGatewayRequest(
            token, // Use token, not card number
            request.getExpiryDate(),
            encryptedCvv,
            request.getAmount()
        );
        
        PaymentGatewayResponse response = paymentGateway.processPayment(gatewayRequest);
        
        // Step 4: Audit log (no sensitive data)
        auditService.log("PAYMENT_PROCESSED", 
            request.getOrderId(), 
            response.getTransactionId(),
            request.getAmount());
        
        // Step 5: Return result (no sensitive data)
        return new PaymentResult(
            response.getTransactionId(),
            response.getStatus(),
            response.getMessage()
        );
    }
    
    // Never store full card numbers
    // Only store tokens
    public void savePaymentMethod(String userId, PaymentMethodRequest request) {
        String token = tokenizationService.tokenize(request.getCardNumber());
        
        PaymentMethod method = new PaymentMethod();
        method.setUserId(userId);
        method.setToken(token); // Store token, not card number
        method.setLast4(request.getCardNumber().substring(request.getCardNumber().length() - 4));
        method.setExpiryDate(request.getExpiryDate());
        
        paymentMethodRepository.save(method);
    }
}
```

---

## Summary: Part 1

### Key Concepts

1. **Security Architecture**: Defense in depth, least privilege, zero trust
2. **Threat Modeling**: STRIDE model, risk assessment, mitigation
3. **Security Patterns**: Authentication, authorization, data protection
4. **Secure Architecture**: Multi-layer security, microservices security

### Next Steps

**Part 2** will cover:
- OWASP Top 10 and Security Best Practices
- Common Vulnerabilities and Mitigations
- Secure Coding Practices
- Security Testing

---

**Master security architecture and threat modeling to build secure systems!**

