# Principal Engineer: Mastering Performance and Scalability Optimization

## Part 4: Load Testing and Capacity Planning

---

## Table of Contents

1. [Load Testing Fundamentals](#1-load-testing-fundamentals)
2. [Load Testing Tools and Frameworks](#2-load-testing-tools-and-frameworks)
3. [Performance Testing Strategies](#3-performance-testing-strategies)
4. [Capacity Planning Methodology](#4-capacity-planning-methodology)
5. [Stress Testing and Chaos Engineering](#5-stress-testing-and-chaos-engineering)
6. [Practical Load Testing Examples](#6-practical-load-testing-examples)

---

## 1. Load Testing Fundamentals

### 1.1 Types of Performance Testing

**Performance Testing Types**:
```java
/**
 * Performance Testing Types:
 * 
 * 1. Load Testing:
 *    - Test under expected load
 *    - Normal operating conditions
 *    - Validate performance requirements
 * 
 * 2. Stress Testing:
 *    - Test beyond normal capacity
 *    - Find breaking points
 *    - Test failure scenarios
 * 
 * 3. Spike Testing:
 *    - Sudden load increases
 *    - Test system recovery
 *    - Validate auto-scaling
 * 
 * 4. Volume Testing:
 *    - Large amounts of data
 *    - Test data handling capacity
 *    - Database performance
 * 
 * 5. Endurance Testing:
 *    - Long duration testing
 *    - Memory leaks detection
 *    - Resource exhaustion
 * 
 * 6. Scalability Testing:
 *    - Test horizontal scaling
 *    - Validate scaling behavior
 *    - Cost optimization
 */
```

### 1.2 Load Testing Metrics

**Key Performance Metrics**:
```java
/**
 * Load Testing Metrics:
 * 
 * 1. Response Time:
 *    - Average response time
 *    - P50, P95, P99, P99.9 percentiles
 *    - Min/Max response time
 * 
 * 2. Throughput:
 *    - Requests per second (RPS)
 *    - Transactions per second (TPS)
 *    - Operations per second (OPS)
 * 
 * 3. Error Rate:
 *    - Error percentage
 *    - HTTP error codes (4xx, 5xx)
 *    - Timeout rate
 * 
 * 4. Resource Utilization:
 *    - CPU usage
 *    - Memory usage
 *    - Network I/O
 *    - Disk I/O
 * 
 * 5. Concurrent Users:
 *    - Active users
 *    - Peak concurrent users
 *    - User ramp-up rate
 */
```

### 1.3 Load Testing Process

**Load Testing Lifecycle**:
```java
/**
 * Load Testing Process:
 * 
 * Phase 1: Planning
 *   - Define test objectives
 *   - Identify test scenarios
 *   - Set performance targets
 *   - Prepare test environment
 * 
 * Phase 2: Test Design
 *   - Create test scripts
 *   - Define load patterns
 *   - Set up monitoring
 *   - Prepare test data
 * 
 * Phase 3: Execution
 *   - Run baseline tests
 *   - Execute load tests
 *   - Monitor system behavior
 *   - Collect metrics
 * 
 * Phase 4: Analysis
 *   - Analyze results
 *   - Identify bottlenecks
 *   - Compare with targets
 *   - Document findings
 * 
 * Phase 5: Optimization
 *   - Fix identified issues
 *   - Retest
 *   - Validate improvements
 *   - Update capacity plans
 */
```

---

## 2. Load Testing Tools and Frameworks

### 2.1 JMeter

**JMeter Test Plan**:
```java
/**
 * JMeter Test Configuration:
 * 
 * 1. Thread Group:
 *    - Number of threads (users)
 *    - Ramp-up period
 *    - Loop count
 * 
 * 2. HTTP Request:
 *    - Server name
 *    - Path
 *    - Method
 *    - Parameters
 * 
 * 3. Listeners:
 *    - View Results Tree
 *    - Summary Report
 *    - Graph Results
 */
```

**JMeter Programmatic Setup**:
```java
@Component
class JMeterTestBuilder {
    
    public TestPlan createLoadTestPlan() {
        TestPlan testPlan = new TestPlan("API Load Test");
        
        // Thread Group
        ThreadGroup threadGroup = new ThreadGroup();
        threadGroup.setName("API Users");
        threadGroup.setNumThreads(100); // 100 concurrent users
        threadGroup.setRampTime(60); // Ramp up over 60 seconds
        threadGroup.setDuration(300); // Run for 5 minutes
        
        // HTTP Request Sampler
        HTTPSamplerProxy httpSampler = new HTTPSamplerProxy();
        httpSampler.setDomain("api.example.com");
        httpSampler.setPath("/api/users");
        httpSampler.setMethod("GET");
        
        // Add to thread group
        threadGroup.addTestElement(httpSampler);
        
        // Add listeners
        SummaryReport summaryReport = new SummaryReport();
        threadGroup.addTestElement(summaryReport);
        
        testPlan.addThreadGroup(threadGroup);
        
        return testPlan;
    }
}
```

### 2.2 Gatling

**Gatling Simulation**:
```scala
// Gatling Load Test (Scala)
class ApiLoadTest extends Simulation {
  
  val httpProtocol = http
    .baseUrl("https://api.example.com")
    .acceptHeader("application/json")
    .userAgentHeader("Gatling Load Test")
  
  val scn = scenario("API Load Test")
    .exec(http("Get Users")
      .get("/api/users")
      .check(status.is(200)))
    .pause(1)
    .exec(http("Get User")
      .get("/api/users/${userId}")
      .check(status.is(200)))
  
  setUp(
    scn.inject(
      rampUsers(100) during (60 seconds), // Ramp up to 100 users
      constantUsersPerSec(100) during (5 minutes) // Maintain 100 users/sec
    )
  ).protocols(httpProtocol)
}
```

**Gatling Java DSL**:
```java
public class ApiLoadTest extends Simulation {
    
    HttpProtocolBuilder httpProtocol = http
        .baseUrl("https://api.example.com")
        .acceptHeader("application/json");
    
    ScenarioBuilder scn = scenario("API Load Test")
        .exec(http("Get Users")
            .get("/api/users")
            .check(status().is(200)))
        .pause(Duration.ofSeconds(1))
        .exec(http("Get User")
            .get("/api/users/${userId}")
            .check(status().is(200)));
    
    {
        setUp(
            scn.inject(
                rampUsers(100).during(Duration.ofSeconds(60)),
                constantUsersPerSec(100).during(Duration.ofMinutes(5))
            )
        ).protocols(httpProtocol);
    }
}
```

### 2.3 K6

**K6 Load Test Script**:
```javascript
// K6 Load Test (JavaScript)
import http from 'k6/http';
import { check, sleep } from 'k6';

export const options = {
  stages: [
    { duration: '1m', target: 50 },   // Ramp up to 50 users
    { duration: '3m', target: 50 },   // Stay at 50 users
    { duration: '1m', target: 100 },  // Ramp up to 100 users
    { duration: '3m', target: 100 },   // Stay at 100 users
    { duration: '1m', target: 0 },    // Ramp down to 0
  ],
  thresholds: {
    http_req_duration: ['p(95)<500'], // 95% of requests < 500ms
    http_req_failed: ['rate<0.01'],   // Error rate < 1%
  },
};

export default function () {
  // Get users
  let response = http.get('https://api.example.com/api/users');
  check(response, {
    'status is 200': (r) => r.status === 200,
    'response time < 500ms': (r) => r.timings.duration < 500,
  });
  
  sleep(1);
  
  // Get specific user
  response = http.get('https://api.example.com/api/users/123');
  check(response, {
    'status is 200': (r) => r.status === 200,
  });
  
  sleep(1);
}
```

### 2.4 Custom Load Testing Framework

**Java-Based Load Testing**:
```java
@Component
class CustomLoadTester {
    
    private final RestTemplate restTemplate;
    private final ExecutorService executorService;
    
    public LoadTestResults runLoadTest(LoadTestConfig config) {
        List<Future<RequestResult>> futures = new ArrayList<>();
        
        // Create load
        for (int i = 0; i < config.getConcurrentUsers(); i++) {
            Future<RequestResult> future = executorService.submit(() -> {
                return executeUserScenario(config);
            });
            futures.add(future);
        }
        
        // Collect results
        List<RequestResult> results = new ArrayList<>();
        for (Future<RequestResult> future : futures) {
            try {
                results.add(future.get());
            } catch (Exception e) {
                logger.error("Load test error", e);
            }
        }
        
        return analyzeResults(results);
    }
    
    private RequestResult executeUserScenario(LoadTestConfig config) {
        List<RequestMetrics> metrics = new ArrayList<>();
        
        for (int i = 0; i < config.getRequestsPerUser(); i++) {
            long startTime = System.currentTimeMillis();
            
            try {
                ResponseEntity<String> response = restTemplate.getForEntity(
                    config.getUrl(), String.class);
                
                long duration = System.currentTimeMillis() - startTime;
                
                metrics.add(new RequestMetrics(
                    duration,
                    response.getStatusCodeValue(),
                    true
                ));
            } catch (Exception e) {
                long duration = System.currentTimeMillis() - startTime;
                metrics.add(new RequestMetrics(duration, 500, false));
            }
            
            // Think time
            try {
                Thread.sleep(config.getThinkTime());
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        
        return new RequestResult(metrics);
    }
    
    private LoadTestResults analyzeResults(List<RequestResult> results) {
        List<RequestMetrics> allMetrics = results.stream()
            .flatMap(r -> r.getMetrics().stream())
            .collect(Collectors.toList());
        
        // Calculate statistics
        double avgResponseTime = allMetrics.stream()
            .mapToLong(RequestMetrics::getDuration)
            .average()
            .orElse(0);
        
        long p95 = calculatePercentile(allMetrics, 95);
        long p99 = calculatePercentile(allMetrics, 99);
        
        long errorCount = allMetrics.stream()
            .filter(m -> !m.isSuccess())
            .count();
        
        double errorRate = (double) errorCount / allMetrics.size() * 100;
        
        return new LoadTestResults(
            avgResponseTime,
            p95,
            p99,
            errorRate,
            allMetrics.size()
        );
    }
    
    private long calculatePercentile(List<RequestMetrics> metrics, int percentile) {
        List<Long> durations = metrics.stream()
            .map(RequestMetrics::getDuration)
            .sorted()
            .collect(Collectors.toList());
        
        int index = (int) Math.ceil(percentile / 100.0 * durations.size()) - 1;
        return durations.get(Math.max(0, index));
    }
}
```

---

## 3. Performance Testing Strategies

### 3.1 Baseline Testing

**Baseline Performance Test**:
```java
@Component
class BaselinePerformanceTest {
    
    /**
     * Baseline Testing:
     * 
     * 1. Establish current performance
     * 2. Single user, no load
     * 3. Measure response times
     * 4. Identify bottlenecks
     */
    
    public BaselineResults runBaselineTest() {
        List<RequestMetrics> metrics = new ArrayList<>();
        
        // Single user, 100 requests
        for (int i = 0; i < 100; i++) {
            long startTime = System.currentTimeMillis();
            
            try {
                restTemplate.getForEntity("/api/users", String.class);
                long duration = System.currentTimeMillis() - startTime;
                metrics.add(new RequestMetrics(duration, 200, true));
            } catch (Exception e) {
                long duration = System.currentTimeMillis() - startTime;
                metrics.add(new RequestMetrics(duration, 500, false));
            }
        }
        
        return new BaselineResults(metrics);
    }
}
```

### 3.2 Load Testing Patterns

**Ramp-Up Pattern**:
```java
@Component
class RampUpLoadTest {
    
    /**
     * Ramp-Up Pattern:
     * 
     * Gradually increase load:
     * - 0-1min: 0 → 50 users
     * - 1-2min: 50 → 100 users
     * - 2-3min: 100 → 150 users
     * - 3-5min: Maintain 150 users
     */
    
    public void runRampUpTest() {
        int[] userCounts = {0, 50, 100, 150, 150};
        int[] durations = {60, 60, 60, 120}; // seconds
        
        for (int i = 0; i < userCounts.length - 1; i++) {
            int startUsers = userCounts[i];
            int endUsers = userCounts[i + 1];
            int duration = durations[i];
            
            rampUpUsers(startUsers, endUsers, duration);
        }
    }
    
    private void rampUpUsers(int start, int end, int duration) {
        int increment = (end - start) / (duration / 10); // Increment every 10 seconds
        
        for (int users = start; users < end; users += increment) {
            runLoadTest(users, 10); // Run for 10 seconds
        }
    }
}
```

**Constant Load Pattern**:
```java
@Component
class ConstantLoadTest {
    
    /**
     * Constant Load Pattern:
     * 
     * Maintain constant load:
     * - 100 users for 10 minutes
     * - Measure steady-state performance
     */
    
    public void runConstantLoadTest(int users, int durationMinutes) {
        ExecutorService executor = Executors.newFixedThreadPool(users);
        CountDownLatch latch = new CountDownLatch(users);
        
        for (int i = 0; i < users; i++) {
            executor.submit(() -> {
                try {
                    long endTime = System.currentTimeMillis() + (durationMinutes * 60 * 1000);
                    
                    while (System.currentTimeMillis() < endTime) {
                        executeRequest();
                        Thread.sleep(1000); // 1 request per second
                    }
                } finally {
                    latch.countDown();
                }
            });
        }
        
        try {
            latch.await();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

**Spike Testing**:
```java
@Component
class SpikeTest {
    
    /**
     * Spike Testing:
     * 
     * Sudden load increase:
     * - Normal: 50 users
     * - Spike: 500 users (10x)
     * - Test system recovery
     */
    
    public void runSpikeTest() {
        // Normal load
        runLoadTest(50, 60); // 50 users for 1 minute
        
        // Spike
        runLoadTest(500, 30); // 500 users for 30 seconds
        
        // Recovery
        runLoadTest(50, 60); // Back to 50 users
    }
}
```

---

## 4. Capacity Planning Methodology

### 4.1 Capacity Planning Process

**Capacity Planning Steps**:
```java
/**
 * Capacity Planning Process:
 * 
 * 1. Define Requirements:
 *    - Expected traffic
 *    - Peak load
 *    - Growth projections
 *    - Performance targets
 * 
 * 2. Measure Current Capacity:
 *    - Baseline performance
 *    - Load testing
 *    - Resource utilization
 *    - Bottlenecks
 * 
 * 3. Calculate Capacity:
 *    - Requests per server
 *    - Required servers
 *    - Database capacity
 *    - Network bandwidth
 * 
 * 4. Plan Scaling:
 *    - Horizontal scaling
 *    - Vertical scaling
 *    - Auto-scaling rules
 *    - Cost optimization
 * 
 * 5. Validate Plan:
 *    - Load testing
 *    - Stress testing
 *    - Cost analysis
 *    - Risk assessment
 */
```

### 4.2 Capacity Calculation

**Capacity Calculation Formula**:
```java
@Component
class CapacityCalculator {
    
    /**
     * Capacity Calculation:
     * 
     * Required Servers = (Peak RPS / Server Capacity) * Safety Factor
     * 
     * Where:
     * - Peak RPS = Peak requests per second
     * - Server Capacity = RPS per server (from load testing)
     * - Safety Factor = 1.5-2.0 (for headroom)
     */
    
    public CapacityPlan calculateCapacity(CapacityRequirements requirements) {
        // Get server capacity from load testing
        int serverCapacity = loadTestResults.getMaxRPS();
        
        // Calculate required servers
        int requiredServers = (int) Math.ceil(
            (requirements.getPeakRPS() / serverCapacity) * 1.5 // 50% headroom
        );
        
        // Calculate database capacity
        int dbConnections = requiredServers * 10; // 10 connections per server
        int dbReplicas = calculateReadReplicas(requirements.getReadWriteRatio());
        
        // Calculate cache capacity
        int cacheNodes = calculateCacheNodes(requirements.getCacheSize());
        
        // Calculate network bandwidth
        double bandwidthMbps = calculateBandwidth(requirements.getPeakRPS());
        
        return new CapacityPlan(
            requiredServers,
            dbConnections,
            dbReplicas,
            cacheNodes,
            bandwidthMbps
        );
    }
    
    private int calculateReadReplicas(double readWriteRatio) {
        // If 80% reads, 20% writes
        // Need replicas to handle read load
        if (readWriteRatio > 0.7) {
            return 3; // 1 primary + 2 replicas
        } else if (readWriteRatio > 0.5) {
            return 2; // 1 primary + 1 replica
        } else {
            return 1; // Primary only
        }
    }
    
    private int calculateCacheNodes(long cacheSizeGB) {
        // Each Redis node: 32GB max
        return (int) Math.ceil(cacheSizeGB / 32.0);
    }
    
    private double calculateBandwidth(int peakRPS) {
        // Average response size: 10KB
        double avgResponseSizeKB = 10;
        double bandwidthMbps = (peakRPS * avgResponseSizeKB * 8) / 1000;
        return bandwidthMbps;
    }
}
```

### 4.3 Growth Projections

**Growth Projection Model**:
```java
@Component
class GrowthProjectionModel {
    
    /**
     * Growth Projection:
     * 
     * Linear Growth:
     *   RPS(t) = RPS(0) * (1 + growth_rate * t)
     * 
     * Exponential Growth:
     *   RPS(t) = RPS(0) * (1 + growth_rate)^t
     * 
     * Compound Growth:
     *   RPS(t) = RPS(0) * e^(growth_rate * t)
     */
    
    public CapacityForecast projectCapacity(
            int currentRPS,
            double monthlyGrowthRate,
            int months) {
        
        List<CapacityPoint> forecast = new ArrayList<>();
        
        for (int month = 0; month <= months; month++) {
            // Exponential growth
            double projectedRPS = currentRPS * Math.pow(1 + monthlyGrowthRate, month);
            
            // Calculate required capacity
            int requiredServers = (int) Math.ceil(projectedRPS / 1000.0); // 1000 RPS per server
            
            forecast.add(new CapacityPoint(month, projectedRPS, requiredServers));
        }
        
        return new CapacityForecast(forecast);
    }
    
    public ScalingPlan createScalingPlan(CapacityForecast forecast) {
        ScalingPlan plan = new ScalingPlan();
        
        for (CapacityPoint point : forecast.getPoints()) {
            if (point.getRequiredServers() > getCurrentServers()) {
                // Need to scale up
                int additionalServers = point.getRequiredServers() - getCurrentServers();
                plan.addScalingEvent(
                    point.getMonth(),
                    ScalingAction.SCALE_UP,
                    additionalServers
                );
            }
        }
        
        return plan;
    }
}
```

---

## 5. Stress Testing and Chaos Engineering

### 5.1 Stress Testing

**Stress Test Implementation**:
```java
@Component
class StressTest {
    
    /**
     * Stress Testing:
     * 
     * 1. Gradually increase load beyond capacity
     * 2. Identify breaking point
     * 3. Test failure scenarios
     * 4. Validate recovery
     */
    
    public StressTestResults runStressTest() {
        int initialUsers = 100;
        int maxUsers = 1000;
        int increment = 50;
        
        StressTestResults results = new StressTestResults();
        
        for (int users = initialUsers; users <= maxUsers; users += increment) {
            LoadTestResults testResults = runLoadTest(users, 60); // 1 minute
            
            results.addTestPoint(users, testResults);
            
            // Stop if error rate > 10%
            if (testResults.getErrorRate() > 10) {
                results.setBreakingPoint(users);
                break;
            }
        }
        
        return results;
    }
}
```

### 5.2 Chaos Engineering

**Chaos Engineering Scenarios**:
```java
@Component
class ChaosEngineering {
    
    /**
     * Chaos Engineering Scenarios:
     * 
     * 1. Network Latency:
     *    - Add delay to network calls
     *    - Test timeout handling
     * 
     * 2. Service Failures:
     *    - Kill random services
     *    - Test circuit breakers
     * 
     * 3. Resource Exhaustion:
     *    - CPU throttling
     *    - Memory pressure
     * 
     * 4. Database Failures:
     *    - Slow queries
     *    - Connection failures
     * 
     * 5. Cache Failures:
     *    - Cache eviction
     *    - Cache unavailability
     */
    
    public void injectNetworkLatency(int delayMs) {
        // Use network proxy to inject latency
        networkProxy.setLatency(delayMs);
    }
    
    public void killRandomService() {
        List<String> services = getServiceList();
        String service = services.get(random.nextInt(services.size()));
        kubernetesClient.deletePod(service);
    }
    
    public void throttleCPU(String podName, int cpuPercent) {
        // Throttle CPU using cgroups
        kubernetesClient.setCpuLimit(podName, cpuPercent);
    }
    
    public void simulateDatabaseSlowdown(int delayMs) {
        // Add delay to database queries
        databaseProxy.setQueryDelay(delayMs);
    }
}
```

**Chaos Monkey Implementation**:
```java
@Component
class ChaosMonkey {
    
    @Scheduled(fixedRate = 300000) // Every 5 minutes
    public void runChaosExperiment() {
        if (shouldRunChaos()) {
            ChaosScenario scenario = selectRandomScenario();
            executeScenario(scenario);
        }
    }
    
    private boolean shouldRunChaos() {
        // Only run in non-production or with feature flag
        return environment.equals("staging") || chaosFeatureFlag.isEnabled();
    }
    
    private ChaosScenario selectRandomScenario() {
        List<ChaosScenario> scenarios = Arrays.asList(
            ChaosScenario.NETWORK_LATENCY,
            ChaosScenario.SERVICE_FAILURE,
            ChaosScenario.CPU_THROTTLE,
            ChaosScenario.MEMORY_PRESSURE
        );
        return scenarios.get(random.nextInt(scenarios.size()));
    }
    
    private void executeScenario(ChaosScenario scenario) {
        switch (scenario) {
            case NETWORK_LATENCY:
                injectNetworkLatency(500); // 500ms delay
                break;
            case SERVICE_FAILURE:
                killRandomService();
                break;
            case CPU_THROTTLE:
                throttleRandomPod(50); // 50% CPU
                break;
            case MEMORY_PRESSURE:
                applyMemoryPressure();
                break;
        }
    }
}
```

---

## 6. Practical Load Testing Examples

### 6.1 API Load Testing

**Complete Load Test Suite**:
```java
@SpringBootTest
class ApiLoadTestSuite {
    
    @Autowired
    private RestTemplate restTemplate;
    
    @Test
    void baselineTest() {
        // Single user, measure baseline
        LoadTestResults results = runLoadTest(1, 100);
        assertThat(results.getAvgResponseTime()).isLessThan(100); // < 100ms
    }
    
    @Test
    void normalLoadTest() {
        // 100 concurrent users
        LoadTestResults results = runLoadTest(100, 300);
        assertThat(results.getAvgResponseTime()).isLessThan(200); // < 200ms
        assertThat(results.getP95ResponseTime()).isLessThan(500); // P95 < 500ms
        assertThat(results.getErrorRate()).isLessThan(1); // < 1% errors
    }
    
    @Test
    void peakLoadTest() {
        // 500 concurrent users (peak load)
        LoadTestResults results = runLoadTest(500, 600);
        assertThat(results.getAvgResponseTime()).isLessThan(500); // < 500ms
        assertThat(results.getP99ResponseTime()).isLessThan(1000); // P99 < 1s
        assertThat(results.getErrorRate()).isLessThan(5); // < 5% errors
    }
    
    @Test
    void stressTest() {
        // Gradually increase to find breaking point
        StressTestResults results = runStressTest(100, 1000, 50);
        assertThat(results.getBreakingPoint()).isGreaterThan(500);
    }
    
    @Test
    void spikeTest() {
        // Sudden load spike
        runLoadTest(50, 60); // Normal: 50 users
        runLoadTest(500, 30); // Spike: 500 users
        LoadTestResults recovery = runLoadTest(50, 60); // Recovery
        
        assertThat(recovery.getAvgResponseTime()).isLessThan(200);
    }
}
```

---

## Summary: Part 4

### Key Takeaways

1. **Load Testing**: Baseline, normal load, peak load, stress testing
2. **Tools**: JMeter, Gatling, K6, custom frameworks
3. **Capacity Planning**: Calculate requirements, project growth, plan scaling
4. **Chaos Engineering**: Test failure scenarios, validate resilience
5. **Performance Metrics**: Response time, throughput, error rate, resource utilization

### Next Steps

**Part 5** will cover:
- System Architecture for Scale
- Best Practices and Patterns
- Real-World Case Studies
- Complete Mastery Guide

---

**Master load testing and capacity planning to enable business growth without technical constraints!**

