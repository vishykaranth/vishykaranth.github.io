# Security and Compliance Leadership for Principal Engineers

## Part 4: Security Code Review

---

## Table of Contents

1. [Security Code Review Fundamentals](#1-security-code-review-fundamentals)
2. [Code Review Checklist](#2-code-review-checklist)
3. [Common Security Vulnerabilities](#3-common-security-vulnerabilities)
4. [Automated Security Scanning](#4-automated-security-scanning)
5. [Security Review Process](#5-security-review-process)
6. [Practical Examples](#6-practical-examples)

---

## 1. Security Code Review Fundamentals

### 1.1 What is Security Code Review?

**Definition**: Systematic examination of source code to identify security vulnerabilities, weaknesses, and compliance issues before code is deployed.

**Objectives**:
- Identify security vulnerabilities early
- Ensure compliance with security standards
- Educate developers on secure coding
- Prevent security breaches
- Maintain code quality

### 1.2 Security Code Review Principles

```java
/**
 * Security Code Review Principles:
 * 
 * 1. Defense in Depth:
 *    - Multiple security layers
 *    - No single point of failure
 * 
 * 2. Fail Securely:
 *    - Fail closed, not open
 *    - Secure error handling
 * 
 * 3. Least Privilege:
 *    - Minimum necessary permissions
 *    - Principle of least access
 * 
 * 4. Input Validation:
 *    - Validate all inputs
 *    - Sanitize user data
 *    - Whitelist, not blacklist
 * 
 * 5. Output Encoding:
 *    - Encode all outputs
 *    - Prevent injection attacks
 * 
 * 6. Secure Defaults:
 *    - Secure by default
 *    - Require explicit insecure choices
 */
```

### 1.3 Security Review vs Regular Code Review

**Differences**:

```java
/**
 * Regular Code Review Focus:
 * - Code quality
 * - Performance
 * - Maintainability
 * - Design patterns
 * - Best practices
 * 
 * Security Code Review Focus:
 * - Security vulnerabilities
 * - Authentication/Authorization
 * - Input validation
 * - Encryption
 * - Data protection
 * - Compliance
 * - Attack vectors
 */
```

---

## 2. Code Review Checklist

### 2.1 Authentication and Authorization

**Authentication Checklist**:

```java
/**
 * Authentication Review Checklist:
 * 
 * □ Strong password requirements enforced
 * □ Password hashing (bcrypt, Argon2, PBKDF2)
 * □ Account lockout after failed attempts
 * □ Session management secure
 * □ Multi-factor authentication available
 * □ Password reset secure
 * □ No hardcoded credentials
 * □ Secure token generation
 * □ Token expiration implemented
 * □ Secure session storage
 */

// BAD: Weak password hashing
class BadAuthenticationService {
    public void createUser(String username, String password) {
        // BAD: MD5 is insecure
        String hashed = DigestUtils.md5Hex(password);
        userRepository.save(new User(username, hashed));
    }
}

// GOOD: Strong password hashing
class GoodAuthenticationService {
    @Autowired
    private PasswordEncoder passwordEncoder; // BCrypt
    
    public void createUser(String username, String password) {
        // GOOD: Use BCrypt with salt
        String hashed = passwordEncoder.encode(password);
        userRepository.save(new User(username, hashed));
    }
}

// BAD: No account lockout
class BadLoginService {
    public boolean login(String username, String password) {
        User user = userRepository.findByUsername(username);
        if (user != null && passwordEncoder.matches(password, user.getPassword())) {
            return true;
        }
        return false; // No lockout after multiple failures
    }
}

// GOOD: Account lockout
class GoodLoginService {
    public boolean login(String username, String password) {
        User user = userRepository.findByUsername(username);
        
        // Check if account is locked
        if (user.isLocked()) {
            throw new AccountLockedException("Account is locked");
        }
        
        if (user != null && passwordEncoder.matches(password, user.getPassword())) {
            user.resetFailedAttempts();
            return true;
        } else {
            user.incrementFailedAttempts();
            if (user.getFailedAttempts() >= 5) {
                user.lockAccount();
            }
            userRepository.save(user);
            return false;
        }
    }
}
```

**Authorization Checklist**:

```java
/**
 * Authorization Review Checklist:
 * 
 * □ Role-based access control (RBAC) implemented
 * □ Permission checks on all protected resources
 * □ Principle of least privilege followed
 * □ No privilege escalation vulnerabilities
 * □ Resource-level authorization
 * □ API endpoint authorization
 * □ Database row-level security
 * □ No authorization bypasses
 */

// BAD: No authorization check
@GetMapping("/api/users/{id}")
public User getUser(@PathVariable String id) {
    // BAD: No authorization check
    return userRepository.findById(id);
}

// GOOD: Authorization check
@GetMapping("/api/users/{id}")
@PreAuthorize("hasRole('ADMIN') or authentication.principal.id == #id")
public User getUser(@PathVariable String id) {
    return userRepository.findById(id);
}

// BAD: Client-side authorization only
@GetMapping("/api/admin/users")
public List<User> getAllUsers() {
    // BAD: Relying on client-side check
    return userRepository.findAll();
}

// GOOD: Server-side authorization
@GetMapping("/api/admin/users")
@PreAuthorize("hasRole('ADMIN')")
public List<User> getAllUsers() {
    // GOOD: Server-side check
    return userRepository.findAll();
}
```

### 2.2 Input Validation

**Input Validation Checklist**:

```java
/**
 * Input Validation Review Checklist:
 * 
 * □ All user inputs validated
 * □ Whitelist validation (not blacklist)
 * □ Type checking
 * □ Length limits enforced
 * □ Format validation (email, phone, etc.)
 * □ SQL injection prevention
 * □ XSS prevention
 * □ Command injection prevention
 * □ Path traversal prevention
 * □ No trust in client-side validation
 */

// BAD: No input validation
@PostMapping("/api/users")
public User createUser(@RequestBody UserRequest request) {
    // BAD: No validation
    User user = new User();
    user.setEmail(request.getEmail()); // Could be anything
    user.setAge(request.getAge()); // Could be negative
    return userRepository.save(user);
}

// GOOD: Input validation
@PostMapping("/api/users")
public User createUser(@Valid @RequestBody UserRequest request) {
    // GOOD: @Valid triggers validation
    User user = new User();
    user.setEmail(request.getEmail());
    user.setAge(request.getAge());
    return userRepository.save(user);
}

// Validation class
class UserRequest {
    @NotBlank
    @Email
    @Size(max = 255)
    private String email;
    
    @Min(0)
    @Max(150)
    private Integer age;
    
    @Pattern(regexp = "^[a-zA-Z0-9]+$")
    @Size(min = 3, max = 20)
    private String username;
}

// BAD: SQL injection
@Repository
class BadUserRepository {
    public User findByUsername(String username) {
        // BAD: SQL injection vulnerability
        String sql = "SELECT * FROM users WHERE username = '" + username + "'";
        return jdbcTemplate.queryForObject(sql, User.class);
    }
}

// GOOD: Parameterized query
@Repository
class GoodUserRepository {
    public User findByUsername(String username) {
        // GOOD: Parameterized query prevents SQL injection
        String sql = "SELECT * FROM users WHERE username = ?";
        return jdbcTemplate.queryForObject(sql, new Object[]{username}, User.class);
    }
}

// BAD: XSS vulnerability
@GetMapping("/api/search")
public String search(@RequestParam String query) {
    // BAD: No output encoding
    return "<h1>Search results for: " + query + "</h1>";
}

// GOOD: Output encoding
@GetMapping("/api/search")
public String search(@RequestParam String query) {
    // GOOD: Encode output to prevent XSS
    String encoded = HtmlUtils.htmlEscape(query);
    return "<h1>Search results for: " + encoded + "</h1>";
}
```

### 2.3 Data Protection

**Data Protection Checklist**:

```java
/**
 * Data Protection Review Checklist:
 * 
 * □ Sensitive data encrypted at rest
 * □ Sensitive data encrypted in transit (TLS)
 * □ No sensitive data in logs
 * □ No sensitive data in error messages
 * □ Password fields never logged
 * □ Credit card data tokenized
 * □ PII data masked in responses
 * □ Secure key management
 * □ No hardcoded secrets
 * □ Secrets in environment variables or vault
 */

// BAD: Sensitive data in logs
@Service
class BadUserService {
    private static final Logger logger = LoggerFactory.getLogger(BadUserService.class);
    
    public void createUser(User user) {
        // BAD: Logging password
        logger.info("Creating user: {} with password: {}", user.getUsername(), user.getPassword());
        userRepository.save(user);
    }
}

// GOOD: No sensitive data in logs
@Service
class GoodUserService {
    private static final Logger logger = LoggerFactory.getLogger(GoodUserService.class);
    
    public void createUser(User user) {
        // GOOD: Don't log sensitive data
        logger.info("Creating user: {}", user.getUsername());
        userRepository.save(user);
    }
}

// BAD: Sensitive data in error messages
@GetMapping("/api/users/{id}")
public User getUser(@PathVariable String id) {
    User user = userRepository.findById(id);
    if (user == null) {
        // BAD: Reveals that user doesn't exist
        throw new UserNotFoundException("User with ID " + id + " not found");
    }
    return user;
}

// GOOD: Generic error messages
@GetMapping("/api/users/{id}")
public User getUser(@PathVariable String id) {
    User user = userRepository.findById(id);
    if (user == null) {
        // GOOD: Generic error message
        throw new UserNotFoundException("Invalid credentials");
    }
    return user;
}

// BAD: Hardcoded secrets
@Service
class BadPaymentService {
    private static final String API_KEY = "sk_live_1234567890abcdef"; // BAD
    
    public void processPayment(PaymentRequest request) {
        // Use hardcoded API key
    }
}

// GOOD: Secrets from environment
@Service
class GoodPaymentService {
    @Value("${payment.api.key}")
    private String apiKey; // GOOD: From environment
    
    public void processPayment(PaymentRequest request) {
        // Use API key from environment
    }
}

// BAD: No encryption
@Entity
class BadUser {
    private String ssn; // BAD: Stored in plaintext
    private String creditCard; // BAD: Stored in plaintext
}

// GOOD: Encryption at rest
@Entity
class GoodUser {
    @Convert(converter = EncryptionConverter.class)
    private String ssn; // GOOD: Encrypted
    
    @Convert(converter = EncryptionConverter.class)
    private String creditCard; // GOOD: Encrypted
}
```

### 2.4 Error Handling

**Error Handling Checklist**:

```java
/**
 * Error Handling Review Checklist:
 * 
 * □ Generic error messages to users
 * □ Detailed errors logged securely
 * □ No stack traces exposed to users
 * □ No sensitive data in error messages
 * □ Proper exception handling
 * □ No information leakage
 * □ Fail securely
 */

// BAD: Stack trace exposed
@ExceptionHandler(Exception.class)
public ResponseEntity<ErrorResponse> handleException(Exception e) {
    // BAD: Exposing stack trace
    return ResponseEntity.status(500)
        .body(new ErrorResponse(e.getMessage(), e.getStackTrace()));
}

// GOOD: Generic error message
@ExceptionHandler(Exception.class)
public ResponseEntity<ErrorResponse> handleException(Exception e) {
    // GOOD: Log detailed error, return generic message
    logger.error("Internal error occurred", e);
    return ResponseEntity.status(500)
        .body(new ErrorResponse("An error occurred. Please try again later."));
}

// BAD: Information leakage
@GetMapping("/api/users/{id}")
public User getUser(@PathVariable String id) {
    try {
        return userRepository.findById(id);
    } catch (SQLException e) {
        // BAD: Reveals database structure
        throw new RuntimeException("Error querying users table: " + e.getMessage());
    }
}

// GOOD: Secure error handling
@GetMapping("/api/users/{id}")
public User getUser(@PathVariable String id) {
    try {
        return userRepository.findById(id);
    } catch (SQLException e) {
        // GOOD: Log details, return generic error
        logger.error("Database error", e);
        throw new UserNotFoundException("User not found");
    }
}
```

---

## 3. Common Security Vulnerabilities

### 3.1 SQL Injection

**Vulnerable Code**:

```java
// BAD: SQL Injection vulnerability
@Repository
class VulnerableUserRepository {
    public List<User> searchUsers(String searchTerm) {
        // BAD: String concatenation allows SQL injection
        String sql = "SELECT * FROM users WHERE name LIKE '%" + searchTerm + "%'";
        return jdbcTemplate.query(sql, new UserRowMapper());
    }
}

// Attack example:
// searchTerm = "'; DROP TABLE users; --"
// Results in: SELECT * FROM users WHERE name LIKE '%'; DROP TABLE users; --%'
```

**Secure Code**:

```java
// GOOD: Parameterized query
@Repository
class SecureUserRepository {
    public List<User> searchUsers(String searchTerm) {
        // GOOD: Parameterized query prevents SQL injection
        String sql = "SELECT * FROM users WHERE name LIKE ?";
        return jdbcTemplate.query(sql, new Object[]{"%" + searchTerm + "%"}, new UserRowMapper());
    }
}

// Using JPA (automatically safe)
@Repository
interface UserRepository extends JpaRepository<User, String> {
    // GOOD: JPA uses parameterized queries
    List<User> findByNameContaining(String name);
}
```

### 3.2 Cross-Site Scripting (XSS)

**Vulnerable Code**:

```java
// BAD: XSS vulnerability
@RestController
class VulnerableController {
    @GetMapping("/search")
    public String search(@RequestParam String query) {
        // BAD: No output encoding
        return "<h1>Results for: " + query + "</h1>";
    }
}

// Attack example:
// query = "<script>alert('XSS')</script>"
// Results in script execution
```

**Secure Code**:

```java
// GOOD: Output encoding
@RestController
class SecureController {
    @GetMapping("/search")
    public String search(@RequestParam String query) {
        // GOOD: Encode output
        String encoded = HtmlUtils.htmlEscape(query);
        return "<h1>Results for: " + encoded + "</h1>";
    }
}

// Using Thymeleaf (automatically escapes)
@Controller
class SecureThymeleafController {
    @GetMapping("/search")
    public String search(@RequestParam String query, Model model) {
        // GOOD: Thymeleaf automatically escapes
        model.addAttribute("query", query);
        return "search";
    }
}

// Thymeleaf template:
// <h1 th:text="${query}">Results</h1> <!-- Automatically escaped -->
```

### 3.3 Cross-Site Request Forgery (CSRF)

**Vulnerable Code**:

```java
// BAD: No CSRF protection
@RestController
class VulnerableController {
    @PostMapping("/api/transfer")
    public void transfer(@RequestBody TransferRequest request) {
        // BAD: No CSRF token validation
        accountService.transfer(request.getFrom(), request.getTo(), request.getAmount());
    }
}
```

**Secure Code**:

```java
// GOOD: CSRF protection
@Configuration
class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf
                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
            );
        return http.build();
    }
}

@RestController
class SecureController {
    @PostMapping("/api/transfer")
    public void transfer(@RequestBody TransferRequest request) {
        // GOOD: CSRF token automatically validated by Spring Security
        accountService.transfer(request.getFrom(), request.getTo(), request.getAmount());
    }
}
```

### 3.4 Insecure Direct Object References (IDOR)

**Vulnerable Code**:

```java
// BAD: IDOR vulnerability
@GetMapping("/api/users/{id}/orders")
public List<Order> getUserOrders(@PathVariable String id) {
    // BAD: No authorization check - user can access any user's orders
    return orderRepository.findByUserId(id);
}
```

**Secure Code**:

```java
// GOOD: Authorization check
@GetMapping("/api/users/{id}/orders")
@PreAuthorize("hasRole('ADMIN') or authentication.principal.id == #id")
public List<Order> getUserOrders(@PathVariable String id) {
    // GOOD: Authorization check prevents IDOR
    return orderRepository.findByUserId(id);
}

// Alternative: Check in service layer
@Service
class SecureOrderService {
    public List<Order> getUserOrders(String userId, String currentUserId) {
        // GOOD: Verify user can only access their own orders
        if (!userId.equals(currentUserId) && !isAdmin(currentUserId)) {
            throw new AccessDeniedException("Not authorized");
        }
        return orderRepository.findByUserId(userId);
    }
}
```

### 3.5 Security Misconfiguration

**Vulnerable Code**:

```java
// BAD: Security misconfiguration
@Configuration
class BadSecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable() // BAD: CSRF disabled
            .headers().disable() // BAD: Security headers disabled
            .authorizeHttpRequests().permitAll(); // BAD: Everything allowed
        return http.build();
    }
}
```

**Secure Code**:

```java
// GOOD: Secure configuration
@Configuration
class SecureSecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf
                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
            )
            .headers(headers -> headers
                .contentSecurityPolicy("default-src 'self'")
                .frameOptions(FrameOptionsMode.DENY)
                .xssProtection(XssProtectionConfig::and)
            )
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/public/**").permitAll()
                .anyRequest().authenticated()
            );
        return http.build();
    }
}
```

---

## 4. Automated Security Scanning

### 4.1 Static Application Security Testing (SAST)

**Tools**:

```java
/**
 * SAST Tools:
 * 
 * 1. SonarQube:
 *    - Code quality and security
 *    - Detects vulnerabilities
 *    - Integrates with CI/CD
 * 
 * 2. Checkmarx:
 *    - Security vulnerability scanning
 *    - OWASP Top 10 detection
 * 
 * 3. Veracode:
 *    - Static analysis
 *    - Security scanning
 * 
 * 4. SpotBugs:
 *    - Bug and security issue detection
 *    - Open source
 */
```

**SonarQube Integration**:

```xml
<!-- pom.xml -->
<plugin>
    <groupId>org.sonarsource.scanner.maven</groupId>
    <artifactId>sonar-maven-plugin</artifactId>
    <version>3.9.1.2184</version>
</plugin>
```

```bash
# Run SonarQube scan
mvn sonar:sonar
```

### 4.2 Dependency Scanning

**OWASP Dependency Check**:

```xml
<!-- pom.xml -->
<plugin>
    <groupId>org.owasp</groupId>
    <artifactId>dependency-check-maven</artifactId>
    <version>8.4.0</version>
    <executions>
        <execution>
            <goals>
                <goal>check</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

```bash
# Run dependency check
mvn dependency-check:check
```

**Snyk Integration**:

```bash
# Install Snyk
npm install -g snyk

# Scan dependencies
snyk test

# Monitor dependencies
snyk monitor
```

### 4.3 Container Security Scanning

**Trivy**:

```bash
# Scan Docker image
trivy image myapp:latest

# Scan with CI/CD
trivy fs --exit-code 1 --severity HIGH,CRITICAL .
```

**Clair**:

```yaml
# docker-compose.yml
version: '3'
services:
  clair:
    image: quay.io/coreos/clair:latest
    ports:
      - "6060:6060"
```

---

## 5. Security Review Process

### 5.1 Security Review Workflow

```java
/**
 * Security Review Workflow:
 * 
 * 1. Pre-Review:
 *    - Automated scans (SAST, dependency check)
 *    - Security checklist
 *    - Threat modeling
 * 
 * 2. Code Review:
 *    - Security-focused review
 *    - Vulnerability identification
 *    - Best practices check
 * 
 * 3. Security Testing:
 *    - Penetration testing
 *    - Security testing
 *    - Vulnerability assessment
 * 
 * 4. Approval:
 *    - Security team approval
 *    - Compliance check
 *    - Sign-off
 * 
 * 5. Post-Deployment:
 *    - Security monitoring
 *    - Vulnerability scanning
 *    - Incident response
 */
```

### 5.2 Security Review Template

```java
/**
 * Security Review Template:
 * 
 * PR: [PR Number]
 * Author: [Developer Name]
 * Reviewer: [Security Reviewer Name]
 * Date: [Date]
 * 
 * Security Checklist:
 * 
 * Authentication:
 * [ ] Strong password requirements
 * [ ] Secure password storage
 * [ ] Account lockout
 * [ ] Session management
 * [ ] MFA available
 * 
 * Authorization:
 * [ ] RBAC implemented
 * [ ] Permission checks
 * [ ] No privilege escalation
 * [ ] Resource-level auth
 * 
 * Input Validation:
 * [ ] All inputs validated
 * [ ] SQL injection prevention
 * [ ] XSS prevention
 * [ ] Command injection prevention
 * 
 * Data Protection:
 * [ ] Encryption at rest
 * [ ] Encryption in transit
 * [ ] No sensitive data in logs
 * [ ] Secure key management
 * 
 * Error Handling:
 * [ ] Generic error messages
 * [ ] No stack traces exposed
 * [ ] Secure logging
 * 
 * Security Configuration:
 * [ ] CSRF protection
 * [ ] Security headers
 * [ ] Secure defaults
 * 
 * Dependencies:
 * [ ] No known vulnerabilities
 * [ ] Up-to-date libraries
 * 
 * Findings:
 * [List of security issues found]
 * 
 * Status: [ ] Approved [ ] Needs Changes [ ] Rejected
 */
```

### 5.3 Security Review Best Practices

```java
/**
 * Security Review Best Practices:
 * 
 * 1. Review Early:
 *    - Review during design phase
 *    - Catch issues early
 *    - Lower cost to fix
 * 
 * 2. Focus on Security:
 *    - Separate from regular code review
 *    - Security-focused checklist
 *    - Threat modeling
 * 
 * 3. Use Tools:
 *    - Automated scanning
 *    - SAST tools
 *    - Dependency scanning
 * 
 * 4. Educate:
 *    - Explain vulnerabilities
 *    - Provide secure alternatives
 *    - Share best practices
 * 
 * 5. Document:
 *    - Document findings
 *    - Track fixes
 *    - Learn from reviews
 */
```

---

## 6. Practical Examples

### 6.1 Complete Security Review Example

**Vulnerable Code**:

```java
@RestController
@RequestMapping("/api/users")
class VulnerableUserController {
    
    @Autowired
    private UserRepository userRepository;
    
    @GetMapping("/{id}")
    public User getUser(@PathVariable String id) {
        // VULNERABILITY 1: No authorization check (IDOR)
        return userRepository.findById(id);
    }
    
    @PostMapping
    public User createUser(@RequestBody UserRequest request) {
        // VULNERABILITY 2: No input validation
        User user = new User();
        user.setEmail(request.getEmail()); // Could be anything
        user.setPassword(request.getPassword()); // No hashing
        
        // VULNERABILITY 3: SQL injection risk (if using string concatenation)
        return userRepository.save(user);
    }
    
    @GetMapping("/search")
    public String search(@RequestParam String query) {
        // VULNERABILITY 4: XSS vulnerability
        return "<h1>Results: " + query + "</h1>";
    }
    
    @PostMapping("/{id}/password")
    public void changePassword(@PathVariable String id, @RequestBody PasswordRequest request) {
        // VULNERABILITY 5: No authorization check
        // VULNERABILITY 6: Weak password hashing (if implemented)
        User user = userRepository.findById(id);
        user.setPassword(request.getNewPassword()); // No hashing
        userRepository.save(user);
    }
}
```

**Secure Code**:

```java
@RestController
@RequestMapping("/api/users")
@PreAuthorize("hasRole('USER')")
class SecureUserController {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or authentication.principal.id == #id")
    public UserResponse getUser(@PathVariable String id) {
        // SECURE: Authorization check prevents IDOR
        User user = userRepository.findById(id);
        return mapToResponse(user);
    }
    
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public UserResponse createUser(@Valid @RequestBody UserRequest request) {
        // SECURE: Input validation with @Valid
        User user = new User();
        user.setEmail(request.getEmail()); // Validated by @Email
        user.setPassword(passwordEncoder.encode(request.getPassword())); // Secure hashing
        
        return mapToResponse(userRepository.save(user));
    }
    
    @GetMapping("/search")
    public String search(@RequestParam @Size(max = 100) String query) {
        // SECURE: Output encoding prevents XSS
        String encoded = HtmlUtils.htmlEscape(query);
        return "<h1>Results: " + encoded + "</h1>";
    }
    
    @PostMapping("/{id}/password")
    @PreAuthorize("hasRole('ADMIN') or authentication.principal.id == #id")
    public void changePassword(@PathVariable String id, 
                               @Valid @RequestBody PasswordRequest request) {
        // SECURE: Authorization check + input validation + secure hashing
        User user = userRepository.findById(id);
        user.setPassword(passwordEncoder.encode(request.getNewPassword()));
        userRepository.save(user);
    }
}
```

### 6.2 Security Review Checklist Implementation

```java
@Service
class SecurityReviewService {
    
    public SecurityReviewResult reviewCode(String code, String filePath) {
        SecurityReviewResult result = new SecurityReviewResult();
        
        // Check for common vulnerabilities
        checkSQLInjection(code, result);
        checkXSS(code, result);
        checkHardcodedSecrets(code, result);
        checkWeakEncryption(code, result);
        checkMissingAuthorization(code, result);
        checkInsecureRandom(code, result);
        
        return result;
    }
    
    private void checkSQLInjection(String code, SecurityReviewResult result) {
        // Check for string concatenation in SQL queries
        if (code.contains("SELECT") && code.contains("+") && code.contains("\"")) {
            result.addFinding(Severity.HIGH, 
                "Potential SQL injection: String concatenation in SQL query");
        }
    }
    
    private void checkXSS(String code, SecurityReviewResult result) {
        // Check for unescaped output
        if (code.contains("return") && code.contains("+") && 
            !code.contains("HtmlUtils.htmlEscape") && 
            !code.contains("th:text")) {
            result.addFinding(Severity.MEDIUM, 
                "Potential XSS: Unescaped output");
        }
    }
    
    private void checkHardcodedSecrets(String code, SecurityReviewResult result) {
        // Check for hardcoded secrets
        String[] secretPatterns = {
            "password\\s*=\\s*[\"'].*[\"']",
            "apiKey\\s*=\\s*[\"'].*[\"']",
            "secret\\s*=\\s*[\"'].*[\"']"
        };
        
        for (String pattern : secretPatterns) {
            if (code.matches(".*" + pattern + ".*")) {
                result.addFinding(Severity.CRITICAL, 
                    "Hardcoded secret found");
            }
        }
    }
}
```

---

## Summary: Part 4

### Key Concepts

1. **Security Code Review**: Systematic examination for vulnerabilities
2. **Review Checklist**: Authentication, Authorization, Input Validation, Data Protection
3. **Common Vulnerabilities**: SQL Injection, XSS, CSRF, IDOR, Security Misconfiguration
4. **Automated Scanning**: SAST, Dependency Scanning, Container Scanning
5. **Review Process**: Pre-review, Code Review, Testing, Approval

### Next Steps

**Part 5** will cover:
- Incident Response and Security Operations
- Security Monitoring
- Security Incident Handling
- Security Operations Best Practices

---

**Master security code review to prevent vulnerabilities before deployment!**

