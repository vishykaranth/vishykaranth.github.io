# Security and Compliance Leadership for Principal Engineers

## Part 2: OWASP Top 10 and Security Best Practices

---

## Table of Contents

1. [OWASP Top 10 Overview](#1-owasp-top-10-overview)
2. [Detailed OWASP Top 10 Vulnerabilities](#2-detailed-owasp-top-10-vulnerabilities)
3. [Security Best Practices](#3-security-best-practices)
4. [Secure Coding Guidelines](#4-secure-coding-guidelines)
5. [Practical Examples and Mitigations](#5-practical-examples-and-mitigations)

---

## 1. OWASP Top 10 Overview

### 1.1 What is OWASP Top 10?

**OWASP (Open Web Application Security Project) Top 10** is a standard awareness document for developers and web application security. It represents a broad consensus about the most critical security risks to web applications.

**2021 OWASP Top 10**:
1. Broken Access Control
2. Cryptographic Failures
3. Injection
4. Insecure Design
5. Security Misconfiguration
6. Vulnerable and Outdated Components
7. Identification and Authentication Failures
8. Software and Data Integrity Failures
9. Security Logging and Monitoring Failures
10. Server-Side Request Forgery (SSRF)

### 1.2 Impact of OWASP Top 10

```java
/**
 * Impact of OWASP Top 10 Vulnerabilities:
 * 
 * - Data breaches: Millions of records exposed
 * - Financial loss: Average $4.45M per breach (2023)
 * - Reputation damage: Loss of customer trust
 * - Compliance violations: GDPR, HIPAA, PCI-DSS fines
 * - Business disruption: Service downtime
 */
```

---

## 2. Detailed OWASP Top 10 Vulnerabilities

### 2.1 A01:2021 – Broken Access Control

**Description**: Access control enforces policies such that users cannot act outside of their intended permissions.

**Common Vulnerabilities**:
- Bypassing access control checks
- Privilege escalation
- Insecure direct object references (IDOR)
- Missing function-level access control

**Vulnerable Code Example**:
```java
// VULNERABLE: No access control check
@GetMapping("/api/users/{id}")
public User getUser(@PathVariable String id) {
    return userRepository.findById(id); // Anyone can access any user
}

// VULNERABLE: Insecure direct object reference
@GetMapping("/api/orders/{orderId}")
public Order getOrder(@PathVariable String orderId) {
    return orderRepository.findById(orderId); // No ownership check
}
```

**Secure Implementation**:
```java
// SECURE: Access control check
@GetMapping("/api/users/{id}")
@PreAuthorize("hasRole('ADMIN') or authentication.principal.id == #id")
public User getUser(@PathVariable String id, 
                    @AuthenticationPrincipal User currentUser) {
    // Additional check
    if (!currentUser.hasRole("ADMIN") && !currentUser.getId().equals(id)) {
        throw new AccessDeniedException("Not authorized");
    }
    return userRepository.findById(id);
}

// SECURE: Ownership verification
@GetMapping("/api/orders/{orderId}")
public Order getOrder(@PathVariable String orderId,
                     @AuthenticationPrincipal User currentUser) {
    Order order = orderRepository.findById(orderId)
        .orElseThrow(() -> new NotFoundException("Order not found"));
    
    // Verify ownership
    if (!order.getUserId().equals(currentUser.getId()) && 
        !currentUser.hasRole("ADMIN")) {
        throw new AccessDeniedException("Not authorized to access this order");
    }
    
    return order;
}

// SECURE: Function-level access control
@DeleteMapping("/api/users/{id}")
@PreAuthorize("hasRole('ADMIN')")
@PreAuthorize("authentication.principal.id != #id") // Cannot delete yourself
public void deleteUser(@PathVariable String id,
                      @AuthenticationPrincipal User currentUser) {
    if (currentUser.getId().equals(id)) {
        throw new IllegalArgumentException("Cannot delete your own account");
    }
    userRepository.deleteById(id);
}
```

**Best Practices**:
```java
@Service
class AccessControlService {
    
    /**
     * Access Control Best Practices:
     * 
     * 1. Deny by default
     * 2. Enforce access control on every request
     * 3. Use principle of least privilege
     * 4. Verify ownership/authorization
     * 5. Log access control failures
     */
    
    public boolean canAccessResource(User user, Resource resource, String action) {
        // Check role-based access
        if (!user.hasRole(getRequiredRole(resource, action))) {
            auditService.log("ACCESS_DENIED", user.getId(), resource.getId(), action);
            return false;
        }
        
        // Check resource ownership
        if (resource.isOwned() && !resource.getOwnerId().equals(user.getId())) {
            auditService.log("ACCESS_DENIED_OWNERSHIP", user.getId(), resource.getId());
            return false;
        }
        
        // Check time-based access (e.g., business hours)
        if (!isAccessAllowedAtCurrentTime(user, resource)) {
            auditService.log("ACCESS_DENIED_TIME", user.getId(), resource.getId());
            return false;
        }
        
        return true;
    }
}
```

### 2.2 A02:2021 – Cryptographic Failures

**Description**: Failures related to cryptography which often lead to exposure of sensitive data.

**Common Vulnerabilities**:
- Weak encryption algorithms
- Insecure key management
- Plaintext storage of sensitive data
- Weak random number generation

**Vulnerable Code Example**:
```java
// VULNERABLE: Weak encryption
public String encrypt(String data) {
    // Using weak DES algorithm
    Cipher cipher = Cipher.getInstance("DES");
    // ...
}

// VULNERABLE: Plaintext storage
@Entity
class User {
    private String password; // Stored in plaintext!
    private String ssn;      // Stored in plaintext!
}

// VULNERABLE: Weak random number generation
public String generateToken() {
    return UUID.randomUUID().toString(); // Not cryptographically secure
}
```

**Secure Implementation**:
```java
// SECURE: Strong encryption (AES-256-GCM)
@Service
class SecureEncryptionService {
    
    private static final String ALGORITHM = "AES/GCM/NoPadding";
    private static final int KEY_SIZE = 256;
    private static final int IV_SIZE = 12;
    private static final int TAG_LENGTH = 128;
    
    @Value("${encryption.key}")
    private String base64Key;
    
    private SecretKey secretKey;
    
    @PostConstruct
    public void init() throws Exception {
        byte[] keyBytes = Base64.getDecoder().decode(base64Key);
        secretKey = new SecretKeySpec(keyBytes, "AES");
    }
    
    public String encrypt(String plaintext) throws Exception {
        // Generate random IV
        byte[] iv = new byte[IV_SIZE];
        SecureRandom random = SecureRandom.getInstanceStrong();
        random.nextBytes(iv);
        
        // Initialize cipher
        GCMParameterSpec parameterSpec = new GCMParameterSpec(TAG_LENGTH, iv);
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, secretKey, parameterSpec);
        
        // Encrypt
        byte[] ciphertext = cipher.doFinal(plaintext.getBytes(StandardCharsets.UTF_8));
        
        // Combine IV and ciphertext
        byte[] encrypted = new byte[IV_SIZE + ciphertext.length];
        System.arraycopy(iv, 0, encrypted, 0, IV_SIZE);
        System.arraycopy(ciphertext, 0, encrypted, IV_SIZE, ciphertext.length);
        
        return Base64.getEncoder().encodeToString(encrypted);
    }
    
    public String decrypt(String ciphertext) throws Exception {
        byte[] encrypted = Base64.getDecoder().decode(ciphertext);
        
        // Extract IV
        byte[] iv = new byte[IV_SIZE];
        System.arraycopy(encrypted, 0, iv, 0, IV_SIZE);
        
        // Extract actual ciphertext
        byte[] ct = new byte[encrypted.length - IV_SIZE];
        System.arraycopy(encrypted, IV_SIZE, ct, 0, ct.length);
        
        // Decrypt
        GCMParameterSpec parameterSpec = new GCMParameterSpec(TAG_LENGTH, iv);
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.DECRYPT_MODE, secretKey, parameterSpec);
        
        byte[] plaintext = cipher.doFinal(ct);
        return new String(plaintext, StandardCharsets.UTF_8);
    }
}

// SECURE: Password hashing (bcrypt/Argon2)
@Service
class PasswordService {
    
    private final PasswordEncoder passwordEncoder;
    
    public PasswordService() {
        // Use bcrypt with strength 12 (recommended)
        this.passwordEncoder = new BCryptPasswordEncoder(12);
    }
    
    public String hashPassword(String plainPassword) {
        return passwordEncoder.encode(plainPassword);
    }
    
    public boolean verifyPassword(String plainPassword, String hashedPassword) {
        return passwordEncoder.matches(plainPassword, hashedPassword);
    }
}

// SECURE: Cryptographically secure random token
@Service
class SecureTokenService {
    
    private final SecureRandom secureRandom = new SecureRandom();
    
    public String generateSecureToken(int length) {
        byte[] bytes = new byte[length];
        secureRandom.nextBytes(bytes);
        return Base64.getUrlEncoder().withoutPadding().encodeToString(bytes);
    }
    
    public String generateSessionToken() {
        // 32 bytes = 256 bits of entropy
        return generateSecureToken(32);
    }
}
```

**Key Management Best Practices**:
```java
@Configuration
class KeyManagementConfig {
    
    /**
     * Key Management Best Practices:
     * 
     * 1. Use key management service (AWS KMS, HashiCorp Vault)
     * 2. Rotate keys regularly
     * 3. Separate keys for different purposes
     * 4. Never hardcode keys
     * 5. Use environment variables or secrets manager
     */
    
    @Bean
    public SecretKey encryptionKey() {
        // Get key from secrets manager (AWS Secrets Manager, Vault, etc.)
        String keyBase64 = secretsManager.getSecret("encryption-key");
        byte[] keyBytes = Base64.getDecoder().decode(keyBase64);
        return new SecretKeySpec(keyBytes, "AES");
    }
    
    @Bean
    public KeyRotationService keyRotationService() {
        return new KeyRotationService() {
            @Scheduled(cron = "0 0 0 1 * ?") // Monthly rotation
            public void rotateKeys() {
                // Generate new key
                // Re-encrypt data with new key
                // Update key in secrets manager
            }
        };
    }
}
```

### 2.3 A03:2021 – Injection

**Description**: Injection flaws occur when untrusted data is sent to an interpreter as part of a command or query.

**Common Vulnerabilities**:
- SQL Injection
- NoSQL Injection
- Command Injection
- LDAP Injection
- XPath Injection

**Vulnerable Code Example**:
```java
// VULNERABLE: SQL Injection
@GetMapping("/api/users")
public List<User> searchUsers(@RequestParam String search) {
    String query = "SELECT * FROM users WHERE name LIKE '%" + search + "%'";
    // Attacker can inject: search = "'; DROP TABLE users; --"
    return jdbcTemplate.query(query, new UserRowMapper());
}

// VULNERABLE: NoSQL Injection
@GetMapping("/api/users")
public List<User> findUsers(@RequestParam String username) {
    // Attacker can inject: username = {"$ne": null}
    Query query = new Query();
    query.addCriteria(Criteria.where("username").is(username));
    return mongoTemplate.find(query, User.class);
}

// VULNERABLE: Command Injection
public void processFile(String filename) {
    Runtime.getRuntime().exec("cat " + filename);
    // Attacker can inject: filename = "file.txt; rm -rf /"
}
```

**Secure Implementation**:
```java
// SECURE: Parameterized queries (SQL)
@Repository
class SecureUserRepository {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    public List<User> searchUsers(String search) {
        // Use parameterized query
        String sql = "SELECT * FROM users WHERE name LIKE ?";
        String searchPattern = "%" + search + "%";
        return jdbcTemplate.query(sql, new Object[]{searchPattern}, new UserRowMapper());
    }
    
    public User findById(String id) {
        // Parameterized query prevents SQL injection
        String sql = "SELECT * FROM users WHERE id = ?";
        return jdbcTemplate.queryForObject(sql, new Object[]{id}, new UserRowMapper());
    }
}

// SECURE: JPA/Hibernate (automatically parameterized)
@Repository
interface UserRepository extends JpaRepository<User, String> {
    // JPA automatically uses parameterized queries
    @Query("SELECT u FROM User u WHERE u.name LIKE %:search%")
    List<User> searchUsers(@Param("search") String search);
    
    // Method name query (also safe)
    List<User> findByNameContaining(String name);
}

// SECURE: NoSQL Injection prevention
@Repository
class SecureMongoUserRepository {
    
    @Autowired
    private MongoTemplate mongoTemplate;
    
    public List<User> findUsers(String username) {
        // Validate and sanitize input
        if (!isValidUsername(username)) {
            throw new IllegalArgumentException("Invalid username");
        }
        
        // Use typed query
        Query query = new Query();
        query.addCriteria(Criteria.where("username").is(username));
        return mongoTemplate.find(query, User.class);
    }
    
    private boolean isValidUsername(String username) {
        // Whitelist validation
        return username.matches("^[a-zA-Z0-9_]{3,20}$");
    }
}

// SECURE: Input validation and sanitization
@Service
class InputValidationService {
    
    public String sanitizeInput(String input) {
        if (input == null) return null;
        
        // Remove potentially dangerous characters
        return input.replaceAll("[<>\"'%;()&+]", "");
    }
    
    public boolean isValidEmail(String email) {
        String emailRegex = "^[A-Za-z0-9+_.-]+@(.+)$";
        Pattern pattern = Pattern.compile(emailRegex);
        return pattern.matcher(email).matches();
    }
    
    public boolean isValidId(String id) {
        // UUID validation
        try {
            UUID.fromString(id);
            return true;
        } catch (IllegalArgumentException e) {
            return false;
        }
    }
}

// SECURE: Command execution (avoid if possible, or use safe methods)
@Service
class SecureFileService {
    
    public void processFile(String filename) {
        // Validate filename
        if (!isValidFilename(filename)) {
            throw new IllegalArgumentException("Invalid filename");
        }
        
        // Use safe file operations instead of command execution
        Path filePath = Paths.get("/safe/directory", filename);
        
        // Additional security: Check if file is within allowed directory
        if (!filePath.normalize().startsWith(Paths.get("/safe/directory"))) {
            throw new SecurityException("Path traversal detected");
        }
        
        // Read file safely
        Files.readAllLines(filePath);
    }
    
    private boolean isValidFilename(String filename) {
        // Whitelist: only alphanumeric, dots, hyphens, underscores
        return filename.matches("^[a-zA-Z0-9._-]+$");
    }
}
```

### 2.4 A04:2021 – Insecure Design

**Description**: Missing or ineffective control design that fails to prevent security issues.

**Common Vulnerabilities**:
- Missing security controls
- Weak security architecture
- Insecure by default
- Missing threat modeling

**Secure Design Principles**:
```java
/**
 * Secure Design Principles:
 * 
 * 1. Security by Design:
 *    - Build security in from the start
 *    - Threat modeling
 *    - Security requirements
 * 
 * 2. Defense in Depth:
 *    - Multiple security layers
 *    - No single point of failure
 * 
 * 3. Fail Securely:
 *    - Fail closed, not open
 *    - Secure error handling
 * 
 * 4. Least Privilege:
 *    - Minimum necessary permissions
 *    - Principle of least access
 * 
 * 5. Complete Mediation:
 *    - Check every access
 *    - Don't trust cached permissions
 */
```

**Secure Design Example**:
```java
@Configuration
class SecureDesignConfig {
    
    /**
     * Secure Design Implementation:
     * 
     * 1. Authentication required by default
     * 2. Authorization checks on all endpoints
     * 3. Input validation on all inputs
     * 4. Output encoding on all outputs
     * 5. Error handling that doesn't leak information
     */
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            // Secure by default: require authentication
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/public/**").permitAll()
                .anyRequest().authenticated() // Default: require auth
            )
            
            // Secure error handling
            .exceptionHandling(ex -> ex
                .authenticationEntryPoint(customAuthenticationEntryPoint())
                .accessDeniedHandler(customAccessDeniedHandler())
            )
            
            // Secure headers
            .headers(headers -> headers
                .contentSecurityPolicy("default-src 'self'")
                .frameOptions(FrameOptionsMode.DENY)
                .xssProtection(XssProtectionConfig::and)
            );
        
        return http.build();
    }
}

// Secure error handling
@Component
class SecureErrorHandler {
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleException(Exception e) {
        // Log full error internally
        logger.error("Error occurred", e);
        
        // Return generic error to client (don't leak information)
        ErrorResponse error = new ErrorResponse(
            "An error occurred. Please contact support.",
            "ERROR_001"
        );
        
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
    
    @ExceptionHandler(ValidationException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(ValidationException e) {
        // Validation errors can be more specific
        ErrorResponse error = new ErrorResponse(
            "Validation failed: " + e.getMessage(),
            "VALIDATION_ERROR"
        );
        
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }
}
```

### 2.5 A05:2021 – Security Misconfiguration

**Description**: Security misconfiguration is the most commonly seen issue.

**Common Misconfigurations**:
- Default credentials
- Unnecessary features enabled
- Missing security headers
- Insecure configurations
- Outdated software

**Secure Configuration**:
```java
@Configuration
class SecureConfiguration {
    
    /**
     * Security Configuration Best Practices:
     * 
     * 1. Remove default credentials
     * 2. Disable unnecessary features
     * 3. Set secure headers
     * 4. Use secure protocols
     * 5. Regular security updates
     */
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            // Disable unnecessary features
            .headers(headers -> headers
                .frameOptions(FrameOptionsMode.DENY) // Prevent clickjacking
                .contentTypeOptions(HeadersConfigurer.ContentTypeOptionsConfig::and)
                .httpStrictTransportSecurity(hsts -> hsts
                    .maxAgeInSeconds(31536000)
                    .includeSubdomains(true)
                )
            )
            
            // Secure session configuration
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .maximumSessions(1)
                .maxSessionsPreventsLogin(true)
            )
            
            // CSRF protection
            .csrf(csrf -> csrf
                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
            );
        
        return http.build();
    }
    
    @Bean
    public DataSource dataSource() {
        HikariConfig config = new HikariConfig();
        
        // Secure database configuration
        config.setJdbcUrl("jdbc:postgresql://localhost:5432/mydb");
        config.setUsername(getSecret("db.username")); // From secrets manager
        config.setPassword(getSecret("db.password")); // From secrets manager
        
        // Security settings
        config.addDataSourceProperty("ssl", "true");
        config.addDataSourceProperty("sslmode", "require");
        
        return new HikariDataSource(config);
    }
}
```

---

## 3. Security Best Practices

### 3.1 Input Validation

```java
@Service
class InputValidationService {
    
    /**
     * Input Validation Best Practices:
     * 
     * 1. Validate all inputs
     * 2. Use whitelist validation
     * 3. Sanitize inputs
     * 4. Validate length
     * 5. Validate format
     */
    
    public void validateUserInput(UserRequest request) {
        // Validate email
        if (!isValidEmail(request.getEmail())) {
            throw new ValidationException("Invalid email format");
        }
        
        // Validate username (whitelist)
        if (!request.getUsername().matches("^[a-zA-Z0-9_]{3,20}$")) {
            throw new ValidationException("Invalid username format");
        }
        
        // Validate length
        if (request.getPassword().length() < 8 || request.getPassword().length() > 128) {
            throw new ValidationException("Password must be 8-128 characters");
        }
        
        // Validate password strength
        if (!isStrongPassword(request.getPassword())) {
            throw new ValidationException("Password does not meet strength requirements");
        }
    }
    
    private boolean isValidEmail(String email) {
        String emailRegex = "^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$";
        return Pattern.matches(emailRegex, email);
    }
    
    private boolean isStrongPassword(String password) {
        // At least 8 characters, 1 uppercase, 1 lowercase, 1 digit, 1 special char
        String passwordRegex = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$";
        return Pattern.matches(passwordRegex, password);
    }
}
```

### 3.2 Output Encoding

```java
@Service
class OutputEncodingService {
    
    /**
     * Output Encoding Best Practices:
     * 
     * 1. Encode all outputs
     * 2. Context-aware encoding
     * 3. HTML encoding for HTML context
     * 4. JavaScript encoding for JS context
     * 5. URL encoding for URL context
     */
    
    public String encodeForHTML(String input) {
        if (input == null) return null;
        
        return input
            .replace("&", "&amp;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace("\"", "&quot;")
            .replace("'", "&#x27;")
            .replace("/", "&#x2F;");
    }
    
    public String encodeForJavaScript(String input) {
        if (input == null) return null;
        
        return input
            .replace("\\", "\\\\")
            .replace("'", "\\'")
            .replace("\"", "\\\"")
            .replace("\n", "\\n")
            .replace("\r", "\\r")
            .replace("/", "\\/");
    }
    
    public String encodeForURL(String input) {
        try {
            return URLEncoder.encode(input, StandardCharsets.UTF_8.toString());
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }
}
```

### 3.3 Secure Session Management

```java
@Configuration
class SecureSessionConfig {
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS) // JWT tokens
                .maximumSessions(1) // Single session per user
                .maxSessionsPreventsLogin(true) // Prevent concurrent logins
            );
        
        return http.build();
    }
    
    // For stateful sessions
    @Bean
    public CookieSerializer cookieSerializer() {
        DefaultCookieSerializer serializer = new DefaultCookieSerializer();
        serializer.setCookieName("JSESSIONID");
        serializer.setCookiePath("/");
        serializer.setDomainNamePattern("^.+?\\.(\\w+\\.[a-z]+)$");
        serializer.setUseHttpOnlyCookie(true); // Prevent XSS
        serializer.setUseSecureCookie(true); // HTTPS only
        serializer.setSameSite("Strict"); // CSRF protection
        return serializer;
    }
}
```

---

## 4. Secure Coding Guidelines

### 4.1 Secure Coding Checklist

```java
/**
 * Secure Coding Checklist:
 * 
 * Authentication:
 * □ Strong password requirements
 * □ Multi-factor authentication
 * □ Secure password storage (bcrypt/Argon2)
 * □ Account lockout after failed attempts
 * □ Session timeout
 * 
 * Authorization:
 * □ Role-based access control
 * □ Principle of least privilege
 * □ Ownership verification
 * □ Function-level access control
 * 
 * Input Validation:
 * □ Validate all inputs
 * □ Use whitelist validation
 * □ Sanitize inputs
 * □ Validate length and format
 * 
 * Output Encoding:
 * □ Encode all outputs
 * □ Context-aware encoding
 * □ Prevent XSS
 * 
 * Cryptography:
 * □ Use strong algorithms (AES-256)
 * □ Secure key management
 * □ Encrypt sensitive data
 * □ Use HTTPS/TLS
 * 
 * Error Handling:
 * □ Don't leak information
 * □ Log errors securely
 * □ Generic error messages
 * 
 * Logging:
 * □ Log security events
 * □ Don't log sensitive data
 * □ Secure log storage
 * 
 * Dependencies:
 * □ Keep dependencies updated
 * □ Scan for vulnerabilities
 * □ Use trusted sources
 */
```

### 4.2 Code Review Security Checklist

```java
/**
 * Security Code Review Checklist:
 * 
 * 1. Authentication & Authorization:
 *    □ All endpoints require authentication
 *    □ Authorization checks present
 *    □ No privilege escalation
 *    □ Ownership verification
 * 
 * 2. Input Validation:
 *    □ All inputs validated
 *    □ SQL injection prevention
 *    □ XSS prevention
 *    □ Command injection prevention
 * 
 * 3. Cryptography:
 *    □ Strong encryption algorithms
 *    □ Secure key management
 *    □ Password hashing (not plaintext)
 *    □ HTTPS/TLS used
 * 
 * 4. Error Handling:
 *    □ No information leakage
 *    □ Generic error messages
 *    □ Secure logging
 * 
 * 5. Configuration:
 *    □ No hardcoded secrets
 *    □ Secure defaults
 *    □ Security headers set
 * 
 * 6. Dependencies:
 *    □ Up-to-date dependencies
 *    □ No known vulnerabilities
 */
```

---

## 5. Practical Examples and Mitigations

### 5.1 Complete Secure API Endpoint

```java
@RestController
@RequestMapping("/api/v1/users")
class SecureUserController {
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private InputValidationService validationService;
    
    @Autowired
    private AuditService auditService;
    
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    @RateLimit(requests = 100, window = 60)
    public ResponseEntity<UserResponse> createUser(@Valid @RequestBody UserRequest request) {
        // 1. Input validation
        validationService.validateUserInput(request);
        
        // 2. Sanitize input
        String sanitizedEmail = sanitizeEmail(request.getEmail());
        
        // 3. Create user
        User user = userService.createUser(request);
        
        // 4. Audit log
        auditService.log("USER_CREATED", user.getId());
        
        // 5. Return response (no sensitive data)
        UserResponse response = mapToResponse(user);
        return ResponseEntity.ok(response);
    }
    
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('USER') or hasRole('ADMIN')")
    public ResponseEntity<UserResponse> getUser(
            @PathVariable @ValidUUID String id,
            @AuthenticationPrincipal User currentUser) {
        
        // 1. Authorization check
        if (!canAccessUser(currentUser, id)) {
            throw new AccessDeniedException("Not authorized");
        }
        
        // 2. Get user
        User user = userService.getUser(id);
        
        // 3. Map response (mask sensitive data for non-admins)
        UserResponse response = mapToResponse(user, currentUser);
        
        // 4. Audit log
        auditService.log("USER_ACCESSED", currentUser.getId(), id);
        
        return ResponseEntity.ok()
            .cacheControl(CacheControl.maxAge(5, TimeUnit.MINUTES))
            .body(response);
    }
    
    private boolean canAccessUser(User currentUser, String userId) {
        return currentUser.hasRole("ADMIN") || currentUser.getId().equals(userId);
    }
    
    private String sanitizeEmail(String email) {
        return email.replaceAll("[^a-zA-Z0-9@._-]", "");
    }
}
```

### 5.2 Secure Password Management

```java
@Service
class SecurePasswordService {
    
    private final PasswordEncoder passwordEncoder = new BCryptPasswordEncoder(12);
    
    public PasswordValidationResult validatePassword(String password) {
        List<String> errors = new ArrayList<>();
        
        if (password.length() < 8) {
            errors.add("Password must be at least 8 characters");
        }
        if (password.length() > 128) {
            errors.add("Password must be less than 128 characters");
        }
        if (!password.matches(".*[a-z].*")) {
            errors.add("Password must contain at least one lowercase letter");
        }
        if (!password.matches(".*[A-Z].*")) {
            errors.add("Password must contain at least one uppercase letter");
        }
        if (!password.matches(".*\\d.*")) {
            errors.add("Password must contain at least one digit");
        }
        if (!password.matches(".*[@$!%*?&].*")) {
            errors.add("Password must contain at least one special character");
        }
        
        // Check against common passwords
        if (isCommonPassword(password)) {
            errors.add("Password is too common");
        }
        
        return new PasswordValidationResult(errors.isEmpty(), errors);
    }
    
    public String hashPassword(String plainPassword) {
        return passwordEncoder.encode(plainPassword);
    }
    
    public boolean verifyPassword(String plainPassword, String hashedPassword) {
        return passwordEncoder.matches(plainPassword, hashedPassword);
    }
    
    private boolean isCommonPassword(String password) {
        // Check against common password list
        Set<String> commonPasswords = Set.of(
            "password", "12345678", "qwerty", "abc123", "password123"
        );
        return commonPasswords.contains(password.toLowerCase());
    }
}
```

---

## Summary: Part 2

### Key Concepts

1. **OWASP Top 10**: Critical security risks to address
2. **Broken Access Control**: Enforce authorization everywhere
3. **Cryptographic Failures**: Use strong encryption and secure key management
4. **Injection**: Use parameterized queries and input validation
5. **Insecure Design**: Security by design, defense in depth
6. **Security Misconfiguration**: Secure defaults, remove unnecessary features

### Best Practices

1. **Input Validation**: Validate and sanitize all inputs
2. **Output Encoding**: Encode all outputs contextually
3. **Secure Coding**: Follow security checklist
4. **Code Review**: Security-focused code reviews

### Next Steps

**Part 3** will cover:
- Compliance Requirements (GDPR, HIPAA, SOC2, PCI-DSS)
- Compliance Implementation
- Data Protection Regulations
- Audit and Compliance Management

---

**Master OWASP Top 10 and security best practices to build secure applications!**

