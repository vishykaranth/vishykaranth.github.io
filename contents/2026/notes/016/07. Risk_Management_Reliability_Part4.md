# Risk Management and Reliability Engineering: Master Guide for Principal Engineers

## Part 4: Incident Response, Post-Mortems, and Continuous Improvement

---

## Table of Contents

1. [Incident Response Fundamentals](#1-incident-response-fundamentals)
2. [Incident Response Process](#2-incident-response-process)
3. [Incident Classification](#3-incident-classification)
4. [Incident Response Tools](#4-incident-response-tools)
5. [Post-Mortem Analysis](#5-post-mortem-analysis)
6. [Reliability Metrics and SLIs/SLOs](#6-reliability-metrics-and-slis-slos)
7. [Continuous Improvement](#7-continuous-improvement)
8. [Practical Examples](#8-practical-examples)

---

## 1. Incident Response Fundamentals

### 1.1 What is an Incident?

**Incident**: An unplanned interruption or reduction in quality of service.

```java
/**
 * Incident Characteristics:
 * 
 * 1. Unplanned:
 *    - Not scheduled maintenance
 *    - Unexpected event
 * 
 * 2. Service Impact:
 *    - Affects users
 *    - Degrades performance
 *    - Causes errors
 * 
 * 3. Requires Response:
 *    - Needs investigation
 *    - Requires remediation
 *    - May need escalation
 */
```

### 1.2 Incident Response Goals

```java
/**
 * Incident Response Goals:
 * 
 * 1. Minimize Impact:
 *    - Reduce downtime
 *    - Limit user impact
 *    - Preserve data integrity
 * 
 * 2. Restore Service:
 *    - Quick resolution
 *    - Effective remediation
 *    - Verify recovery
 * 
 * 3. Learn and Improve:
 *    - Understand root cause
 *    - Prevent recurrence
 *    - Improve processes
 * 
 * 4. Communication:
 *    - Keep stakeholders informed
 *    - Transparent updates
 *    - Post-incident reports
 */
```

### 1.3 Incident Response Team Roles

```java
/**
 * Incident Response Team Roles:
 * 
 * 1. Incident Commander:
 *    - Overall coordination
 *    - Decision making
 *    - Communication
 * 
 * 2. Technical Lead:
 *    - Technical investigation
 *    - Root cause analysis
 *    - Solution implementation
 * 
 * 3. Communications Lead:
 *    - Stakeholder updates
 *    - Status page updates
 *    - Customer communication
 * 
 * 4. Scribe:
 *    - Document timeline
 *    - Record actions taken
 *    - Maintain incident log
 * 
 * 5. Subject Matter Experts:
 *    - Domain knowledge
 *    - Specialized skills
 *    - On-call engineers
 */
```

---

## 2. Incident Response Process

### 2.1 Incident Response Lifecycle

```java
/**
 * Incident Response Lifecycle:
 * 
 * 1. Detection:
 *    - Monitoring alerts
 *    - User reports
 *    - Automated detection
 * 
 * 2. Triage:
 *    - Assess severity
 *    - Classify incident
 *    - Assign team
 * 
 * 3. Response:
 *    - Investigate cause
 *    - Implement fix
 *    - Verify resolution
 * 
 * 4. Recovery:
 *    - Restore service
 *    - Validate functionality
 *    - Monitor stability
 * 
 * 5. Post-Incident:
 *    - Post-mortem
 *    - Action items
 *    - Process improvement
 */
```

### 2.2 Incident Response Implementation

```java
@Service
class IncidentResponseService {
    
    @Autowired
    private IncidentRepository incidentRepository;
    
    @Autowired
    private AlertService alertService;
    
    @Autowired
    private NotificationService notificationService;
    
    /**
     * Incident Detection and Creation
     */
    
    public Incident detectIncident(Alert alert) {
        // Check if this is a new incident or related to existing one
        Incident existing = findRelatedIncident(alert);
        
        if (existing != null) {
            // Add alert to existing incident
            existing.addAlert(alert);
            return incidentRepository.save(existing);
        }
        
        // Create new incident
        Incident incident = new Incident(
            generateIncidentId(),
            IncidentSeverity.fromAlert(alert),
            alert.getDescription(),
            Instant.now()
        );
        
        incident.addAlert(alert);
        incident.setStatus(IncidentStatus.DETECTED);
        
        // Assign incident commander
        incident.setCommander(assignIncidentCommander(incident));
        
        // Notify team
        notificationService.notifyIncidentTeam(incident);
        
        return incidentRepository.save(incident);
    }
    
    /**
     * Incident Triage
     */
    
    public void triageIncident(String incidentId, TriageInfo triageInfo) {
        Incident incident = incidentRepository.findById(incidentId)
            .orElseThrow(() -> new IncidentNotFoundException(incidentId));
        
        // Update severity if needed
        if (triageInfo.getSeverity() != null) {
            incident.setSeverity(triageInfo.getSeverity());
        }
        
        // Assign technical lead
        if (triageInfo.getTechnicalLead() != null) {
            incident.setTechnicalLead(triageInfo.getTechnicalLead());
        }
        
        // Add initial assessment
        incident.setInitialAssessment(triageInfo.getAssessment());
        
        incident.setStatus(IncidentStatus.TRIAGED);
        incidentRepository.save(incident);
        
        // Escalate if critical
        if (incident.getSeverity() == IncidentSeverity.CRITICAL) {
            escalateIncident(incident);
        }
    }
    
    /**
     * Incident Response
     */
    
    public void respondToIncident(String incidentId, ResponseAction action) {
        Incident incident = incidentRepository.findById(incidentId)
            .orElseThrow(() -> new IncidentNotFoundException(incidentId));
        
        // Record action
        incident.addAction(new IncidentAction(
            action.getType(),
            action.getDescription(),
            action.getPerformedBy(),
            Instant.now()
        ));
        
        incident.setStatus(IncidentStatus.IN_PROGRESS);
        incidentRepository.save(incident);
        
        // Update status page
        statusPageService.updateStatus(incident);
    }
    
    /**
     * Incident Resolution
     */
    
    public void resolveIncident(String incidentId, ResolutionInfo resolutionInfo) {
        Incident incident = incidentRepository.findById(incidentId)
            .orElseThrow(() -> new IncidentNotFoundException(incidentId));
        
        incident.setResolution(resolutionInfo.getDescription());
        incident.setRootCause(resolutionInfo.getRootCause());
        incident.setResolvedAt(Instant.now());
        incident.setStatus(IncidentStatus.RESOLVED);
        
        // Calculate metrics
        incident.setDuration(calculateDuration(incident));
        incident.setMttr(calculateMTTR(incident));
        
        incidentRepository.save(incident);
        
        // Notify stakeholders
        notificationService.notifyResolution(incident);
        
        // Update status page
        statusPageService.updateStatus(incident);
        
        // Schedule post-mortem
        schedulePostMortem(incident);
    }
}

enum IncidentStatus {
    DETECTED,
    TRIAGED,
    IN_PROGRESS,
    RESOLVED,
    CLOSED
}

enum IncidentSeverity {
    CRITICAL,    // Service completely down, all users affected
    HIGH,        // Major functionality broken, many users affected
    MEDIUM,      // Partial functionality broken, some users affected
    LOW          // Minor issue, few users affected
}

class Incident {
    private String id;
    private IncidentSeverity severity;
    private String description;
    private Instant detectedAt;
    private Instant resolvedAt;
    private Duration duration;
    private Duration mttr;
    private IncidentStatus status;
    private String commander;
    private String technicalLead;
    private List<Alert> alerts;
    private List<IncidentAction> actions;
    private String resolution;
    private String rootCause;
    private String initialAssessment;
    
    // Getters and setters
}
```

### 2.3 Incident Timeline

```java
@Service
class IncidentTimelineService {
    
    /**
     * Maintain detailed incident timeline
     */
    
    public void addTimelineEvent(String incidentId, TimelineEvent event) {
        Incident incident = incidentRepository.findById(incidentId)
            .orElseThrow(() -> new IncidentNotFoundException(incidentId));
        
        incident.addTimelineEvent(event);
        incidentRepository.save(incident);
    }
    
    public List<TimelineEvent> getTimeline(String incidentId) {
        Incident incident = incidentRepository.findById(incidentId)
            .orElseThrow(() -> new IncidentNotFoundException(incidentId));
        
        return incident.getTimelineEvents().stream()
            .sorted(Comparator.comparing(TimelineEvent::getTimestamp))
            .collect(Collectors.toList());
    }
}

class TimelineEvent {
    private Instant timestamp;
    private String eventType;
    private String description;
    private String performedBy;
    private Map<String, Object> metadata;
    
    // Constructor and getters
}
```

---

## 3. Incident Classification

### 3.1 Severity Levels

```java
class IncidentSeverityClassifier {
    
    /**
     * Severity Classification Criteria:
     * 
     * CRITICAL:
     * - Service completely unavailable
     * - All users affected
     * - Data loss or corruption
     * - Security breach
     * - RTO: < 15 minutes
     * 
     * HIGH:
     * - Major functionality broken
     * - Significant user impact (>50%)
     * - Performance degradation (>50%)
     * - RTO: < 1 hour
     * 
     * MEDIUM:
     * - Partial functionality broken
     * - Moderate user impact (10-50%)
     * - Performance degradation (20-50%)
     * - RTO: < 4 hours
     * 
     * LOW:
     * - Minor functionality issue
     * - Limited user impact (<10%)
     * - Minor performance impact (<20%)
     * - RTO: < 24 hours
     */
    
    public IncidentSeverity classifyIncident(IncidentMetrics metrics) {
        if (metrics.getAvailability() < 0.01 || // <1% availability
            metrics.getUserImpact() > 0.95 ||    // >95% users affected
            metrics.isDataLoss() ||
            metrics.isSecurityBreach()) {
            return IncidentSeverity.CRITICAL;
        }
        
        if (metrics.getAvailability() < 0.50 || // <50% availability
            metrics.getUserImpact() > 0.50) {    // >50% users affected
            return IncidentSeverity.HIGH;
        }
        
        if (metrics.getAvailability() < 0.90 || // <90% availability
            metrics.getUserImpact() > 0.10) {    // >10% users affected
            return IncidentSeverity.MEDIUM;
        }
        
        return IncidentSeverity.LOW;
    }
}

class IncidentMetrics {
    private double availability;      // 0.0 to 1.0
    private double userImpact;        // 0.0 to 1.0
    private double performanceDegradation; // 0.0 to 1.0
    private boolean dataLoss;
    private boolean securityBreach;
    
    // Getters and setters
}
```

### 3.2 Incident Categories

```java
enum IncidentCategory {
    INFRASTRUCTURE,    // Server, network, database failures
    APPLICATION,       // Code bugs, performance issues
    DEPENDENCY,       // Third-party service failures
    SECURITY,         // Security breaches, attacks
    DATA,             // Data loss, corruption
    CONFIGURATION,    // Configuration errors
    DEPLOYMENT,       // Deployment failures
    CAPACITY          // Resource exhaustion
}
```

---

## 4. Incident Response Tools

### 4.1 Incident Management System

```java
@RestController
@RequestMapping("/api/incidents")
class IncidentManagementController {
    
    @Autowired
    private IncidentResponseService incidentService;
    
    @PostMapping
    public ResponseEntity<Incident> createIncident(@RequestBody IncidentRequest request) {
        Incident incident = incidentService.createIncident(request);
        return ResponseEntity.ok(incident);
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<Incident> getIncident(@PathVariable String id) {
        Incident incident = incidentService.getIncident(id);
        return ResponseEntity.ok(incident);
    }
    
    @PutMapping("/{id}/triage")
    public ResponseEntity<Incident> triageIncident(
            @PathVariable String id,
            @RequestBody TriageInfo triageInfo) {
        incidentService.triageIncident(id, triageInfo);
        Incident incident = incidentService.getIncident(id);
        return ResponseEntity.ok(incident);
    }
    
    @PostMapping("/{id}/actions")
    public ResponseEntity<Incident> addAction(
            @PathVariable String id,
            @RequestBody ResponseAction action) {
        incidentService.respondToIncident(id, action);
        Incident incident = incidentService.getIncident(id);
        return ResponseEntity.ok(incident);
    }
    
    @PutMapping("/{id}/resolve")
    public ResponseEntity<Incident> resolveIncident(
            @PathVariable String id,
            @RequestBody ResolutionInfo resolutionInfo) {
        incidentService.resolveIncident(id, resolutionInfo);
        Incident incident = incidentService.getIncident(id);
        return ResponseEntity.ok(incident);
    }
    
    @GetMapping("/{id}/timeline")
    public ResponseEntity<List<TimelineEvent>> getTimeline(@PathVariable String id) {
        List<TimelineEvent> timeline = incidentService.getTimeline(id);
        return ResponseEntity.ok(timeline);
    }
}
```

### 4.2 On-Call Management

```java
@Service
class OnCallService {
    
    @Autowired
    private OnCallRepository onCallRepository;
    
    /**
     * On-Call Rotation Management
     */
    
    public OnCallSchedule createSchedule(OnCallRotation rotation) {
        OnCallSchedule schedule = new OnCallSchedule();
        
        // Create rotation schedule
        LocalDate startDate = rotation.getStartDate();
        int rotationDays = rotation.getRotationDays();
        List<String> engineers = rotation.getEngineers();
        
        int engineerIndex = 0;
        LocalDate currentDate = startDate;
        
        while (currentDate.isBefore(rotation.getEndDate())) {
            String engineer = engineers.get(engineerIndex % engineers.size());
            
            OnCallShift shift = new OnCallShift(
                engineer,
                currentDate,
                currentDate.plusDays(rotationDays)
            );
            
            schedule.addShift(shift);
            
            engineerIndex++;
            currentDate = currentDate.plusDays(rotationDays);
        }
        
        return onCallRepository.save(schedule);
    }
    
    public String getCurrentOnCallEngineer(String team) {
        OnCallSchedule schedule = onCallRepository.findByTeamAndDate(team, LocalDate.now());
        return schedule.getCurrentEngineer();
    }
    
    public void escalateIncident(String incidentId) {
        Incident incident = incidentService.getIncident(incidentId);
        String onCallEngineer = getCurrentOnCallEngineer(incident.getTeam());
        
        // Notify on-call engineer
        notificationService.notifyOnCallEngineer(onCallEngineer, incident);
    }
}
```

---

## 5. Post-Mortem Analysis

### 5.1 Post-Mortem Process

```java
/**
 * Post-Mortem Process:
 * 
 * 1. Schedule (within 48 hours):
 *    - While incident is fresh
 *    - All participants available
 * 
 * 2. Prepare:
 *    - Gather timeline
 *    - Collect metrics
 *    - Review logs
 * 
 * 3. Conduct:
 *    - Blameless culture
 *    - Focus on process
 *    - Identify root cause
 * 
 * 4. Document:
 *    - Timeline
 *    - Root cause
 *    - Action items
 * 
 * 5. Follow-up:
 *    - Track action items
 *    - Verify fixes
 *    - Share learnings
 */
```

### 5.2 Post-Mortem Template

```java
@Service
class PostMortemService {
    
    @Autowired
    private IncidentRepository incidentRepository;
    
    @Autowired
    private PostMortemRepository postMortemRepository;
    
    /**
     * Create Post-Mortem Document
     */
    
    public PostMortem createPostMortem(String incidentId) {
        Incident incident = incidentRepository.findById(incidentId)
            .orElseThrow(() -> new IncidentNotFoundException(incidentId));
        
        PostMortem postMortem = new PostMortem();
        postMortem.setIncidentId(incidentId);
        postMortem.setTitle("Post-Mortem: " + incident.getDescription());
        postMortem.setIncidentDate(incident.getDetectedAt());
        postMortem.setResolvedDate(incident.getResolvedAt());
        postMortem.setDuration(incident.getDuration());
        
        // Executive Summary
        postMortem.setExecutiveSummary(createExecutiveSummary(incident));
        
        // Impact
        postMortem.setImpact(assessImpact(incident));
        
        // Timeline
        postMortem.setTimeline(incident.getTimelineEvents());
        
        // Root Cause
        postMortem.setRootCause(analyzeRootCause(incident));
        
        // Contributing Factors
        postMortem.setContributingFactors(identifyContributingFactors(incident));
        
        // Action Items
        postMortem.setActionItems(createActionItems(incident));
        
        // Lessons Learned
        postMortem.setLessonsLearned(extractLessons(incident));
        
        return postMortemRepository.save(postMortem);
    }
    
    private String createExecutiveSummary(Incident incident) {
        return String.format(
            "On %s, %s occurred affecting %s users for %s. " +
            "The incident was resolved in %s. Root cause: %s",
            formatDate(incident.getDetectedAt()),
            incident.getDescription(),
            estimateUserImpact(incident),
            formatDuration(incident.getDuration()),
            formatDuration(incident.getMttr()),
            incident.getRootCause()
        );
    }
    
    private Impact assessImpact(Incident incident) {
        return new Impact(
            estimateUserImpact(incident),
            calculateRevenueImpact(incident),
            assessReputationImpact(incident),
            identifyAffectedSystems(incident)
        );
    }
    
    private RootCause analyzeRootCause(Incident incident) {
        // Use 5 Whys technique
        return performFiveWhys(incident);
    }
    
    private List<ContributingFactor> identifyContributingFactors(Incident incident) {
        List<ContributingFactor> factors = new ArrayList<>();
        
        // Check monitoring gaps
        if (wasMonitoringInadequate(incident)) {
            factors.add(new ContributingFactor(
                "Monitoring",
                "Inadequate monitoring prevented early detection"
            ));
        }
        
        // Check alerting gaps
        if (wasAlertingInadequate(incident)) {
            factors.add(new ContributingFactor(
                "Alerting",
                "Missing or delayed alerts"
            ));
        }
        
        // Check documentation
        if (wasDocumentationMissing(incident)) {
            factors.add(new ContributingFactor(
                "Documentation",
                "Missing runbooks or procedures"
            ));
        }
        
        return factors;
    }
    
    private List<ActionItem> createActionItems(Incident incident) {
        List<ActionItem> items = new ArrayList<>();
        
        // Immediate actions (P0)
        items.addAll(createImmediateActions(incident));
        
        // Short-term actions (P1)
        items.addAll(createShortTermActions(incident));
        
        // Long-term actions (P2)
        items.addAll(createLongTermActions(incident));
        
        return items;
    }
    
    private RootCause performFiveWhys(Incident incident) {
        // Why 1: What happened?
        String why1 = incident.getDescription();
        
        // Why 2: Why did it happen?
        String why2 = identifyImmediateCause(incident);
        
        // Why 3: Why did that happen?
        String why3 = identifyUnderlyingCause(why2);
        
        // Why 4: Why did that happen?
        String why4 = identifySystemicCause(why3);
        
        // Why 5: Why did that happen?
        String why5 = identifyRootCause(why4);
        
        return new RootCause(why1, why2, why3, why4, why5);
    }
}

class PostMortem {
    private String id;
    private String incidentId;
    private String title;
    private Instant incidentDate;
    private Instant resolvedDate;
    private Duration duration;
    private String executiveSummary;
    private Impact impact;
    private List<TimelineEvent> timeline;
    private RootCause rootCause;
    private List<ContributingFactor> contributingFactors;
    private List<ActionItem> actionItems;
    private List<String> lessonsLearned;
    
    // Getters and setters
}

class ActionItem {
    private String id;
    private String description;
    private Priority priority;
    private String owner;
    private LocalDate dueDate;
    private ActionItemStatus status;
    private String notes;
    
    // Getters and setters
}

enum Priority {
    P0,  // Critical, immediate
    P1,  // High, within 1 week
    P2   // Medium, within 1 month
}

enum ActionItemStatus {
    OPEN,
    IN_PROGRESS,
    COMPLETED,
    BLOCKED
}
```

---

## 6. Reliability Metrics and SLIs/SLOs

### 6.1 Service Level Indicators (SLIs)

```java
/**
 * Common SLIs:
 * 
 * 1. Availability:
 *    SLI = (Successful requests / Total requests) × 100%
 * 
 * 2. Latency:
 *    SLI = Percentage of requests below threshold
 *    e.g., 95% of requests < 200ms
 * 
 * 3. Error Rate:
 *    SLI = (Error requests / Total requests) × 100%
 * 
 * 4. Throughput:
 *    SLI = Requests per second
 */
```

### 6.2 Service Level Objectives (SLOs)

```java
@Service
class SLOService {
    
    /**
     * Define SLOs for services
     */
    
    public SLO defineSLO(String serviceName, SLIConfig config) {
        SLO slo = new SLO();
        slo.setServiceName(serviceName);
        slo.setSli(config.getSli());
        slo.setTarget(config.getTarget());
        slo.setWindow(config.getWindow());
        
        return sloRepository.save(slo);
    }
    
    /**
     * Example SLOs:
     * 
     * Availability: 99.9% over 30 days
     * Latency: 95% of requests < 200ms
     * Error Rate: < 0.1% over 30 days
     */
    
    public void defineDefaultSLOs() {
        // Availability SLO
        defineSLO("user-service", new SLIConfig(
            SLI.AVAILABILITY,
            0.999,  // 99.9%
            Duration.ofDays(30)
        ));
        
        // Latency SLO
        defineSLO("user-service", new SLIConfig(
            SLI.LATENCY_P95,
            Duration.ofMillis(200),
            Duration.ofDays(30)
        ));
        
        // Error Rate SLO
        defineSLO("user-service", new SLIConfig(
            SLI.ERROR_RATE,
            0.001,  // 0.1%
            Duration.ofDays(30)
        ));
    }
    
    /**
     * Calculate SLO Compliance
     */
    
    public SLOCompliance calculateCompliance(String serviceName, Duration window) {
        SLO slo = sloRepository.findByServiceName(serviceName);
        SLIMetrics metrics = metricsService.getSLIMetrics(serviceName, window);
        
        boolean compliant = isCompliant(slo, metrics);
        double compliancePercentage = calculateCompliancePercentage(slo, metrics);
        
        return new SLOCompliance(
            serviceName,
            slo,
            metrics,
            compliant,
            compliancePercentage
        );
    }
}

enum SLI {
    AVAILABILITY,
    LATENCY_P50,
    LATENCY_P95,
    LATENCY_P99,
    ERROR_RATE,
    THROUGHPUT
}

class SLO {
    private String serviceName;
    private SLI sli;
    private double target;
    private Duration window;
    
    // Getters and setters
}
```

### 6.3 Error Budget

```java
/**
 * Error Budget:
 * 
 * Error Budget = 100% - SLO Target
 * 
 * Example:
 * - SLO: 99.9% availability
 * - Error Budget: 0.1% (43.2 minutes per month)
 * 
 * Use error budget for:
 * - Feature releases
 * - Experiments
 * - Risk-taking
 */
```

---

## 7. Continuous Improvement

### 7.1 Improvement Process

```java
@Service
class ContinuousImprovementService {
    
    /**
     * Continuous Improvement Cycle:
     * 
     * 1. Measure:
     *    - Track metrics
     *    - Monitor SLIs
     *    - Collect feedback
     * 
     * 2. Analyze:
     *    - Identify trends
     *    - Find patterns
     *    - Root cause analysis
     * 
     * 3. Improve:
     *    - Implement fixes
     *    - Enhance processes
     *    - Update procedures
     * 
     * 4. Verify:
     *    - Measure improvement
     *    - Validate fixes
     *    - Confirm effectiveness
     */
    
    public ImprovementPlan createImprovementPlan(List<PostMortem> postMortems) {
        ImprovementPlan plan = new ImprovementPlan();
        
        // Analyze patterns across incidents
        Map<String, Integer> commonRootCauses = analyzeCommonRootCauses(postMortems);
        Map<String, Integer> commonContributingFactors = analyzeContributingFactors(postMortems);
        
        // Identify improvement opportunities
        List<ImprovementOpportunity> opportunities = identifyOpportunities(
            commonRootCauses,
            commonContributingFactors
        );
        
        // Prioritize improvements
        List<Improvement> improvements = prioritizeImprovements(opportunities);
        
        plan.setImprovements(improvements);
        return plan;
    }
    
    private Map<String, Integer> analyzeCommonRootCauses(List<PostMortem> postMortems) {
        return postMortems.stream()
            .map(PostMortem::getRootCause)
            .map(RootCause::getFinalCause)
            .collect(Collectors.groupingBy(
                Function.identity(),
                Collectors.counting()
            ))
            .entrySet().stream()
            .collect(Collectors.toMap(
                Map.Entry::getKey,
                e -> e.getValue().intValue()
            ));
    }
    
    public void trackActionItems() {
        List<ActionItem> openItems = actionItemRepository.findByStatus(
            ActionItemStatus.OPEN, ActionItemStatus.IN_PROGRESS
        );
        
        for (ActionItem item : openItems) {
            if (item.getDueDate().isBefore(LocalDate.now())) {
                // Escalate overdue items
                escalateOverdueActionItem(item);
            }
        }
    }
}
```

### 7.2 Reliability Dashboard

```java
@RestController
@RequestMapping("/api/reliability")
class ReliabilityDashboardController {
    
    @Autowired
    private ReliabilityMetricsService metricsService;
    
    @GetMapping("/dashboard")
    public ResponseEntity<ReliabilityDashboard> getDashboard(
            @RequestParam(required = false) Duration window) {
        if (window == null) {
            window = Duration.ofDays(30);
        }
        
        ReliabilityDashboard dashboard = new ReliabilityDashboard();
        
        // Overall availability
        dashboard.setAvailability(metricsService.getOverallAvailability(window));
        
        // MTTR trends
        dashboard.setMttrTrend(metricsService.getMTTRTrend(window));
        
        // Incident frequency
        dashboard.setIncidentFrequency(metricsService.getIncidentFrequency(window));
        
        // SLO compliance
        dashboard.setSloCompliance(metricsService.getSLOCompliance(window));
        
        // Error budget
        dashboard.setErrorBudget(metricsService.getErrorBudget(window));
        
        // Top incidents
        dashboard.setTopIncidents(metricsService.getTopIncidents(window, 10));
        
        return ResponseEntity.ok(dashboard);
    }
}
```

---

## 8. Practical Examples

### 8.1 Complete Incident Response System

```java
@SpringBootApplication
public class IncidentResponseApplication {
    public static void main(String[] args) {
        SpringApplication.run(IncidentResponseApplication.class, args);
    }
}

@Configuration
class IncidentResponseConfig {
    
    @Bean
    public IncidentResponseService incidentResponseService() {
        return new IncidentResponseService();
    }
    
    @Bean
    public PostMortemService postMortemService() {
        return new PostMortemService();
    }
    
    @Bean
    public OnCallService onCallService() {
        return new OnCallService();
    }
    
    @Bean
    public SLOService sloService() {
        return new SLOService();
    }
}

@RestController
@RequestMapping("/api/post-mortems")
class PostMortemController {
    
    @Autowired
    private PostMortemService postMortemService;
    
    @PostMapping("/{incidentId}")
    public ResponseEntity<PostMortem> createPostMortem(@PathVariable String incidentId) {
        PostMortem postMortem = postMortemService.createPostMortem(incidentId);
        return ResponseEntity.ok(postMortem);
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<PostMortem> getPostMortem(@PathVariable String id) {
        PostMortem postMortem = postMortemService.getPostMortem(id);
        return ResponseEntity.ok(postMortem);
    }
    
    @PutMapping("/{id}/action-items/{actionItemId}")
    public ResponseEntity<ActionItem> updateActionItem(
            @PathVariable String id,
            @PathVariable String actionItemId,
            @RequestBody ActionItemUpdate update) {
        ActionItem item = postMortemService.updateActionItem(id, actionItemId, update);
        return ResponseEntity.ok(item);
    }
}
```

---

## Summary: Part 4

### Key Takeaways

1. **Incident Response**: Structured process for handling incidents
2. **Post-Mortems**: Blameless analysis and learning
3. **SLIs/SLOs**: Define and measure reliability
4. **Continuous Improvement**: Learn from incidents and improve

### Complete Mastery Checklist

**Risk Management**:
- ✅ Risk identification and assessment
- ✅ Risk mitigation strategies
- ✅ Risk monitoring and review

**Disaster Recovery**:
- ✅ RTO/RPO planning
- ✅ Backup and recovery strategies
- ✅ Multi-region deployment

**Reliability Patterns**:
- ✅ Circuit breakers
- ✅ Retries with backoff
- ✅ Graceful degradation

**Chaos Engineering**:
- ✅ Failure injection
- ✅ Chaos experiments
- ✅ Resilience testing

**Incident Response**:
- ✅ Incident detection and triage
- ✅ Response procedures
- ✅ Post-mortem analysis

**Continuous Improvement**:
- ✅ Metrics and SLIs/SLOs
- ✅ Action item tracking
- ✅ Process improvement

---

**Master risk management and reliability engineering to build truly resilient systems!**

**Impact**: Reduces downtime from days to hours, saves $100K+ per hour of downtime, improves system reliability by 60%.

