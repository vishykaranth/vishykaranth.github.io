# Cost Optimization and Resource Management: Master Guide for Principal Engineers

## Part 2: Resource Right-Sizing and Capacity Planning

---

## Table of Contents

1. [Resource Right-Sizing Deep Dive](#1-resource-right-sizing-deep-dive)
2. [Capacity Planning Strategies](#2-capacity-planning-strategies)
3. [Auto-Scaling Optimization](#3-auto-scaling-optimization)
4. [Resource Lifecycle Management](#4-resource-lifecycle-management)
5. [Practical Examples](#5-practical-examples)

---

## 1. Resource Right-Sizing Deep Dive

### 1.1 Right-Sizing Methodology

**The Right-Sizing Process**:
```java
/**
 * Right-Sizing Process:
 * 
 * 1. Data Collection (2-4 weeks):
 *    - Collect utilization metrics
 *    - CPU, Memory, Network, I/O
 *    - Peak and average usage
 *    - Growth trends
 * 
 * 2. Analysis:
 *    - Identify over-provisioned resources
 *    - Identify under-provisioned resources
 *    - Calculate waste
 *    - Estimate savings
 * 
 * 3. Recommendations:
 *    - Instance type changes
 *    - Storage optimizations
 *    - Network optimizations
 * 
 * 4. Implementation:
 *    - Test in non-production
 *    - Gradual rollout
 *    - Monitor impact
 * 
 * 5. Validation:
 *    - Verify performance
 *    - Confirm savings
 *    - Document results
 */
```

### 1.2 EC2 Right-Sizing Analysis

**Comprehensive EC2 Analysis**:
```java
@Service
class EC2RightSizingAnalyzer {
    
    /**
     * EC2 Right-Sizing Analysis:
     * 
     * Metrics to Analyze:
     * 1. CPU Utilization (target: 40-70%)
 *   2. Memory Utilization (target: 60-80%)
 *   3. Network Utilization
 *   4. EBS I/O
 *   5. Burst Credits (for T instances)
     */
    
    public RightSizingReport analyzeEC2Instance(String instanceId, int days) {
        // Collect metrics
        MetricData cpuMetrics = getCloudWatchMetrics(instanceId, "CPUUtilization", days);
        MetricData memoryMetrics = getCloudWatchMetrics(instanceId, "MemoryUtilization", days);
        MetricData networkIn = getCloudWatchMetrics(instanceId, "NetworkIn", days);
        MetricData networkOut = getCloudWatchMetrics(instanceId, "NetworkOut", days);
        
        // Calculate statistics
        Statistics stats = calculateStatistics(cpuMetrics, memoryMetrics, networkIn, networkOut);
        
        // Get current instance details
        InstanceDetails current = getInstanceDetails(instanceId);
        
        // Generate recommendations
        List<Recommendation> recommendations = generateRecommendations(stats, current);
        
        // Calculate potential savings
        double monthlySavings = calculateSavings(recommendations);
        
        return RightSizingReport.builder()
            .instanceId(instanceId)
            .currentInstanceType(current.getInstanceType())
            .analysisPeriod(days)
            .statistics(stats)
            .recommendations(recommendations)
            .estimatedMonthlySavings(monthlySavings)
            .riskLevel(assessRisk(recommendations))
            .build();
    }
    
    private List<Recommendation> generateRecommendations(Statistics stats, InstanceDetails current) {
        List<Recommendation> recommendations = new ArrayList<>();
        
        // CPU Analysis
        if (stats.getAvgCpuUtil() < 20 && stats.getMaxCpuUtil() < 40) {
            // Over-provisioned CPU
            String smallerInstance = findSmallerInstanceType(current.getInstanceType(), "CPU");
            recommendations.add(Recommendation.builder()
                .type("DOWN_SIZE")
                .current(current.getInstanceType())
                .recommended(smallerInstance)
                .reason("CPU utilization consistently below 20%")
                .estimatedSavings(calculateInstanceCostDifference(current.getInstanceType(), smallerInstance))
                .risk("LOW")
                .build());
        } else if (stats.getAvgCpuUtil() > 80 || stats.getMaxCpuUtil() > 95) {
            // Under-provisioned CPU
            String largerInstance = findLargerInstanceType(current.getInstanceType(), "CPU");
            recommendations.add(Recommendation.builder()
                .type("UP_SIZE")
                .current(current.getInstanceType())
                .recommended(largerInstance)
                .reason("CPU utilization consistently above 80%")
                .estimatedSavings(0) // No savings, but better performance
                .risk("MEDIUM")
                .build());
        }
        
        // Memory Analysis
        if (stats.getAvgMemoryUtil() < 30 && stats.getMaxMemoryUtil() < 50) {
            // Over-provisioned Memory
            String smallerInstance = findSmallerInstanceType(current.getInstanceType(), "MEMORY");
            recommendations.add(Recommendation.builder()
                .type("DOWN_SIZE")
                .current(current.getInstanceType())
                .recommended(smallerInstance)
                .reason("Memory utilization consistently below 30%")
                .estimatedSavings(calculateInstanceCostDifference(current.getInstanceType(), smallerInstance))
                .risk("LOW")
                .build());
        } else if (stats.getAvgMemoryUtil() > 90 || stats.getMaxMemoryUtil() > 95) {
            // Under-provisioned Memory
            String largerInstance = findLargerInstanceType(current.getInstanceType(), "MEMORY");
            recommendations.add(Recommendation.builder()
                .type("UP_SIZE")
                .current(current.getInstanceType())
                .recommended(largerInstance)
                .reason("Memory utilization consistently above 90%")
                .estimatedSavings(0)
                .risk("HIGH") // Risk of OOM errors
                .build());
        }
        
        // Network Analysis
        if (stats.getAvgNetworkUtil() < 10) {
            // Low network usage - might not need enhanced networking
            recommendations.add(Recommendation.builder()
                .type("NETWORK_OPTIMIZATION")
                .reason("Low network utilization - consider standard networking")
                .estimatedSavings(calculateNetworkSavings(current))
                .risk("LOW")
                .build());
        }
        
        return recommendations;
    }
    
    private double calculateSavings(List<Recommendation> recommendations) {
        return recommendations.stream()
            .mapToDouble(Recommendation::getEstimatedSavings)
            .sum();
    }
}
```

### 1.3 RDS Right-Sizing

**RDS Right-Sizing Analysis**:
```java
@Service
class RDSRightSizingAnalyzer {
    
    /**
     * RDS Right-Sizing Considerations:
     * 
     * 1. Instance Type:
     *    - CPU utilization
     *    - Memory utilization
     *    - I/O performance
     * 
     * 2. Storage:
     *    - Storage size
     *    - IOPS (if provisioned)
     *    - Storage type (gp2, gp3, io1)
     * 
     * 3. Multi-AZ:
     *    - Only for production
     *    - Consider read replicas instead
     * 
     * 4. Engine Optimization:
     *    - Parameter tuning
     *    - Connection pooling
     */
    
    public RDSRightSizingReport analyzeRDS(String dbInstanceId, int days) {
        // Get RDS metrics
        MetricData cpuMetrics = getRDSMetrics(dbInstanceId, "CPUUtilization", days);
        MetricData memoryMetrics = getRDSMetrics(dbInstanceId, "FreeableMemory", days);
        MetricData readIOPS = getRDSMetrics(dbInstanceId, "ReadIOPS", days);
        MetricData writeIOPS = getRDSMetrics(dbInstanceId, "WriteIOPS", days);
        MetricData storageSize = getRDSMetrics(dbInstanceId, "FreeStorageSpace", days);
        
        // Get current configuration
        RDSInstanceDetails current = getRDSInstanceDetails(dbInstanceId);
        
        // Analyze
        List<RDSRecommendation> recommendations = new ArrayList<>();
        
        // Instance Type Analysis
        if (cpuMetrics.getAverage() < 30 && memoryMetrics.getAverage() > current.getTotalMemory() * 0.6) {
            // Over-provisioned
            String smallerInstance = findSmallerRDSInstance(current.getInstanceClass());
            recommendations.add(RDSRecommendation.builder()
                .type("INSTANCE_DOWN_SIZE")
                .current(current.getInstanceClass())
                .recommended(smallerInstance)
                .estimatedSavings(calculateRDSInstanceSavings(current.getInstanceClass(), smallerInstance))
                .build());
        }
        
        // Storage Analysis
        double avgFreeStorage = storageSize.getAverage();
        double totalStorage = current.getAllocatedStorage();
        double utilizationPercent = ((totalStorage - avgFreeStorage) / totalStorage) * 100;
        
        if (utilizationPercent < 50) {
            // Over-provisioned storage
            int recommendedStorage = (int) (totalStorage * 0.7); // 30% headroom
            recommendations.add(RDSRecommendation.builder()
                .type("STORAGE_DOWN_SIZE")
                .current(totalStorage)
                .recommended(recommendedStorage)
                .estimatedSavings(calculateStorageSavings(totalStorage, recommendedStorage))
                .build());
        }
        
        // IOPS Analysis (for provisioned IOPS)
        if (current.getStorageType().equals("io1")) {
            int provisionedIOPS = current.getIops();
            double avgIOPS = (readIOPS.getAverage() + writeIOPS.getAverage());
            
            if (avgIOPS < provisionedIOPS * 0.3) {
                // Over-provisioned IOPS
                int recommendedIOPS = (int) (avgIOPS * 1.5); // 50% headroom
                recommendations.add(RDSRecommendation.builder()
                    .type("IOPS_REDUCE")
                    .current(provisionedIOPS)
                    .recommended(recommendedIOPS)
                    .estimatedSavings(calculateIOPSSavings(provisionedIOPS, recommendedIOPS))
                    .build());
            }
        }
        
        return RDSRightSizingReport.builder()
            .dbInstanceId(dbInstanceId)
            .currentConfiguration(current)
            .recommendations(recommendations)
            .estimatedMonthlySavings(calculateTotalSavings(recommendations))
            .build();
    }
}
```

### 1.4 Container Right-Sizing

**Kubernetes Resource Optimization**:
```java
@Service
class KubernetesRightSizingAnalyzer {
    
    /**
     * Kubernetes Right-Sizing:
     * 
     * 1. Resource Requests:
     *    - CPU requests (guaranteed)
     *    - Memory requests (guaranteed)
     * 
     * 2. Resource Limits:
     *    - CPU limits (maximum)
     *    - Memory limits (maximum)
     * 
     * 3. Analysis:
     *    - Actual usage vs requests
     *    - Actual usage vs limits
     *    - Waste calculation
     */
    
    public K8sRightSizingReport analyzePod(String namespace, String podName, int days) {
        // Get metrics from Prometheus/Metrics Server
        PodMetrics metrics = getPodMetrics(namespace, podName, days);
        PodSpec spec = getPodSpec(namespace, podName);
        
        // Calculate utilization
        double cpuRequest = spec.getCpuRequest();
        double cpuLimit = spec.getCpuLimit();
        double cpuUsage = metrics.getAverageCpuUsage();
        
        double memoryRequest = spec.getMemoryRequest();
        double memoryLimit = spec.getMemoryLimit();
        double memoryUsage = metrics.getAverageMemoryUsage();
        
        List<K8sRecommendation> recommendations = new ArrayList<>();
        
        // CPU Analysis
        if (cpuUsage < cpuRequest * 0.5) {
            // Over-provisioned CPU request
            double recommendedRequest = cpuUsage * 1.2; // 20% headroom
            recommendations.add(K8sRecommendation.builder()
                .type("CPU_REQUEST_REDUCE")
                .resource("CPU")
                .current(String.valueOf(cpuRequest))
                .recommended(String.valueOf(recommendedRequest))
                .wastePercent((cpuRequest - cpuUsage) / cpuRequest * 100)
                .build());
        }
        
        if (cpuLimit > cpuUsage * 2) {
            // Over-provisioned CPU limit
            double recommendedLimit = cpuUsage * 1.5; // 50% headroom
            recommendations.add(K8sRecommendation.builder()
                .type("CPU_LIMIT_REDUCE")
                .resource("CPU")
                .current(String.valueOf(cpuLimit))
                .recommended(String.valueOf(recommendedLimit))
                .build());
        }
        
        // Memory Analysis
        if (memoryUsage < memoryRequest * 0.5) {
            // Over-provisioned memory request
            double recommendedRequest = memoryUsage * 1.2; // 20% headroom
            recommendations.add(K8sRecommendation.builder()
                .type("MEMORY_REQUEST_REDUCE")
                .resource("MEMORY")
                .current(String.valueOf(memoryRequest))
                .recommended(String.valueOf(recommendedRequest))
                .wastePercent((memoryRequest - memoryUsage) / memoryRequest * 100)
                .build());
        }
        
        return K8sRightSizingReport.builder()
            .namespace(namespace)
            .podName(podName)
            .currentSpec(spec)
            .actualUsage(metrics)
            .recommendations(recommendations)
            .estimatedSavings(calculateK8sSavings(recommendations))
            .build();
    }
}
```

---

## 2. Capacity Planning Strategies

### 2.1 Capacity Planning Framework

**Capacity Planning Process**:
```java
/**
 * Capacity Planning Framework:
 * 
 * 1. Current State Analysis:
 *    - Current capacity
 *    - Current utilization
 *    - Current costs
 * 
 * 2. Demand Forecasting:
 *    - Historical growth trends
 *    - Business projections
 *    - Seasonal patterns
 *    - Marketing campaigns
 * 
 * 3. Capacity Requirements:
 *    - Peak capacity needs
 *    - Average capacity needs
 *    - Growth projections
 * 
 * 4. Resource Planning:
 *    - Compute resources
 *    - Storage resources
 *    - Network resources
 *    - Database resources
 * 
 * 5. Cost Projections:
 *    - Current costs
 *    - Projected costs
 *    - Optimization opportunities
 * 
 * 6. Implementation Plan:
 *    - Phased approach
 *    - Risk mitigation
 *    - Monitoring strategy
 */
```

### 2.2 Demand Forecasting

**Forecasting Models**:
```java
@Service
class CapacityForecaster {
    
    /**
     * Demand Forecasting Methods:
     * 
     * 1. Linear Regression:
     *    - Simple trend analysis
     *    - Good for steady growth
     * 
     * 2. Time Series Analysis:
     *    - ARIMA models
     *    - Seasonal patterns
     *    - Trend + seasonality
     * 
     * 3. Machine Learning:
     *    - More complex patterns
     *    - Multiple factors
     *    - Better accuracy
     */
    
    public CapacityForecast forecastDemand(String resourceType, int months) {
        // Get historical data
        List<HistoricalDataPoint> historicalData = getHistoricalData(resourceType, 12); // 12 months
        
        // Calculate growth rate
        double growthRate = calculateGrowthRate(historicalData);
        
        // Identify seasonal patterns
        Map<Integer, Double> seasonalFactors = identifySeasonalPatterns(historicalData);
        
        // Forecast
        List<ForecastDataPoint> forecast = new ArrayList<>();
        double currentValue = historicalData.get(historicalData.size() - 1).getValue();
        
        for (int month = 1; month <= months; month++) {
            // Apply growth rate
            double baseForecast = currentValue * Math.pow(1 + growthRate, month);
            
            // Apply seasonal factor
            int seasonMonth = (month % 12);
            double seasonalFactor = seasonalFactors.getOrDefault(seasonMonth, 1.0);
            double forecastValue = baseForecast * seasonalFactor;
            
            // Add buffer (20% headroom)
            double forecastWithBuffer = forecastValue * 1.2;
            
            forecast.add(ForecastDataPoint.builder()
                .month(month)
                .forecastedValue(forecastValue)
                .forecastedWithBuffer(forecastWithBuffer)
                .confidenceInterval(calculateConfidenceInterval(forecastValue, historicalData))
                .build());
        }
        
        return CapacityForecast.builder()
            .resourceType(resourceType)
            .forecastPeriod(months)
            .currentValue(currentValue)
            .growthRate(growthRate)
            .forecast(forecast)
            .build();
    }
    
    private double calculateGrowthRate(List<HistoricalDataPoint> data) {
        if (data.size() < 2) return 0;
        
        double firstValue = data.get(0).getValue();
        double lastValue = data.get(data.size() - 1).getValue();
        
        // Compound annual growth rate
        return Math.pow(lastValue / firstValue, 1.0 / (data.size() - 1)) - 1;
    }
}
```

### 2.3 Capacity Planning for Different Workloads

**Steady-State Workloads**:
```java
@Service
class SteadyStateCapacityPlanner {
    
    /**
     * Steady-State Workload Planning:
     * 
     * Characteristics:
     * - Predictable demand
     * - Consistent utilization
     * - Long-term commitment viable
     * 
     * Strategy:
     * - Purchase Reserved Instances
     * - Right-size for average load
     * - Minimal auto-scaling
     */
    
    public CapacityPlan planSteadyState(WorkloadProfile profile) {
        // Calculate average capacity needed
        double avgCapacity = profile.getAverageDemand();
        
        // Add 20% buffer
        double plannedCapacity = avgCapacity * 1.2;
        
        // Recommend Reserved Instances
        ReservedInstanceRecommendation riRecommendation = ReservedInstanceRecommendation.builder()
            .instanceType(determineInstanceType(plannedCapacity))
            .term("3-year")
            .paymentOption("All Upfront") // Best savings
            .estimatedSavings(calculateRISavings(plannedCapacity, "3-year", "All Upfront"))
            .build();
        
        return CapacityPlan.builder()
            .workloadType("STEADY_STATE")
            .plannedCapacity(plannedCapacity)
            .recommendations(Arrays.asList(riRecommendation))
            .estimatedMonthlyCost(calculateMonthlyCost(plannedCapacity, riRecommendation))
            .build();
    }
}
```

**Variable Workloads**:
```java
@Service
class VariableWorkloadCapacityPlanner {
    
    /**
     * Variable Workload Planning:
     * 
     * Characteristics:
     * - Unpredictable demand
     * - High variance
     * - Peak vs average ratio > 3:1
     * 
     * Strategy:
     * - Auto-scaling
     * - On-demand instances
     * - Spot instances for non-critical
     * - Savings Plans (flexible)
     */
    
    public CapacityPlan planVariable(WorkloadProfile profile) {
        double avgCapacity = profile.getAverageDemand();
        double peakCapacity = profile.getPeakDemand();
        double peakToAvgRatio = peakCapacity / avgCapacity;
        
        // Base capacity (on-demand)
        double baseCapacity = avgCapacity * 1.1; // 10% above average
        
        // Peak capacity (auto-scaled)
        double maxCapacity = peakCapacity * 1.2; // 20% above peak
        
        // Use Savings Plans for base capacity
        SavingsPlanRecommendation spRecommendation = SavingsPlanRecommendation.builder()
            .commitment("1-year")
            .commitmentAmount(baseCapacity)
            .estimatedSavings(calculateSavingsPlanSavings(baseCapacity))
            .build();
        
        // Auto-scaling configuration
        AutoScalingConfig autoScaling = AutoScalingConfig.builder()
            .minInstances((int) baseCapacity)
            .maxInstances((int) maxCapacity)
            .targetUtilization(70)
            .scaleUpCooldown(60) // 1 minute
            .scaleDownCooldown(300) // 5 minutes
            .build();
        
        return CapacityPlan.builder()
            .workloadType("VARIABLE")
            .baseCapacity(baseCapacity)
            .maxCapacity(maxCapacity)
            .autoScalingConfig(autoScaling)
            .recommendations(Arrays.asList(spRecommendation))
            .estimatedMonthlyCost(calculateVariableWorkloadCost(baseCapacity, maxCapacity, spRecommendation))
            .build();
    }
}
```

**Batch Workloads**:
```java
@Service
class BatchWorkloadCapacityPlanner {
    
    /**
     * Batch Workload Planning:
     * 
     * Characteristics:
     * - Scheduled execution
     * - Can tolerate interruptions
     * - High compute, short duration
     * 
     * Strategy:
     * - Spot instances (90% savings)
     * - Preemptible VMs
     * - Auto-scaling for batch jobs
     */
    
    public CapacityPlan planBatch(BatchWorkloadProfile profile) {
        // Use Spot instances for maximum savings
        SpotInstanceConfig spotConfig = SpotInstanceConfig.builder()
            .instanceTypes(Arrays.asList("m5.large", "m5.xlarge", "c5.large"))
            .maxPrice(profile.getMaxBidPrice())
            .interruptionHandling("CHECKPOINT_AND_RESTART")
            .build();
        
        // Auto-scaling for batch queue
        AutoScalingConfig autoScaling = AutoScalingConfig.builder()
            .minInstances(0) // Scale to zero when no jobs
            .maxInstances(profile.getMaxConcurrentJobs())
            .targetMetric("QUEUE_DEPTH")
            .targetValue(10) // Scale when queue > 10
            .build();
        
        return CapacityPlan.builder()
            .workloadType("BATCH")
            .spotInstanceConfig(spotConfig)
            .autoScalingConfig(autoScaling)
            .estimatedMonthlyCost(calculateBatchCost(profile, spotConfig))
            .estimatedSavings(calculateSpotSavings(profile))
            .build();
    }
}
```

### 2.4 Capacity Planning Tools

**Capacity Planning Dashboard**:
```java
@Service
class CapacityPlanningDashboard {
    
    public CapacityPlanningReport generateReport() {
        // Current capacity
        CurrentCapacity current = analyzeCurrentCapacity();
        
        // Forecasts
        CapacityForecast computeForecast = forecaster.forecastDemand("COMPUTE", 12);
        CapacityForecast storageForecast = forecaster.forecastDemand("STORAGE", 12);
        CapacityForecast networkForecast = forecaster.forecastDemand("NETWORK", 12);
        
        // Recommendations
        List<CapacityRecommendation> recommendations = generateRecommendations(
            current, computeForecast, storageForecast, networkForecast);
        
        // Cost projections
        CostProjection costProjection = projectCosts(current, 
            computeForecast, storageForecast, networkForecast);
        
        return CapacityPlanningReport.builder()
            .currentCapacity(current)
            .forecasts(CapacityForecasts.builder()
                .compute(computeForecast)
                .storage(storageForecast)
                .network(networkForecast)
                .build())
            .recommendations(recommendations)
            .costProjection(costProjection)
            .build();
    }
}
```

---

## 3. Auto-Scaling Optimization

### 3.1 Auto-Scaling Strategy

**Auto-Scaling Best Practices**:
```java
/**
 * Auto-Scaling Optimization:
 * 
 * 1. Metrics Selection:
 *    - CPU utilization (40-70% target)
 *    - Memory utilization (60-80% target)
 *    - Request rate
 *    - Queue depth
 *    - Custom metrics
 * 
 * 2. Scaling Policies:
 *    - Target tracking (recommended)
 *    - Step scaling
 *    - Scheduled scaling
 * 
 * 3. Cooldown Periods:
 *    - Scale-up: Short (1-2 min)
 *    - Scale-down: Longer (5-10 min)
 * 
 * 4. Instance Distribution:
 *    - Multiple availability zones
 *    - Even distribution
 *    - Health checks
 */
```

### 3.2 AWS Auto Scaling Configuration

```java
@Configuration
class OptimizedAutoScalingConfig {
    
    /**
     * Optimized Auto-Scaling Configuration:
     * 
     * 1. Target Tracking:
     *    - Maintain CPU at 50%
 *    - Maintain memory at 70%
 *    - Scale based on request rate
     * 
     * 2. Predictive Scaling:
     *    - ML-based forecasting
     *    - Pre-scale before demand
     * 
     * 3. Scheduled Scaling:
     *    - Known patterns
     *    - Business hours
     */
    
    @Bean
    public AutoScalingGroupConfig optimizedAutoScaling() {
        return AutoScalingGroupConfig.builder()
            .minSize(2) // Minimum for HA
            .maxSize(20) // Maximum capacity
            .desiredCapacity(4) // Initial capacity
            .healthCheckType("ELB")
            .healthCheckGracePeriod(300) // 5 minutes
            .targetGroupARNs(Arrays.asList("arn:aws:elasticloadbalancing:..."))
            .scalingPolicies(Arrays.asList(
                // Target tracking - CPU
                ScalingPolicy.builder()
                    .policyType("TargetTrackingScaling")
                    .targetTrackingConfiguration(TargetTrackingConfiguration.builder()
                        .predefinedMetricSpecification(PredefinedMetricSpecification.builder()
                            .predefinedMetricType("ASGAverageCPUUtilization")
                            .build())
                        .targetValue(50.0) // Target 50% CPU
                        .scaleInCooldown(300) // 5 min scale-in cooldown
                        .scaleOutCooldown(60) // 1 min scale-out cooldown
                        .build())
                    .build(),
                
                // Target tracking - Request rate
                ScalingPolicy.builder()
                    .policyType("TargetTrackingScaling")
                    .targetTrackingConfiguration(TargetTrackingConfiguration.builder()
                        .customizedMetricSpecification(CustomizedMetricSpecification.builder()
                            .metricName("RequestCountPerTarget")
                            .namespace("AWS/ApplicationELB")
                            .statistic("Average")
                            .build())
                        .targetValue(1000.0) // 1000 requests per target
                        .build())
                    .build()
            ))
            .build();
    }
}
```

### 3.3 Kubernetes HPA Optimization

```yaml
# Optimized HPA Configuration
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: optimized-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: my-app
  minReplicas: 3
  maxReplicas: 20
  metrics:
  # CPU metric
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  # Memory metric
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  # Custom metric - request rate
  - type: Pods
    pods:
      metric:
        name: requests_per_second
      target:
        type: AverageValue
        averageValue: "100"
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300  # 5 min stabilization
      policies:
      - type: Percent
        value: 50  # Scale down by 50%
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 0  # Scale up immediately
      policies:
      - type: Percent
        value: 100  # Double capacity
        periodSeconds: 60
      - type: Pods
        value: 4  # Or add 4 pods
        periodSeconds: 60
      selectPolicy: Max  # Use most aggressive policy
```

---

## 4. Resource Lifecycle Management

### 4.1 Resource Cleanup Strategy

**Orphaned Resource Detection**:
```java
@Service
class ResourceLifecycleManager {
    
    /**
     * Resource Lifecycle Management:
     * 
     * 1. Orphaned Resources:
     *    - Unattached EBS volumes
     *    - Unused Elastic IPs
     *    - Unused load balancers
     *    - Unused security groups
     * 
     * 2. Idle Resources:
     *    - Stopped instances
     *    - Unused snapshots
     *    - Old AMIs
     * 
     * 3. Old Resources:
     *    - Unused S3 objects
     *    - Old database snapshots
     *    - Expired certificates
     */
    
    public ResourceCleanupReport identifyOrphanedResources() {
        List<OrphanedResource> orphaned = new ArrayList<>();
        
        // Unattached EBS volumes
        List<Volume> unattachedVolumes = findUnattachedVolumes();
        orphaned.addAll(unattachedVolumes.stream()
            .map(v -> OrphanedResource.builder()
                .type("EBS_VOLUME")
                .id(v.getVolumeId())
                .monthlyCost(calculateVolumeCost(v))
                .build())
            .collect(Collectors.toList()));
        
        // Unused Elastic IPs
        List<ElasticIP> unusedIPs = findUnusedElasticIPs();
        orphaned.addAll(unusedIPs.stream()
            .map(ip -> OrphanedResource.builder()
                .type("ELASTIC_IP")
                .id(ip.getAllocationId())
                .monthlyCost(0.005 * 24 * 30) // $0.005/hour
                .build())
            .collect(Collectors.toList()));
        
        // Unused load balancers
        List<LoadBalancer> unusedLBs = findUnusedLoadBalancers();
        orphaned.addAll(unusedLBs.stream()
            .map(lb -> OrphanedResource.builder()
                .type("LOAD_BALANCER")
                .id(lb.getLoadBalancerArn())
                .monthlyCost(calculateLoadBalancerCost(lb))
                .build())
            .collect(Collectors.toList()));
        
        double totalSavings = orphaned.stream()
            .mapToDouble(OrphanedResource::getMonthlyCost)
            .sum();
        
        return ResourceCleanupReport.builder()
            .orphanedResources(orphaned)
            .totalMonthlySavings(totalSavings)
            .build();
    }
}
```

### 4.2 Automated Cleanup

```java
@Service
class AutomatedResourceCleanup {
    
    @Scheduled(cron = "0 0 2 * * ?") // Daily at 2 AM
    public void performDailyCleanup() {
        // 1. Clean up old snapshots (> 30 days)
        cleanupOldSnapshots(30);
        
        // 2. Clean up unattached volumes (> 7 days)
        cleanupUnattachedVolumes(7);
        
        // 3. Clean up unused Elastic IPs (> 1 day)
        cleanupUnusedElasticIPs(1);
        
        // 4. Clean up stopped instances (> 14 days)
        cleanupStoppedInstances(14);
    }
    
    @Scheduled(cron = "0 0 3 * * 0") // Weekly on Sunday at 3 AM
    public void performWeeklyCleanup() {
        // 1. Clean up old AMIs (> 90 days, not in use)
        cleanupOldAMIs(90);
        
        // 2. Clean up unused security groups
        cleanupUnusedSecurityGroups();
        
        // 3. Clean up unused load balancers
        cleanupUnusedLoadBalancers();
    }
    
    private void cleanupOldSnapshots(int daysOld) {
        List<Snapshot> oldSnapshots = findSnapshotsOlderThan(daysOld);
        
        for (Snapshot snapshot : oldSnapshots) {
            // Check if snapshot is still needed
            if (!isSnapshotNeeded(snapshot)) {
                logger.info("Deleting old snapshot: {}", snapshot.getSnapshotId());
                deleteSnapshot(snapshot.getSnapshotId());
            }
        }
    }
}
```

---

## 5. Practical Examples

### 5.1 Complete Right-Sizing Case Study

**Scenario**: 100 EC2 instances, $50k/month spend

**Analysis Results**:
```java
RightSizingReport report = analyzer.analyzeAllInstances();

// Results:
// - 30 instances over-provisioned (can downsize)
// - 5 instances under-provisioned (need upsize)
// - 65 instances properly sized

// Savings:
// - Downsizing: $8k/month
// - Total: $8k/month = $96k/year
```

**Implementation Plan**:
```java
ImplementationPlan plan = ImplementationPlan.builder()
    .phase1("Test downsizing in dev environment")
    .phase2("Downsize 10 instances in staging")
    .phase3("Monitor for 1 week")
    .phase4("Downsize remaining 20 instances in production")
    .estimatedSavings(8000) // $8k/month
    .riskMitigation("Keep original AMIs for 30 days")
    .build();
```

---

## Summary: Part 2

### Key Concepts

1. **Right-Sizing**: Match resources to actual needs
2. **Capacity Planning**: Forecast and plan for future needs
3. **Auto-Scaling**: Optimize scaling policies
4. **Resource Lifecycle**: Clean up unused resources

### Next Steps

**Part 3** will cover:
- Cost-Benefit Analysis
- Technical Investment Optimization
- ROI Calculations
- Budget Management

---

**Master right-sizing and capacity planning to optimize costs effectively!**

