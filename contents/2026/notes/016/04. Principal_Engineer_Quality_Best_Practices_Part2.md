# Principal Engineer: Mastering Quality and Best Practices Enforcement

## Part 2: Design Patterns and Anti-Patterns

---

## Table of Contents

1. [Design Patterns Overview](#1-design-patterns-overview)
2. [Essential Design Patterns](#2-essential-design-patterns)
3. [Anti-Patterns to Avoid](#3-anti-patterns-to-avoid)
4. [Pattern Selection Guide](#4-pattern-selection-guide)
5. [Pattern Enforcement](#5-pattern-enforcement)
6. [Practical Examples](#6-practical-examples)

---

## 1. Design Patterns Overview

### 1.1 Why Design Patterns Matter

**Benefits**:
- **Consistency**: Common solutions to common problems
- **Maintainability**: Easier to understand and modify
- **Communication**: Shared vocabulary
- **Best Practices**: Proven solutions
- **Quality**: Reduces technical debt

### 1.2 Pattern Categories

```java
/**
 * Design Pattern Categories:
 * 
 * 1. Creational Patterns:
 *    - Singleton, Factory, Builder
 *    - Object creation
 * 
 * 2. Structural Patterns:
 *    - Adapter, Decorator, Facade
 *    - Object composition
 * 
 * 3. Behavioral Patterns:
 *    - Strategy, Observer, Command
 *    - Object interaction
 * 
 * 4. Architectural Patterns:
 *    - MVC, Repository, Service Layer
 *    - System structure
 */
```

---

## 2. Essential Design Patterns

### 2.1 Repository Pattern

**Purpose**: Abstract data access layer

**Implementation**:
```java
// Interface
interface UserRepository {
    Optional<User> findById(String id);
    List<User> findAll();
    User save(User user);
    void deleteById(String id);
}

// Implementation
@Repository
class JpaUserRepository implements UserRepository {
    
    @Autowired
    private EntityManager entityManager;
    
    @Override
    public Optional<User> findById(String id) {
        return Optional.ofNullable(
            entityManager.find(User.class, id));
    }
    
    @Override
    public List<User> findAll() {
        return entityManager.createQuery(
            "SELECT u FROM User u", User.class)
            .getResultList();
    }
    
    @Override
    public User save(User user) {
        if (user.getId() == null) {
            entityManager.persist(user);
        } else {
            user = entityManager.merge(user);
        }
        return user;
    }
    
    @Override
    public void deleteById(String id) {
        User user = entityManager.find(User.class, id);
        if (user != null) {
            entityManager.remove(user);
        }
    }
}

// Service uses repository
@Service
class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public User getUser(String id) {
        return userRepository.findById(id)
            .orElseThrow(() -> new UserNotFoundException(id));
    }
}
```

**Benefits**:
- Testability (easy to mock)
- Flexibility (switch implementations)
- Separation of concerns

### 2.2 Service Layer Pattern

**Purpose**: Encapsulate business logic

**Implementation**:
```java
@Service
@Transactional
class OrderService {
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private PaymentService paymentService;
    
    @Autowired
    private InventoryService inventoryService;
    
    @Autowired
    private NotificationService notificationService;
    
    public Order createOrder(OrderRequest request) {
        // 1. Validate
        validateOrderRequest(request);
        
        // 2. Check inventory
        if (!inventoryService.isAvailable(request.getItems())) {
            throw new InsufficientInventoryException();
        }
        
        // 3. Create order
        Order order = new Order(request);
        order = orderRepository.save(order);
        
        // 4. Process payment
        PaymentResult payment = paymentService.processPayment(
            order.getId(), request.getPaymentInfo());
        
        if (!payment.isSuccess()) {
            order.setStatus(OrderStatus.PAYMENT_FAILED);
            orderRepository.save(order);
            throw new PaymentFailedException();
        }
        
        // 5. Update inventory
        inventoryService.reserveItems(order.getItems());
        
        // 6. Send notification
        notificationService.sendOrderConfirmation(order);
        
        order.setStatus(OrderStatus.CONFIRMED);
        return orderRepository.save(order);
    }
    
    private void validateOrderRequest(OrderRequest request) {
        if (request.getItems().isEmpty()) {
            throw new IllegalArgumentException("Order must have items");
        }
        if (request.getPaymentInfo() == null) {
            throw new IllegalArgumentException("Payment info required");
        }
    }
}
```

**Benefits**:
- Centralized business logic
- Transaction management
- Reusability

### 2.3 Strategy Pattern

**Purpose**: Encapsulate algorithms

**Implementation**:
```java
// Strategy interface
interface PaymentStrategy {
    PaymentResult processPayment(double amount, PaymentInfo info);
}

// Concrete strategies
@Component
class CreditCardPaymentStrategy implements PaymentStrategy {
    
    @Override
    public PaymentResult processPayment(double amount, PaymentInfo info) {
        // Credit card processing logic
        return new PaymentResult(true, "Payment processed via credit card");
    }
}

@Component
class PayPalPaymentStrategy implements PaymentStrategy {
    
    @Override
    public PaymentResult processPayment(double amount, PaymentInfo info) {
        // PayPal processing logic
        return new PaymentResult(true, "Payment processed via PayPal");
    }
}

@Component
class BankTransferPaymentStrategy implements PaymentStrategy {
    
    @Override
    public PaymentResult processPayment(double amount, PaymentInfo info) {
        // Bank transfer logic
        return new PaymentResult(true, "Payment processed via bank transfer");
    }
}

// Context
@Service
class PaymentService {
    
    private final Map<PaymentType, PaymentStrategy> strategies;
    
    public PaymentService(List<PaymentStrategy> strategyList) {
        this.strategies = strategyList.stream()
            .collect(Collectors.toMap(
                this::getPaymentType,
                Function.identity()
            ));
    }
    
    public PaymentResult processPayment(PaymentType type, double amount, PaymentInfo info) {
        PaymentStrategy strategy = strategies.get(type);
        if (strategy == null) {
            throw new UnsupportedPaymentTypeException(type);
        }
        return strategy.processPayment(amount, info);
    }
    
    private PaymentType getPaymentType(PaymentStrategy strategy) {
        if (strategy instanceof CreditCardPaymentStrategy) {
            return PaymentType.CREDIT_CARD;
        } else if (strategy instanceof PayPalPaymentStrategy) {
            return PaymentType.PAYPAL;
        } else if (strategy instanceof BankTransferPaymentStrategy) {
            return PaymentType.BANK_TRANSFER;
        }
        throw new IllegalArgumentException("Unknown strategy type");
    }
}
```

**Benefits**:
- Open/Closed Principle
- Easy to add new strategies
- Testable

### 2.4 Factory Pattern

**Purpose**: Create objects without specifying exact class

**Implementation**:
```java
// Product interface
interface Notification {
    void send(String recipient, String message);
}

// Concrete products
class EmailNotification implements Notification {
    @Override
    public void send(String recipient, String message) {
        System.out.println("Sending email to " + recipient + ": " + message);
    }
}

class SMSNotification implements Notification {
    @Override
    public void send(String recipient, String message) {
        System.out.println("Sending SMS to " + recipient + ": " + message);
    }
}

class PushNotification implements Notification {
    @Override
    public void send(String recipient, String message) {
        System.out.println("Sending push to " + recipient + ": " + message);
    }
}

// Factory
class NotificationFactory {
    
    public static Notification create(NotificationType type) {
        switch (type) {
            case EMAIL:
                return new EmailNotification();
            case SMS:
                return new SMSNotification();
            case PUSH:
                return new PushNotification();
            default:
                throw new IllegalArgumentException("Unknown notification type: " + type);
        }
    }
}

// Usage
@Service
class NotificationService {
    
    public void sendNotification(NotificationType type, String recipient, String message) {
        Notification notification = NotificationFactory.create(type);
        notification.send(recipient, message);
    }
}
```

### 2.5 Builder Pattern

**Purpose**: Construct complex objects step by step

**Implementation**:
```java
class User {
    private String id;
    private String firstName;
    private String lastName;
    private String email;
    private String phone;
    private Address address;
    private List<String> roles;
    
    private User(Builder builder) {
        this.id = builder.id;
        this.firstName = builder.firstName;
        this.lastName = builder.lastName;
        this.email = builder.email;
        this.phone = builder.phone;
        this.address = builder.address;
        this.roles = builder.roles;
    }
    
    public static Builder builder() {
        return new Builder();
    }
    
    static class Builder {
        private String id;
        private String firstName;
        private String lastName;
        private String email;
        private String phone;
        private Address address;
        private List<String> roles = new ArrayList<>();
        
        public Builder id(String id) {
            this.id = id;
            return this;
        }
        
        public Builder firstName(String firstName) {
            this.firstName = firstName;
            return this;
        }
        
        public Builder lastName(String lastName) {
            this.lastName = lastName;
            return this;
        }
        
        public Builder email(String email) {
            this.email = email;
            return this;
        }
        
        public Builder phone(String phone) {
            this.phone = phone;
            return this;
        }
        
        public Builder address(Address address) {
            this.address = address;
            return this;
        }
        
        public Builder role(String role) {
            this.roles.add(role);
            return this;
        }
        
        public User build() {
            validate();
            return new User(this);
        }
        
        private void validate() {
            if (email == null || !email.contains("@")) {
                throw new IllegalArgumentException("Valid email required");
            }
        }
    }
}

// Usage
User user = User.builder()
    .id("123")
    .firstName("John")
    .lastName("Doe")
    .email("john@example.com")
    .phone("123-456-7890")
    .address(address)
    .role("USER")
    .role("ADMIN")
    .build();
```

---

## 3. Anti-Patterns to Avoid

### 3.1 God Object / God Class

**Anti-Pattern**:
```java
// BAD: God class - does everything
class UserService {
    public void createUser() { }
    public void updateUser() { }
    public void deleteUser() { }
    public void sendEmail() { }           // Wrong responsibility
    public void processPayment() { }      // Wrong responsibility
    public void generateReport() { }      // Wrong responsibility
    public void validateOrder() { }        // Wrong responsibility
    public void calculateTax() { }         // Wrong responsibility
    // 50+ methods doing unrelated things
}
```

**Solution**:
```java
// GOOD: Single responsibility
class UserService {
    public void createUser() { }
    public void updateUser() { }
    public void deleteUser() { }
}

class EmailService {
    public void sendEmail() { }
}

class PaymentService {
    public void processPayment() { }
}

class ReportService {
    public void generateReport() { }
}

class OrderService {
    public void validateOrder() { }
}

class TaxService {
    public void calculateTax() { }
}
```

### 3.2 Anemic Domain Model

**Anti-Pattern**:
```java
// BAD: Anemic model - only getters/setters
class User {
    private String id;
    private String name;
    private String email;
    private String status;
    
    // Only getters and setters
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    // ... more getters/setters
}

// Business logic in service
class UserService {
    public void activateUser(User user) {
        user.setStatus("ACTIVE");  // Logic outside domain
    }
    
    public void deactivateUser(User user) {
        user.setStatus("INACTIVE");  // Logic outside domain
    }
}
```

**Solution**:
```java
// GOOD: Rich domain model
class User {
    private String id;
    private String name;
    private String email;
    private UserStatus status;
    
    public void activate() {
        if (this.status == UserStatus.SUSPENDED) {
            throw new IllegalStateException("Cannot activate suspended user");
        }
        this.status = UserStatus.ACTIVE;
        // Domain logic encapsulated
    }
    
    public void deactivate() {
        this.status = UserStatus.INACTIVE;
    }
    
    public void changeEmail(String newEmail) {
        validateEmail(newEmail);
        this.email = newEmail;
        // Trigger domain event if needed
    }
    
    private void validateEmail(String email) {
        if (email == null || !email.contains("@")) {
            throw new IllegalArgumentException("Invalid email");
        }
    }
}
```

### 3.3 Spaghetti Code

**Anti-Pattern**:
```java
// BAD: Everything mixed together
class EverythingService {
    public void doEverything(String input) {
        // Database code
        Connection conn = DriverManager.getConnection(...);
        PreparedStatement stmt = conn.prepareStatement(...);
        ResultSet rs = stmt.executeQuery();
        
        // Business logic
        while (rs.next()) {
            String data = rs.getString("data");
            if (data != null && data.length() > 10) {
                data = data.toUpperCase();
                // More mixed logic
            }
        }
        
        // UI code
        System.out.println("Result: " + data);
        
        // File I/O
        FileWriter writer = new FileWriter("output.txt");
        writer.write(data);
    }
}
```

**Solution**:
```java
// GOOD: Separation of concerns
@Repository
class DataRepository {
    public List<String> getData() {
        // Only data access
    }
}

@Service
class BusinessService {
    @Autowired
    private DataRepository repository;
    
    public String processData() {
        // Only business logic
        List<String> data = repository.getData();
        return data.stream()
            .filter(d -> d != null && d.length() > 10)
            .map(String::toUpperCase)
            .collect(Collectors.joining());
    }
}

@Controller
class DataController {
    @Autowired
    private BusinessService service;
    
    @GetMapping("/data")
    public ResponseEntity<String> getData() {
        // Only presentation
        return ResponseEntity.ok(service.processData());
    }
}
```

### 3.4 Magic Numbers and Strings

**Anti-Pattern**:
```java
// BAD: Magic numbers and strings
public void processOrder(Order order) {
    if (order.getStatus().equals("PENDING")) {  // Magic string
        if (order.getTotal() > 1000) {          // Magic number
            order.setDiscount(0.1);              // Magic number
        } else if (order.getTotal() > 500) {    // Magic number
            order.setDiscount(0.05);              // Magic number
        }
        order.setStatus("PROCESSED");            // Magic string
    }
}
```

**Solution**:
```java
// GOOD: Constants
class OrderConstants {
    public static final String STATUS_PENDING = "PENDING";
    public static final String STATUS_PROCESSED = "PROCESSED";
    
    public static final double HIGH_ORDER_THRESHOLD = 1000.0;
    public static final double MEDIUM_ORDER_THRESHOLD = 500.0;
    
    public static final double HIGH_ORDER_DISCOUNT = 0.1;
    public static final double MEDIUM_ORDER_DISCOUNT = 0.05;
}

// Or use enums
enum OrderStatus {
    PENDING, PROCESSED, CANCELLED
}

class DiscountCalculator {
    private static final double HIGH_THRESHOLD = 1000.0;
    private static final double MEDIUM_THRESHOLD = 500.0;
    private static final double HIGH_DISCOUNT = 0.1;
    private static final double MEDIUM_DISCOUNT = 0.05;
    
    public double calculateDiscount(double total) {
        if (total > HIGH_THRESHOLD) {
            return HIGH_DISCOUNT;
        } else if (total > MEDIUM_THRESHOLD) {
            return MEDIUM_DISCOUNT;
        }
        return 0.0;
    }
}

// Usage
public void processOrder(Order order) {
    if (order.getStatus() == OrderStatus.PENDING) {
        double discount = discountCalculator.calculateDiscount(order.getTotal());
        order.setDiscount(discount);
        order.setStatus(OrderStatus.PROCESSED);
    }
}
```

### 3.5 Copy-Paste Programming

**Anti-Pattern**:
```java
// BAD: Duplicated code
class UserService {
    public void createUser(User user) {
        if (user.getName() == null || user.getName().isEmpty()) {
            throw new IllegalArgumentException("Name required");
        }
        if (user.getEmail() == null || !user.getEmail().contains("@")) {
            throw new IllegalArgumentException("Valid email required");
        }
        userRepository.save(user);
    }
    
    public void updateUser(User user) {
        if (user.getName() == null || user.getName().isEmpty()) {
            throw new IllegalArgumentException("Name required");
        }
        if (user.getEmail() == null || !user.getEmail().contains("@")) {
            throw new IllegalArgumentException("Valid email required");
        }
        userRepository.save(user);
    }
}
```

**Solution**:
```java
// GOOD: DRY (Don't Repeat Yourself)
class UserService {
    
    public void createUser(User user) {
        validateUser(user);
        userRepository.save(user);
    }
    
    public void updateUser(User user) {
        validateUser(user);
        userRepository.save(user);
    }
    
    private void validateUser(User user) {
        if (user.getName() == null || user.getName().isEmpty()) {
            throw new IllegalArgumentException("Name required");
        }
        if (user.getEmail() == null || !user.getEmail().contains("@")) {
            throw new IllegalArgumentException("Valid email required");
        }
    }
}
```

### 3.6 Premature Optimization

**Anti-Pattern**:
```java
// BAD: Optimizing before measuring
class PrematureOptimization {
    // Using complex data structures when simple would work
    private Map<String, ConcurrentHashMap<String, AtomicInteger>> complexStructure;
    
    public void add(String key, String subKey) {
        // Complex logic for simple operation
        complexStructure.computeIfAbsent(key, k -> new ConcurrentHashMap<>())
            .computeIfAbsent(subKey, k -> new AtomicInteger(0))
            .incrementAndGet();
    }
}
```

**Solution**:
```java
// GOOD: Start simple, optimize when needed
class SimpleFirst {
    private Map<String, Integer> simpleStructure = new HashMap<>();
    
    public void add(String key) {
        simpleStructure.merge(key, 1, Integer::sum);
    }
    
    // Optimize only if profiling shows it's needed
}
```

---

## 4. Pattern Selection Guide

### 4.1 Decision Tree

```java
/**
 * Pattern Selection Decision Tree:
 * 
 * Need to create objects?
 * ├─ Need single instance? → Singleton
 * ├─ Complex construction? → Builder
 * ├─ Create without specifying class? → Factory
 * └─ Create families? → Abstract Factory
 * 
 * Need to structure objects?
 * ├─ Make incompatible work? → Adapter
 * ├─ Add responsibilities? → Decorator
 * ├─ Simplify interface? → Facade
 * └─ Control access? → Proxy
 * 
 * Need to handle behavior?
 * ├─ Interchangeable algorithms? → Strategy
 * ├─ Notify multiple objects? → Observer
 * ├─ Encapsulate requests? → Command
 * └─ Chain of handlers? → Chain of Responsibility
 * 
 * Need data access?
 * └─ Abstract data access? → Repository
 * 
 * Need business logic?
 * └─ Encapsulate logic? → Service Layer
 */
```

### 4.2 When NOT to Use Patterns

```java
/**
 * Don't Use Patterns When:
 * 
 * 1. Problem is simple:
 *    - Simple problem doesn't need complex solution
 *    - Over-engineering
 * 
 * 2. Premature optimization:
 *    - Don't add pattern "just in case"
 *    - Add when actually needed
 * 
 * 3. Team doesn't understand:
 *    - Pattern adds complexity
 *    - Team must understand to maintain
 * 
 * 4. Pattern doesn't fit:
 *    - Don't force pattern
 *    - Use appropriate solution
 */
```

---

## 5. Pattern Enforcement

### 5.1 Code Review Checklist

```java
/**
 * Pattern Enforcement Checklist:
 * 
 * Code Review:
 * □ Follows established patterns
 * □ No anti-patterns
 * □ Consistent with codebase
 * □ Appropriate pattern usage
 * 
 * Architecture Review:
 * □ Service layer pattern used
 * □ Repository pattern for data access
 * □ Strategy pattern for algorithms
 * □ Factory for object creation
 * 
 * Anti-Pattern Check:
 * □ No God classes
 * □ No anemic models
 * □ No spaghetti code
 * □ No magic numbers/strings
 * □ No copy-paste code
 */
```

### 5.2 Automated Pattern Detection

**SonarQube Rules**:
```java
/**
 * SonarQube Pattern Rules:
 * 
 * 1. God Class Detection:
 *    - Classes with > 500 lines
 *    - Classes with > 20 methods
 * 
 * 2. Anemic Model Detection:
 *    - Classes with only getters/setters
 *    - No business logic
 * 
 * 3. Duplication Detection:
 *    - > 3% duplication
 * 
 * 4. Complexity Detection:
 *    - Cyclomatic complexity > 10
 */
```

---

## 6. Practical Examples

### 6.1 Refactoring Anti-Pattern to Pattern

**Before (Anti-Pattern)**:
```java
// God class with everything
class OrderProcessor {
    public void process(Order order) {
        // Database access
        Connection conn = getConnection();
        PreparedStatement stmt = conn.prepareStatement("SELECT * FROM orders WHERE id = ?");
        stmt.setString(1, order.getId());
        ResultSet rs = stmt.executeQuery();
        
        // Business logic
        if (rs.next()) {
            double total = rs.getDouble("total");
            if (total > 1000) {
                total = total * 0.9;  // Magic number
            }
            
            // Update
            PreparedStatement update = conn.prepareStatement("UPDATE orders SET total = ? WHERE id = ?");
            update.setDouble(1, total);
            update.setString(2, order.getId());
            update.executeUpdate();
        }
        
        // Notification
        System.out.println("Order processed: " + order.getId());
    }
}
```

**After (Using Patterns)**:
```java
// Repository pattern
@Repository
class OrderRepository {
    public Optional<Order> findById(String id) {
        // JPA or proper data access
    }
    
    public Order save(Order order) {
        // Save logic
    }
}

// Service layer pattern
@Service
class OrderService {
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private DiscountCalculator discountCalculator;
    
    @Autowired
    private NotificationService notificationService;
    
    public void process(Order order) {
        Order existingOrder = orderRepository.findById(order.getId())
            .orElseThrow(() -> new OrderNotFoundException(order.getId()));
        
        double discount = discountCalculator.calculateDiscount(existingOrder.getTotal());
        existingOrder.applyDiscount(discount);
        
        orderRepository.save(existingOrder);
        notificationService.notifyOrderProcessed(existingOrder);
    }
}

// Strategy pattern for discount
class DiscountCalculator {
    private final List<DiscountStrategy> strategies;
    
    public double calculateDiscount(double total) {
        return strategies.stream()
            .filter(s -> s.isApplicable(total))
            .map(s -> s.calculate(total))
            .reduce(0.0, Double::sum);
    }
}
```

---

## Summary: Part 2

### Key Takeaways

1. **Design Patterns**: Proven solutions to common problems
2. **Anti-Patterns**: Common mistakes to avoid
3. **Pattern Selection**: Choose appropriate pattern
4. **Enforcement**: Code review and automated checks

### Next Steps

**Part 3** will cover:
- Testing Strategies (Unit, Integration, E2E)
- Test coverage and quality
- Test-driven development
- Testing best practices

---

**Master design patterns and avoid anti-patterns for maintainable code!**

