# Risk Management and Reliability Engineering: Master Guide for Principal Engineers

## Part 1: Risk Assessment and Mitigation Strategies

---

## Table of Contents

1. [Understanding Risk Management](#1-understanding-risk-management)
2. [Risk Identification](#2-risk-identification)
3. [Risk Assessment and Analysis](#3-risk-assessment-and-analysis)
4. [Risk Mitigation Strategies](#4-risk-mitigation-strategies)
5. [Risk Monitoring and Review](#5-risk-monitoring-and-review)
6. [Practical Examples](#6-practical-examples)

---

## 1. Understanding Risk Management

### 1.1 What is Risk Management?

**Risk Management** is the process of identifying, assessing, and mitigating risks that could impact system reliability, availability, and business continuity.

### 1.2 Types of Technical Risks

```java
/**
 * Technical Risk Categories:
 * 
 * 1. Infrastructure Risks:
 *    - Server failures
 *    - Network outages
 *    - Data center failures
 *    - Cloud provider outages
 * 
 * 2. Application Risks:
 *    - Code bugs
 *    - Performance degradation
 *    - Security vulnerabilities
 *    - Integration failures
 * 
 * 3. Data Risks:
 *    - Data loss
 *    - Data corruption
 *    - Data breaches
 *    - Backup failures
 * 
 * 4. Dependency Risks:
 *    - Third-party service failures
 *    - Library vulnerabilities
 *    - API changes
 *    - Vendor lock-in
 * 
 * 5. Operational Risks:
 *    - Human errors
 *    - Configuration mistakes
 *    - Deployment failures
 *    - Monitoring gaps
 */
```

### 1.3 Risk Management Framework

```java
/**
 * Risk Management Lifecycle:
 * 
 * 1. Identify Risks
 *    - Brainstorming sessions
 *    - Architecture reviews
 *    - Historical incident analysis
 *    - Threat modeling
 * 
 * 2. Assess Risks
 *    - Probability (Likelihood)
 *    - Impact (Severity)
 *    - Risk Score = Probability × Impact
 * 
 * 3. Mitigate Risks
 *    - Avoid (eliminate risk)
 *    - Reduce (lower probability/impact)
 *    - Transfer (insurance, contracts)
 *    - Accept (monitor and prepare)
 * 
 * 4. Monitor Risks
 *    - Continuous monitoring
 *    - Regular reviews
 *    - Metrics tracking
 *    - Alerting
 * 
 * 5. Respond to Risks
 *    - Incident response
 *    - Disaster recovery
 *    - Post-mortem analysis
 */
```

---

## 2. Risk Identification

### 2.1 Risk Identification Techniques

**1. Architecture Risk Analysis (ARA)**
```java
/**
 * Architecture Risk Analysis Process:
 * 
 * 1. Document Architecture:
 *    - System components
 *    - Data flows
 *    - Dependencies
 *    - Integration points
 * 
 * 2. Identify Single Points of Failure:
 *    - Components without redundancy
 *    - Critical dependencies
 *    - Shared resources
 * 
 * 3. Analyze Failure Modes:
 *    - What can go wrong?
 *    - How can it fail?
 *    - What are the consequences?
 */
```

**Example: Risk Identification for E-Commerce Platform**
```java
class ArchitectureRiskAnalysis {
    
    /**
     * E-Commerce Platform Risk Analysis:
     * 
     * Components:
     * 1. Load Balancer
     * 2. Application Servers (3 instances)
     * 3. Database (Primary + 2 Replicas)
     * 4. Redis Cache (Single instance)
     * 5. Payment Gateway (External)
     * 6. Email Service (External)
     * 
     * Identified Risks:
     */
    
    public List<Risk> identifyRisks() {
        List<Risk> risks = new ArrayList<>();
        
        // Risk 1: Single Redis instance (SPOF)
        risks.add(new Risk(
            "Redis Cache Failure",
            "Single Redis instance without replication",
            RiskCategory.INFRASTRUCTURE,
            "Cache failure causes all requests to hit database",
            "High"
        ));
        
        // Risk 2: External payment gateway dependency
        risks.add(new Risk(
            "Payment Gateway Outage",
            "External payment service unavailable",
            RiskCategory.DEPENDENCY,
            "Cannot process payments, revenue loss",
            "Critical"
        ));
        
        // Risk 3: Database primary failure
        risks.add(new Risk(
            "Database Primary Failure",
            "Primary database crashes",
            RiskCategory.INFRASTRUCTURE,
            "Write operations fail, read replicas may have stale data",
            "Critical"
        ));
        
        // Risk 4: No circuit breaker for external services
        risks.add(new Risk(
            "Cascading Failure",
            "No circuit breaker for external services",
            RiskCategory.APPLICATION,
            "External service failure cascades to application",
            "High"
        ));
        
        return risks;
    }
}
```

**2. Threat Modeling**
```java
/**
 * STRIDE Threat Model:
 * 
 * S - Spoofing: Impersonating users or systems
 * T - Tampering: Unauthorized modification of data
 * R - Repudiation: Denying actions
 * I - Information Disclosure: Data leaks
 * D - Denial of Service: System unavailability
 * E - Elevation of Privilege: Unauthorized access
 */
```

**Example: Threat Modeling**
```java
class ThreatModeling {
    
    public List<Threat> identifyThreats(SystemComponent component) {
        List<Threat> threats = new ArrayList<>();
        
        // Example: API Gateway Component
        if (component.getName().equals("API Gateway")) {
            // Spoofing
            threats.add(new Threat(
                "Spoofing",
                "Attacker impersonates legitimate user",
                "Use JWT tokens, API keys, OAuth 2.0"
            ));
            
            // Tampering
            threats.add(new Threat(
                "Tampering",
                "Request/response modification",
                "Use HTTPS, request signing, input validation"
            ));
            
            // Denial of Service
            threats.add(new Threat(
                "DoS",
                "Overwhelm API gateway with requests",
                "Rate limiting, DDoS protection, auto-scaling"
            ));
            
            // Information Disclosure
            threats.add(new Threat(
                "Information Disclosure",
                "Sensitive data in logs/responses",
                "Data masking, encryption, secure logging"
            ));
        }
        
        return threats;
    }
}
```

**3. Failure Mode and Effects Analysis (FMEA)**
```java
class FMEAAnalysis {
    
    public List<FailureMode> analyzeFailureModes(Component component) {
        List<FailureMode> failureModes = new ArrayList<>();
        
        // Example: Database Component
        failureModes.add(new FailureMode(
            "Database Connection Pool Exhaustion",
            "All connections in pool are in use",
            "High",
            "New requests fail, application becomes unresponsive",
            "Monitor connection pool usage, set appropriate pool size, implement connection timeout"
        ));
        
        failureModes.add(new FailureMode(
            "Database Disk Full",
            "Database server runs out of disk space",
            "Critical",
            "Cannot write data, database becomes read-only or crashes",
            "Monitor disk usage, implement alerts, auto-scaling storage"
        ));
        
        failureModes.add(new FailureMode(
            "Database Replication Lag",
            "Read replicas fall behind primary",
            "Medium",
            "Reads return stale data, eventual consistency issues",
            "Monitor replication lag, alert on threshold, use primary for critical reads"
        ));
        
        return failureModes;
    }
}
```

### 2.2 Risk Register Template

```java
class RiskRegister {
    
    private List<Risk> risks = new ArrayList<>();
    
    public void addRisk(Risk risk) {
        risks.add(risk);
    }
    
    public List<Risk> getHighPriorityRisks() {
        return risks.stream()
            .filter(r -> r.getPriority().equals("High") || r.getPriority().equals("Critical"))
            .collect(Collectors.toList());
    }
}

class Risk {
    private String id;
    private String description;
    private RiskCategory category;
    private String probability; // Low, Medium, High
    private String impact; // Low, Medium, High, Critical
    private String riskScore; // Calculated: Probability × Impact
    private String mitigationStrategy;
    private String owner;
    private String status; // Open, In Progress, Mitigated, Accepted
    private Date identifiedDate;
    private Date targetMitigationDate;
    
    public Risk(String description, String details, RiskCategory category, 
                String impact, String probability) {
        this.id = UUID.randomUUID().toString();
        this.description = description;
        this.category = category;
        this.probability = probability;
        this.impact = impact;
        this.riskScore = calculateRiskScore(probability, impact);
        this.identifiedDate = new Date();
        this.status = "Open";
    }
    
    private String calculateRiskScore(String probability, String impact) {
        Map<String, Integer> scores = Map.of(
            "Low", 1, "Medium", 2, "High", 3, "Critical", 4
        );
        
        int probScore = scores.getOrDefault(probability, 1);
        int impactScore = scores.getOrDefault(impact, 1);
        int total = probScore * impactScore;
        
        if (total >= 9) return "Critical";
        if (total >= 6) return "High";
        if (total >= 3) return "Medium";
        return "Low";
    }
    
    // Getters and setters
}

enum RiskCategory {
    INFRASTRUCTURE,
    APPLICATION,
    DATA,
    DEPENDENCY,
    OPERATIONAL,
    SECURITY
}
```

---

## 3. Risk Assessment and Analysis

### 3.1 Risk Matrix

```java
class RiskMatrix {
    
    /**
     * Risk Matrix:
     * 
     * Impact →
     * Probability ↓
     * 
     *              Low    Medium   High    Critical
     * Low          1       2        3        4
     * Medium       2       4        6        8
     * High         3       6        9       12
     * Critical     4       8       12       16
     * 
     * Risk Levels:
     * 1-3:   Low (Accept)
     * 4-6:   Medium (Monitor)
     * 7-9:   High (Mitigate)
     * 10-16: Critical (Immediate Action)
     */
    
    public RiskLevel assessRisk(String probability, String impact) {
        Map<String, Integer> probMap = Map.of(
            "Low", 1, "Medium", 2, "High", 3, "Critical", 4
        );
        Map<String, Integer> impactMap = Map.of(
            "Low", 1, "Medium", 2, "High", 3, "Critical", 4
        );
        
        int score = probMap.get(probability) * impactMap.get(impact);
        
        if (score >= 10) return RiskLevel.CRITICAL;
        if (score >= 7) return RiskLevel.HIGH;
        if (score >= 4) return RiskLevel.MEDIUM;
        return RiskLevel.LOW;
    }
}

enum RiskLevel {
    LOW,        // Accept risk, monitor
    MEDIUM,     // Monitor closely, plan mitigation
    HIGH,       // Mitigate within 30 days
    CRITICAL    // Immediate mitigation required
}
```

### 3.2 Quantitative Risk Analysis

```java
class QuantitativeRiskAnalysis {
    
    /**
     * Quantitative Risk Metrics:
     * 
     * 1. Annualized Loss Expectancy (ALE):
     *    ALE = Single Loss Expectancy (SLE) × Annualized Rate of Occurrence (ARO)
     * 
     * 2. Mean Time Between Failures (MTBF):
     *    Average time between system failures
     * 
     * 3. Mean Time To Repair (MTTR):
     *    Average time to restore service after failure
     * 
     * 4. Availability:
     *    Availability = (MTBF / (MTBF + MTTR)) × 100%
     * 
     * 5. Risk Exposure:
     *    Risk Exposure = Probability × Impact (in dollars)
     */
    
    public RiskMetrics calculateRiskMetrics(Risk risk) {
        // Example: Database failure risk
        double singleLossExpectancy = 100000.0; // $100K per incident
        double annualizedRateOfOccurrence = 0.1; // 10% chance per year
        
        double annualizedLossExpectancy = singleLossExpectancy * annualizedRateOfOccurrence;
        
        double meanTimeBetweenFailures = 365.0 / annualizedRateOfOccurrence; // days
        double meanTimeToRepair = 4.0; // hours
        
        double availability = (meanTimeBetweenFailures * 24) / 
                             ((meanTimeBetweenFailures * 24) + meanTimeToRepair) * 100;
        
        return new RiskMetrics(
            annualizedLossExpectancy,
            meanTimeBetweenFailures,
            meanTimeToRepair,
            availability
        );
    }
}

class RiskMetrics {
    private double ale; // Annualized Loss Expectancy
    private double mtbf; // Mean Time Between Failures
    private double mttr; // Mean Time To Repair
    private double availability; // Percentage
    
    // Constructor and getters
}
```

### 3.3 Risk Prioritization

```java
class RiskPrioritizer {
    
    /**
     * Risk Prioritization Criteria:
     * 
     * 1. Risk Score (Probability × Impact)
     * 2. Business Impact (Revenue, Customers, Reputation)
     * 3. Regulatory Compliance
     * 4. Dependencies (Blocking other work)
     * 5. Effort to Mitigate
     */
    
    public List<Risk> prioritizeRisks(List<Risk> risks) {
        return risks.stream()
            .sorted(Comparator
                .comparing((Risk r) -> getRiskScore(r))
                .thenComparing((Risk r) -> getBusinessImpact(r))
                .reversed())
            .collect(Collectors.toList());
    }
    
    private int getRiskScore(Risk risk) {
        Map<String, Integer> scores = Map.of(
            "Critical", 4, "High", 3, "Medium", 2, "Low", 1
        );
        return scores.getOrDefault(risk.getRiskScore(), 0);
    }
    
    private int getBusinessImpact(Risk risk) {
        // Calculate business impact score
        // Revenue impact, customer impact, reputation impact
        return 0; // Simplified
    }
}
```

---

## 4. Risk Mitigation Strategies

### 4.1 Mitigation Strategy Types

```java
/**
 * Risk Mitigation Strategies:
 * 
 * 1. Avoid:
 *    - Eliminate the risk entirely
 *    - Don't use risky technology
 *    - Don't implement risky feature
 * 
 * 2. Reduce:
 *    - Lower probability or impact
 *    - Add redundancy
 *    - Implement safeguards
 *    - Improve monitoring
 * 
 * 3. Transfer:
 *    - Move risk to third party
 *    - Insurance
 *    - Service level agreements
 *    - Contracts
 * 
 * 4. Accept:
 *    - Accept the risk
 *    - Monitor closely
 *    - Have response plan ready
 */
```

### 4.2 Infrastructure Risk Mitigation

```java
class InfrastructureRiskMitigation {
    
    /**
     * Infrastructure Risk Mitigations:
     * 
     * 1. Single Point of Failure (SPOF):
     *    Mitigation: Add redundancy
     */
    
    public void mitigateSPOF() {
        // Before: Single Redis instance
        // After: Redis Cluster with replication
        
        @Configuration
        class RedisClusterConfig {
            @Bean
            public RedisClusterConfiguration redisClusterConfiguration() {
                RedisClusterConfiguration config = new RedisClusterConfiguration();
                config.setClusterNodes(Arrays.asList(
                    new RedisNode("redis1", 6379),
                    new RedisNode("redis2", 6379),
                    new RedisNode("redis3", 6379)
                ));
                config.setMaxRedirects(3);
                return config;
            }
        }
    }
    
    /**
     * 2. Data Center Failure:
     *    Mitigation: Multi-region deployment
     */
    
    public void mitigateDataCenterFailure() {
        // Deploy in multiple regions
        // Primary region: us-east-1
        // Secondary region: us-west-2
        
        @Configuration
        class MultiRegionConfig {
            @Bean
            @Primary
            public DataSource primaryRegionDataSource() {
                return createDataSource("us-east-1-db");
            }
            
            @Bean
            public DataSource secondaryRegionDataSource() {
                return createDataSource("us-west-2-db");
            }
            
            @Bean
            public DataSource routingDataSource() {
                MultiRegionRoutingDataSource routing = new MultiRegionRoutingDataSource();
                Map<Object, Object> dataSourceMap = new HashMap<>();
                dataSourceMap.put("primary", primaryRegionDataSource());
                dataSourceMap.put("secondary", secondaryRegionDataSource());
                routing.setTargetDataSources(dataSourceMap);
                routing.setDefaultTargetDataSource(primaryRegionDataSource());
                return routing;
            }
        }
    }
    
    /**
     * 3. Network Outage:
     *    Mitigation: Multiple network paths, CDN
     */
    
    public void mitigateNetworkOutage() {
        // Use CDN for static assets
        // Multiple network providers
        // Edge locations
    }
}
```

### 4.3 Application Risk Mitigation

```java
class ApplicationRiskMitigation {
    
    /**
     * Application Risk Mitigations:
     * 
     * 1. Code Bugs:
     *    - Comprehensive testing
     *    - Code reviews
     *    - Static analysis
     *    - Gradual rollout
     */
    
    public void mitigateCodeBugs() {
        // 1. Unit Tests
        @Test
        class OrderServiceTest {
            @Test
            void testCreateOrder() {
                // Comprehensive test coverage
            }
        }
        
        // 2. Integration Tests
        @SpringBootTest
        class IntegrationTest {
            // Test full flow
        }
        
        // 3. Canary Deployment
        @Configuration
        class CanaryDeployment {
            // Deploy to 10% of traffic first
            // Monitor metrics
            // Gradually increase
        }
    }
    
    /**
     * 2. Performance Degradation:
     *    - Performance testing
     *    - Load testing
     *    - Capacity planning
     *    - Auto-scaling
     */
    
    public void mitigatePerformanceIssues() {
        // Load Testing
        @Test
        class LoadTest {
            @Test
            void testUnderLoad() {
                // Simulate 1000 concurrent users
                // Verify response times
                // Check resource usage
            }
        }
        
        // Auto-scaling
        @Configuration
        class AutoScalingConfig {
            // Scale based on CPU, memory, request rate
            // Min: 2 instances
            // Max: 20 instances
            // Target: 70% CPU
        }
    }
    
    /**
     * 3. Security Vulnerabilities:
     *    - Security scanning
     *    - Dependency updates
     *    - Penetration testing
     *    - Security headers
     */
    
    public void mitigateSecurityRisks() {
        // Dependency Scanning
        // Use tools like Snyk, OWASP Dependency Check
        
        // Security Headers
        @Configuration
        class SecurityConfig {
            @Bean
            public SecurityFilterChain securityFilterChain(HttpSecurity http) {
                http.headers(headers -> headers
                    .contentSecurityPolicy(csp -> csp.policyDirectives("default-src 'self'"))
                    .frameOptions(FrameOptionsConfig::deny)
                    .httpStrictTransportSecurity(hsts -> hsts
                        .maxAgeInSeconds(31536000)
                        .includeSubdomains(true))
                );
                return http.build();
            }
        }
    }
}
```

### 4.4 Dependency Risk Mitigation

```java
class DependencyRiskMitigation {
    
    /**
     * Dependency Risk Mitigations:
     * 
     * 1. External Service Failure:
     *    - Circuit breaker
     *    - Retry with backoff
     *    - Fallback mechanisms
     *    - Timeout configuration
     */
    
    public void mitigateExternalServiceFailure() {
        // Circuit Breaker
        @Service
        class PaymentService {
            @Autowired
            private CircuitBreakerRegistry circuitBreakerRegistry;
            
            private CircuitBreaker circuitBreaker;
            
            @PostConstruct
            public void init() {
                circuitBreaker = circuitBreakerRegistry.circuitBreaker("payment-gateway",
                    CircuitBreakerConfig.custom()
                        .failureRateThreshold(50)
                        .waitDurationInOpenState(Duration.ofSeconds(30))
                        .slidingWindowSize(10)
                        .build());
            }
            
            public PaymentResult processPayment(PaymentRequest request) {
                return circuitBreaker.executeSupplier(() -> {
                    // Call payment gateway
                    return paymentGateway.charge(request);
                }, throwable -> {
                    // Fallback: Queue for later processing
                    return queuePaymentForRetry(request);
                });
            }
        }
        
        // Retry with Exponential Backoff
        @Service
        class ExternalServiceClient {
            @Autowired
            private RetryRegistry retryRegistry;
            
            private Retry retry;
            
            @PostConstruct
            public void init() {
                retry = retryRegistry.retry("external-service",
                    RetryConfig.custom()
                        .maxAttempts(3)
                        .waitDuration(Duration.ofSeconds(1))
                        .exponentialBackoffMultiplier(2)
                        .retryExceptions(IOException.class, TimeoutException.class)
                        .build());
            }
            
            public String callExternalService() {
                return retry.executeSupplier(() -> {
                    return restTemplate.getForObject("http://external-service/api", String.class);
                });
            }
        }
    }
    
    /**
     * 2. Library Vulnerabilities:
     *    - Regular dependency updates
     *    - Vulnerability scanning
     *    - Security patches
     */
    
    public void mitigateLibraryVulnerabilities() {
        // Use tools like:
        // - Snyk
        // - OWASP Dependency Check
        // - Dependabot (GitHub)
        
        // Automated scanning in CI/CD
        // Block deployments with critical vulnerabilities
    }
}
```

---

## 5. Risk Monitoring and Review

### 5.1 Risk Monitoring Dashboard

```java
@Service
class RiskMonitoringService {
    
    @Autowired
    private RiskRepository riskRepository;
    
    @Autowired
    private MetricsService metricsService;
    
    /**
     * Risk Monitoring Metrics:
     * 
     * 1. Number of open risks by category
     * 2. Risk score trends
     * 3. Mitigation progress
     * 4. Incident frequency
     * 5. MTTR trends
     */
    
    public RiskDashboard getRiskDashboard() {
        List<Risk> allRisks = riskRepository.findAll();
        
        Map<RiskCategory, Long> risksByCategory = allRisks.stream()
            .filter(r -> r.getStatus().equals("Open"))
            .collect(Collectors.groupingBy(
                Risk::getCategory,
                Collectors.counting()
            ));
        
        List<Risk> criticalRisks = allRisks.stream()
            .filter(r -> r.getRiskScore().equals("Critical"))
            .collect(Collectors.toList());
        
        double mitigationProgress = calculateMitigationProgress(allRisks);
        
        return new RiskDashboard(
            risksByCategory,
            criticalRisks,
            mitigationProgress,
            getRiskTrends()
        );
    }
    
    private double calculateMitigationProgress(List<Risk> risks) {
        long total = risks.size();
        long mitigated = risks.stream()
            .filter(r -> r.getStatus().equals("Mitigated"))
            .count();
        return (double) mitigated / total * 100;
    }
    
    private List<RiskTrend> getRiskTrends() {
        // Get risk trends over time
        // Track risk score changes
        // Monitor new risks
        return new ArrayList<>();
    }
}
```

### 5.2 Risk Review Process

```java
@Service
class RiskReviewService {
    
    /**
     * Risk Review Schedule:
     * 
     * 1. Weekly: Review critical risks
     * 2. Monthly: Review all high-priority risks
     * 3. Quarterly: Comprehensive risk review
     * 4. After Incidents: Immediate risk review
     */
    
    @Scheduled(cron = "0 0 9 * * MON") // Every Monday at 9 AM
    public void weeklyRiskReview() {
        List<Risk> criticalRisks = riskRepository.findByRiskScore("Critical");
        
        for (Risk risk : criticalRisks) {
            // Review mitigation progress
            // Update risk status
            // Escalate if needed
            reviewRisk(risk);
        }
    }
    
    @Scheduled(cron = "0 0 9 1 * ?") // First day of month at 9 AM
    public void monthlyRiskReview() {
        List<Risk> highPriorityRisks = riskRepository.findByPriorityIn(
            Arrays.asList("High", "Critical")
        );
        
        // Comprehensive review
        // Update risk assessments
        // Review mitigation strategies
        // Update risk register
    }
    
    public void reviewRiskAfterIncident(String incidentId) {
        // Immediate risk review after incident
        // Identify new risks
        // Update existing risk assessments
        // Review mitigation strategies
    }
    
    private void reviewRisk(Risk risk) {
        // Check mitigation progress
        // Verify mitigation effectiveness
        // Update risk score if needed
        // Escalate if not progressing
    }
}
```

---

## 6. Practical Examples

### 6.1 Complete Risk Management Implementation

```java
@RestController
@RequestMapping("/api/risks")
class RiskManagementController {
    
    @Autowired
    private RiskService riskService;
    
    @PostMapping
    public ResponseEntity<Risk> createRisk(@RequestBody RiskRequest request) {
        Risk risk = riskService.createRisk(request);
        return ResponseEntity.ok(risk);
    }
    
    @GetMapping
    public ResponseEntity<List<Risk>> getAllRisks(
            @RequestParam(required = false) String category,
            @RequestParam(required = false) String priority) {
        List<Risk> risks = riskService.getRisks(category, priority);
        return ResponseEntity.ok(risks);
    }
    
    @GetMapping("/dashboard")
    public ResponseEntity<RiskDashboard> getDashboard() {
        RiskDashboard dashboard = riskService.getDashboard();
        return ResponseEntity.ok(dashboard);
    }
    
    @PutMapping("/{id}/mitigate")
    public ResponseEntity<Risk> mitigateRisk(
            @PathVariable String id,
            @RequestBody MitigationPlan plan) {
        Risk risk = riskService.mitigateRisk(id, plan);
        return ResponseEntity.ok(risk);
    }
}

@Service
class RiskService {
    
    @Autowired
    private RiskRepository riskRepository;
    
    @Autowired
    private RiskAssessmentService assessmentService;
    
    public Risk createRisk(RiskRequest request) {
        Risk risk = new Risk(
            request.getDescription(),
            request.getDetails(),
            request.getCategory(),
            request.getImpact(),
            request.getProbability()
        );
        
        // Assess risk
        RiskLevel level = assessmentService.assessRisk(risk);
        risk.setRiskLevel(level);
        
        // Auto-assign owner based on category
        risk.setOwner(assignOwner(risk.getCategory()));
        
        return riskRepository.save(risk);
    }
    
    public Risk mitigateRisk(String riskId, MitigationPlan plan) {
        Risk risk = riskRepository.findById(riskId)
            .orElseThrow(() -> new RiskNotFoundException(riskId));
        
        risk.setMitigationStrategy(plan.getStrategy());
        risk.setStatus("In Progress");
        risk.setTargetMitigationDate(plan.getTargetDate());
        
        return riskRepository.save(risk);
    }
    
    private String assignOwner(RiskCategory category) {
        // Assign owner based on risk category
        Map<RiskCategory, String> owners = Map.of(
            RiskCategory.INFRASTRUCTURE, "Infrastructure Team",
            RiskCategory.APPLICATION, "Development Team",
            RiskCategory.DATA, "Data Team",
            RiskCategory.SECURITY, "Security Team"
        );
        return owners.getOrDefault(category, "Engineering Team");
    }
}
```

### 6.2 Risk Assessment for Microservices

```java
@Service
class MicroserviceRiskAssessment {
    
    /**
     * Microservices-Specific Risks:
     * 
     * 1. Service Discovery Failure
     * 2. Network Partition
     * 3. Cascading Failures
     * 4. Data Consistency
     * 5. Distributed Transactions
     * 6. Service Versioning
     */
    
    public List<Risk> assessMicroserviceRisks(List<Microservice> services) {
        List<Risk> risks = new ArrayList<>();
        
        // Risk: Service Discovery Failure
        risks.add(new Risk(
            "Service Discovery Failure",
            "Service registry unavailable, services cannot find each other",
            RiskCategory.INFRASTRUCTURE,
            "Critical",
            "Medium",
            "Use multiple service registries, implement client-side caching"
        ));
        
        // Risk: Cascading Failures
        risks.add(new Risk(
            "Cascading Failures",
            "One service failure causes other services to fail",
            RiskCategory.APPLICATION,
            "Critical",
            "High",
            "Implement circuit breakers, timeouts, bulkheads"
        ));
        
        // Risk: Data Consistency
        risks.add(new Risk(
            "Data Consistency Issues",
            "Distributed transactions fail, data becomes inconsistent",
            RiskCategory.DATA,
            "High",
            "Medium",
            "Use Saga pattern, eventual consistency, compensation"
        ));
        
        return risks;
    }
}
```

---

## Summary: Part 1

### Key Takeaways

1. **Risk Identification**: Use ARA, Threat Modeling, FMEA
2. **Risk Assessment**: Probability × Impact = Risk Score
3. **Risk Mitigation**: Avoid, Reduce, Transfer, Accept
4. **Risk Monitoring**: Continuous monitoring and regular reviews

### Next Steps

**Part 2** will cover:
- Disaster Recovery Planning (RTO/RPO)
- Reliability Patterns (Circuit Breakers, Retries, Graceful Degradation)
- Backup and Recovery Strategies
- High Availability Patterns

---

**Master risk assessment and mitigation to build resilient systems!**

