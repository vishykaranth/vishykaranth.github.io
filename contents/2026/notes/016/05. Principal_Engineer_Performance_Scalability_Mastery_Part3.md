# Principal Engineer: Mastering Performance and Scalability Optimization

## Part 3: Database Optimization (Queries, Indexing, Connection Pooling)

---

## Table of Contents

1. [Query Optimization Techniques](#1-query-optimization-techniques)
2. [Index Strategy and Design](#2-index-strategy-and-design)
3. [Connection Pooling Optimization](#3-connection-pooling-optimization)
4. [Database Schema Optimization](#4-database-schema-optimization)
5. [Query Performance Analysis](#5-query-performance-analysis)
6. [Practical Database Optimization Examples](#6-practical-database-optimization-examples)

---

## 1. Query Optimization Techniques

### 1.1 Understanding Query Performance

**Query Execution Plan Analysis**:
```sql
-- PostgreSQL: EXPLAIN ANALYZE
EXPLAIN ANALYZE
SELECT u.id, u.name, u.email, o.id as order_id, o.total
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE u.status = 'ACTIVE'
ORDER BY u.created_at DESC
LIMIT 100;

-- MySQL: EXPLAIN
EXPLAIN
SELECT * FROM users WHERE email = 'user@example.com';

-- Analyze execution plan:
-- 1. Check if indexes are used
-- 2. Check join types (Nested Loop, Hash Join, Merge Join)
-- 3. Check if full table scan occurs
-- 4. Check estimated vs actual rows
```

**Query Performance Metrics**:
```java
@Component
class QueryPerformanceMonitor {
    
    @Autowired
    private DataSource dataSource;
    
    /**
     * Query Performance Metrics:
     * 
     * 1. Execution Time:
     *    - Total query time
     *    - Planning time
     *    - Execution time
     * 
     * 2. I/O Operations:
     *    - Sequential scans
     *    - Index scans
     *    - Buffer hits/misses
     * 
     * 3. Row Operations:
     *    - Rows examined
     *    - Rows returned
     *    - Rows filtered
     */
    
    public QueryStats analyzeQuery(String sql) {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            long startTime = System.currentTimeMillis();
            ResultSet rs = stmt.executeQuery();
            long executionTime = System.currentTimeMillis() - startTime;
            
            int rowCount = 0;
            while (rs.next()) {
                rowCount++;
            }
            
            return new QueryStats(sql, executionTime, rowCount);
        } catch (SQLException e) {
            throw new RuntimeException("Query analysis failed", e);
        }
    }
}
```

### 1.2 Common Query Optimization Patterns

**1. Avoid N+1 Query Problem**:
```java
// BAD: N+1 Queries
@Repository
class BadUserRepository {
    
    public List<UserWithOrders> getUsersWithOrders() {
        // Query 1: Get all users
        List<User> users = findAll();
        
        // Query 2-N: Get orders for each user (N queries)
        for (User user : users) {
            List<Order> orders = orderRepository.findByUserId(user.getId());
            user.setOrders(orders);
        }
        
        return users;
    }
}

// GOOD: Single Query with JOIN
@Repository
class OptimizedUserRepository {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    public List<UserWithOrders> getUsersWithOrders() {
        String sql = """
            SELECT u.id, u.name, u.email, 
                   o.id as order_id, o.total, o.created_at
            FROM users u
            LEFT JOIN orders o ON u.id = o.user_id
            WHERE u.status = 'ACTIVE'
            ORDER BY u.created_at DESC
            """;
        
        // Single query with JOIN - much faster
        return jdbcTemplate.query(sql, new UserWithOrdersRowMapper());
    }
}

// Using JPA with @EntityGraph
@Entity
class User {
    @Id
    private String id;
    
    @OneToMany(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private List<Order> orders;
}

@Repository
interface UserRepository extends JpaRepository<User, String> {
    
    @EntityGraph(attributePaths = {"orders"})
    @Query("SELECT u FROM User u WHERE u.status = 'ACTIVE'")
    List<User> findActiveUsersWithOrders();
}
```

**2. Use Appropriate JOIN Types**:
```java
/**
 * JOIN Type Selection:
 * 
 * INNER JOIN: When you need matching records from both tables
 * LEFT JOIN: When you need all records from left table
 * RIGHT JOIN: When you need all records from right table
 * FULL OUTER JOIN: When you need all records from both tables
 */

// Use INNER JOIN when possible (faster)
@Repository
class OptimizedJoinRepository {
    
    // INNER JOIN (faster, only matching records)
    public List<UserOrder> getUsersWithOrders() {
        String sql = """
            SELECT u.id, u.name, o.id as order_id, o.total
            FROM users u
            INNER JOIN orders o ON u.id = o.user_id
            WHERE u.status = 'ACTIVE'
            """;
        return jdbcTemplate.query(sql, new UserOrderRowMapper());
    }
    
    // Use LEFT JOIN only when needed
    public List<UserOrder> getUsersWithOptionalOrders() {
        String sql = """
            SELECT u.id, u.name, o.id as order_id, o.total
            FROM users u
            LEFT JOIN orders o ON u.id = o.user_id
            WHERE u.status = 'ACTIVE'
            """;
        return jdbcTemplate.query(sql, new UserOrderRowMapper());
    }
}
```

**3. Use EXISTS Instead of COUNT**:
```java
// BAD: COUNT(*) scans all rows
@Repository
class BadRepository {
    
    public boolean userHasOrders(String userId) {
        String sql = "SELECT COUNT(*) FROM orders WHERE user_id = ?";
        int count = jdbcTemplate.queryForObject(sql, Integer.class, userId);
        return count > 0; // Scans all matching rows
    }
}

// GOOD: EXISTS stops at first match
@Repository
class OptimizedRepository {
    
    public boolean userHasOrders(String userId) {
        String sql = "SELECT EXISTS(SELECT 1 FROM orders WHERE user_id = ?)";
        Boolean exists = jdbcTemplate.queryForObject(sql, Boolean.class, userId);
        return Boolean.TRUE.equals(exists); // Stops at first match
    }
}
```

**4. Use LIMIT and Pagination**:
```java
@Repository
class PaginatedRepository {
    
    // BAD: Fetch all records
    public List<User> getAllUsers() {
        return jdbcTemplate.query("SELECT * FROM users", new UserRowMapper());
        // Loads all users into memory
    }
    
    // GOOD: Pagination with LIMIT
    public Page<User> getUsers(Pageable pageable) {
        String countSql = "SELECT COUNT(*) FROM users";
        int total = jdbcTemplate.queryForObject(countSql, Integer.class);
        
        String dataSql = """
            SELECT * FROM users 
            ORDER BY created_at DESC 
            LIMIT ? OFFSET ?
            """;
        
        List<User> users = jdbcTemplate.query(
            dataSql,
            new Object[]{pageable.getPageSize(), pageable.getOffset()},
            new UserRowMapper()
        );
        
        return new PageImpl<>(users, pageable, total);
    }
    
    // BEST: Cursor-based pagination (for large datasets)
    public List<User> getUsersAfter(String lastId, int limit) {
        String sql = """
            SELECT * FROM users 
            WHERE id > ? 
            ORDER BY id 
            LIMIT ?
            """;
        return jdbcTemplate.query(sql, new Object[]{lastId, limit}, new UserRowMapper());
    }
}
```

**5. Use Batch Operations**:
```java
@Repository
class BatchRepository {
    
    // BAD: Individual inserts
    public void saveUsers(List<User> users) {
        for (User user : users) {
            jdbcTemplate.update(
                "INSERT INTO users (id, name, email) VALUES (?, ?, ?)",
                user.getId(), user.getName(), user.getEmail()
            );
        }
        // N database round trips
    }
    
    // GOOD: Batch insert
    public void saveUsersBatch(List<User> users) {
        String sql = "INSERT INTO users (id, name, email) VALUES (?, ?, ?)";
        
        jdbcTemplate.batchUpdate(sql, users, 100, (ps, user) -> {
            ps.setString(1, user.getId());
            ps.setString(2, user.getName());
            ps.setString(3, user.getEmail());
        });
        // Single database round trip
    }
    
    // BEST: Bulk insert (PostgreSQL)
    public void saveUsersBulk(List<User> users) {
        String sql = """
            INSERT INTO users (id, name, email) 
            VALUES (?, ?, ?)
            ON CONFLICT (id) DO UPDATE 
            SET name = EXCLUDED.name, email = EXCLUDED.email
            """;
        
        jdbcTemplate.batchUpdate(sql, users, 1000, (ps, user) -> {
            ps.setString(1, user.getId());
            ps.setString(2, user.getName());
            ps.setString(3, user.getEmail());
        });
    }
}
```

### 1.3 Query Caching

**Query Result Caching**:
```java
@Configuration
class QueryCacheConfig {
    
    @Bean
    public CacheManager queryCacheManager() {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(5))
            .serializeValuesWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new GenericJackson2JsonRedisSerializer()));
        
        return RedisCacheManager.builder(redisConnectionFactory())
            .cacheDefaults(config)
            .build();
    }
}

@Repository
class CachedRepository {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    @Autowired
    private RedisTemplate<String, List<User>> redisTemplate;
    
    @Cacheable(value = "users", key = "#status")
    public List<User> findUsersByStatus(String status) {
        String sql = "SELECT * FROM users WHERE status = ?";
        return jdbcTemplate.query(sql, new Object[]{status}, new UserRowMapper());
    }
    
    // Manual caching for complex queries
    public List<User> findActiveUsersWithOrders() {
        String cacheKey = "users:active:with-orders";
        
        // Check cache
        List<User> cached = redisTemplate.opsForValue().get(cacheKey);
        if (cached != null) {
            return cached;
        }
        
        // Query database
        String sql = """
            SELECT u.*, o.id as order_id, o.total
            FROM users u
            LEFT JOIN orders o ON u.id = o.user_id
            WHERE u.status = 'ACTIVE'
            """;
        List<User> users = jdbcTemplate.query(sql, new UserWithOrdersRowMapper());
        
        // Cache result
        redisTemplate.opsForValue().set(cacheKey, users, Duration.ofMinutes(10));
        
        return users;
    }
}
```

---

## 2. Index Strategy and Design

### 2.1 Understanding Indexes

**Index Types**:
```sql
-- B-Tree Index (Default, most common)
CREATE INDEX idx_user_email ON users(email);

-- Hash Index (Equality only, PostgreSQL)
CREATE INDEX idx_user_email_hash ON users USING HASH(email);

-- Composite Index (Multiple columns)
CREATE INDEX idx_user_status_created ON users(status, created_at);

-- Partial Index (Filtered)
CREATE INDEX idx_active_users ON users(email) WHERE status = 'ACTIVE';

-- Covering Index (Includes all columns needed)
CREATE INDEX idx_user_covering ON users(id, name, email) 
INCLUDE (status, created_at);

-- Unique Index
CREATE UNIQUE INDEX idx_user_email_unique ON users(email);
```

### 2.2 Index Design Strategy

**Index Selection Guidelines**:
```java
/**
 * Index Design Strategy:
 * 
 * 1. Index Frequently Queried Columns:
 *    - WHERE clause columns
 *    - JOIN columns
 *    - ORDER BY columns
 * 
 * 2. Composite Index Order:
 *    - Most selective first
 *    - Equality before range
 *    - Consider query patterns
 * 
 * 3. Avoid Over-Indexing:
 *    - Each index adds write overhead
 *    - Monitor index usage
 *    - Remove unused indexes
 * 
 * 4. Covering Indexes:
 *    - Include all needed columns
 *    - Avoid table lookups
 *    - Faster query execution
 */
```

**Index Design Examples**:
```sql
-- Example 1: Single Column Index
-- Query: SELECT * FROM users WHERE email = 'user@example.com'
CREATE INDEX idx_users_email ON users(email);

-- Example 2: Composite Index (Order Matters!)
-- Query: SELECT * FROM users WHERE status = 'ACTIVE' AND created_at > '2024-01-01'
-- Good: status first (equality), then created_at (range)
CREATE INDEX idx_users_status_created ON users(status, created_at);

-- Bad: created_at first (range), then status
-- CREATE INDEX idx_users_created_status ON users(created_at, status);
-- This index won't be used efficiently

-- Example 3: Covering Index
-- Query: SELECT id, name, email FROM users WHERE status = 'ACTIVE'
CREATE INDEX idx_users_status_covering ON users(status) 
INCLUDE (id, name, email);
-- Query can be satisfied from index only

-- Example 4: Partial Index (Smaller, Faster)
-- Query: SELECT * FROM users WHERE status = 'ACTIVE' AND email = 'user@example.com'
CREATE INDEX idx_active_users_email ON users(email) 
WHERE status = 'ACTIVE';
-- Only indexes active users, smaller index
```

**Index Usage Analysis**:
```java
@Component
class IndexAnalyzer {
    
    @Autowired
    private DataSource dataSource;
    
    /**
     * Analyze Index Usage:
     * 
     * PostgreSQL:
     * SELECT * FROM pg_stat_user_indexes;
     * 
     * MySQL:
     * SHOW INDEX FROM users;
     * SELECT * FROM sys.schema_unused_indexes;
     */
    
    public void analyzeIndexUsage() {
        String sql = """
            SELECT 
                schemaname,
                tablename,
                indexname,
                idx_scan as index_scans,
                idx_tup_read as tuples_read,
                idx_tup_fetch as tuples_fetched
            FROM pg_stat_user_indexes
            WHERE schemaname = 'public'
            ORDER BY idx_scan ASC
            """;
        
        // Find unused indexes
        List<IndexStats> stats = jdbcTemplate.query(sql, new IndexStatsRowMapper());
        
        stats.stream()
            .filter(s -> s.getIndexScans() == 0)
            .forEach(s -> logger.warn("Unused index: {}", s.getIndexName()));
    }
    
    public void analyzeSlowQueries() {
        // Enable slow query log
        // Analyze queries that don't use indexes
        String sql = """
            SELECT 
                query,
                calls,
                total_time,
                mean_time,
                rows
            FROM pg_stat_statements
            WHERE mean_time > 100  -- Queries taking > 100ms
            ORDER BY mean_time DESC
            LIMIT 20
            """;
        
        List<SlowQuery> slowQueries = jdbcTemplate.query(sql, new SlowQueryRowMapper());
        
        slowQueries.forEach(query -> {
            logger.warn("Slow query: {} (avg: {}ms, calls: {})",
                query.getQuery(), query.getMeanTime(), query.getCalls());
        });
    }
}
```

### 2.3 Index Maintenance

**Index Maintenance Strategy**:
```sql
-- Rebuild Index (PostgreSQL)
REINDEX INDEX idx_users_email;

-- Rebuild All Indexes on Table
REINDEX TABLE users;

-- Analyze Table (Update Statistics)
ANALYZE users;

-- Vacuum (Clean up, Update Statistics)
VACUUM ANALYZE users;

-- MySQL: Optimize Table
OPTIMIZE TABLE users;
```

**Automated Index Maintenance**:
```java
@Component
class IndexMaintenanceService {
    
    @Autowired
    private DataSource dataSource;
    
    @Scheduled(cron = "0 2 * * *") // Daily at 2 AM
    public void performIndexMaintenance() {
        logger.info("Starting index maintenance");
        
        // Rebuild indexes
        rebuildIndexes();
        
        // Update statistics
        updateStatistics();
        
        // Find and remove unused indexes
        removeUnusedIndexes();
        
        logger.info("Index maintenance completed");
    }
    
    private void rebuildIndexes() {
        // Rebuild indexes on frequently updated tables
        List<String> tables = Arrays.asList("users", "orders", "products");
        
        tables.forEach(table -> {
            String sql = "REINDEX TABLE " + table;
            jdbcTemplate.execute(sql);
            logger.info("Rebuilt indexes for table: {}", table);
        });
    }
    
    private void updateStatistics() {
        // Update query planner statistics
        List<String> tables = Arrays.asList("users", "orders", "products");
        
        tables.forEach(table -> {
            String sql = "ANALYZE " + table;
            jdbcTemplate.execute(sql);
            logger.info("Updated statistics for table: {}", table);
        });
    }
    
    private void removeUnusedIndexes() {
        // Find and remove unused indexes (with caution!)
        String sql = """
            SELECT indexname 
            FROM pg_stat_user_indexes 
            WHERE idx_scan = 0 
            AND indexname NOT LIKE '%_pkey'
            """;
        
        List<String> unusedIndexes = jdbcTemplate.queryForList(sql, String.class);
        
        unusedIndexes.forEach(index -> {
            logger.warn("Unused index found: {}", index);
            // Don't auto-delete, just log for review
        });
    }
}
```

---

## 3. Connection Pooling Optimization

### 3.1 Connection Pool Sizing

**Connection Pool Calculation**:
```java
/**
 * Connection Pool Sizing Formula:
 * 
 * Optimal Pool Size = ((core_count * 2) + effective_spindle_count)
 * 
 * Where:
 * - core_count = CPU cores
 * - effective_spindle_count = Disk I/O capacity
 * 
 * For modern SSDs: effective_spindle_count â‰ˆ 0
 * 
 * Example:
 * - 8 CPU cores
 * - SSD storage
 * - Pool size = (8 * 2) + 0 = 16 connections
 * 
 * Adjust based on:
 * - Query execution time
 * - Concurrent requests
 * - Database capacity
 */
```

**HikariCP Configuration**:
```java
@Configuration
class OptimizedConnectionPoolConfig {
    
    @Bean
    public DataSource dataSource() {
        HikariConfig config = new HikariConfig();
        
        // Basic Configuration
        config.setJdbcUrl("jdbc:postgresql://localhost:5432/mydb");
        config.setUsername("user");
        config.setPassword("password");
        
        // Connection Pool Sizing
        int cores = Runtime.getRuntime().availableProcessors();
        int optimalPoolSize = (cores * 2) + 1;
        
        config.setMaximumPoolSize(optimalPoolSize);
        config.setMinimumIdle(Math.max(optimalPoolSize / 2, 2));
        
        // Connection Timeouts
        config.setConnectionTimeout(30000);      // 30 seconds
        config.setIdleTimeout(600000);           // 10 minutes
        config.setMaxLifetime(1800000);          // 30 minutes
        
        // Leak Detection
        config.setLeakDetectionThreshold(60000);  // 60 seconds
        
        // Performance Optimizations
        config.addDataSourceProperty("cachePrepStmts", "true");
        config.addDataSourceProperty("prepStmtCacheSize", "250");
        config.addDataSourceProperty("prepStmtCacheSqlLimit", "2048");
        config.addDataSourceProperty("useServerPrepStmts", "true");
        config.addDataSourceProperty("rewriteBatchedStatements", "true");
        
        // Connection Validation
        config.setConnectionTestQuery("SELECT 1");
        config.setValidationTimeout(5000);
        
        // Metrics
        config.setRegisterMbeans(true);
        
        return new HikariDataSource(config);
    }
}
```

### 3.2 Connection Pool Monitoring

**Connection Pool Metrics**:
```java
@Component
class ConnectionPoolMonitor {
    
    @Autowired
    private DataSource dataSource;
    
    @Scheduled(fixedRate = 60000) // Every minute
    public void monitorConnectionPool() {
        if (dataSource instanceof HikariDataSource) {
            HikariDataSource hikariDS = (HikariDataSource) dataSource;
            HikariPoolMXBean poolBean = hikariDS.getHikariPoolMXBean();
            
            int active = poolBean.getActiveConnections();
            int idle = poolBean.getIdleConnections();
            int total = poolBean.getTotalConnections();
            int threadsAwaiting = poolBean.getThreadsAwaitingConnection();
            
            logger.info("Connection Pool Stats: Active={}, Idle={}, Total={}, Waiting={}",
                active, idle, total, threadsAwaiting);
            
            // Alert if pool is exhausted
            if (threadsAwaiting > 0) {
                logger.warn("Connection pool exhausted! {} threads waiting", threadsAwaiting);
                // Send alert
            }
            
            // Alert if pool is too large
            if (idle > total * 0.8) {
                logger.warn("Connection pool too large: {}% idle", (idle * 100 / total));
            }
        }
    }
}
```

### 3.3 Connection Pool Tuning

**Dynamic Connection Pool Adjustment**:
```java
@Component
class DynamicConnectionPoolTuner {
    
    @Autowired
    private HikariDataSource dataSource;
    
    @Scheduled(fixedRate = 300000) // Every 5 minutes
    public void tuneConnectionPool() {
        HikariPoolMXBean poolBean = dataSource.getHikariPoolMXBean();
        
        int active = poolBean.getActiveConnections();
        int total = poolBean.getTotalConnections();
        int maxPoolSize = dataSource.getMaximumPoolSize();
        
        double utilization = (double) active / maxPoolSize;
        
        // Increase pool if utilization > 80%
        if (utilization > 0.8 && maxPoolSize < 50) {
            int newSize = Math.min(maxPoolSize + 5, 50);
            dataSource.setMaximumPoolSize(newSize);
            logger.info("Increased connection pool size to: {}", newSize);
        }
        
        // Decrease pool if utilization < 30%
        if (utilization < 0.3 && maxPoolSize > 10) {
            int newSize = Math.max(maxPoolSize - 2, 10);
            dataSource.setMaximumPoolSize(newSize);
            logger.info("Decreased connection pool size to: {}", newSize);
        }
    }
}
```

---

## 4. Database Schema Optimization

### 4.1 Normalization vs Denormalization

**Normalization Strategy**:
```java
/**
 * Normalization Benefits:
 * - Reduces data redundancy
 * - Prevents update anomalies
 * - Saves storage space
 * 
 * Normalization Trade-offs:
 * - More JOINs required
 * - Slower read queries
 * - More complex queries
 */
```

**Denormalization for Performance**:
```java
/**
 * Denormalization Strategy:
 * 
 * When to Denormalize:
 * - Read-heavy workloads
 * - Frequent JOINs on same tables
 * - Reporting/analytics queries
 * - Real-time requirements
 * 
 * Denormalization Techniques:
 * - Add computed columns
 * - Duplicate frequently accessed data
 * - Materialized views
 * - Read replicas with different schemas
 */

// Example: Denormalized Order Table
@Entity
@Table(name = "orders")
class Order {
    @Id
    private String id;
    
    // Denormalized: Store user name instead of just user_id
    private String userId;
    private String userName;  // Denormalized from users table
    private String userEmail; // Denormalized from users table
    
    // Denormalized: Store product info
    private String productId;
    private String productName; // Denormalized from products table
    private Double productPrice; // Denormalized from products table
    
    // Benefits:
    // - Faster queries (no JOINs needed)
    // - Better read performance
    // 
    // Trade-offs:
    // - More storage
    // - Update complexity (update multiple places)
}
```

### 4.2 Partitioning

**Table Partitioning**:
```sql
-- Range Partitioning (PostgreSQL)
CREATE TABLE orders (
    id VARCHAR(50),
    user_id VARCHAR(50),
    total DECIMAL(10,2),
    created_at TIMESTAMP
) PARTITION BY RANGE (created_at);

-- Create partitions
CREATE TABLE orders_2024_01 PARTITION OF orders
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE TABLE orders_2024_02 PARTITION OF orders
    FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');

-- Hash Partitioning
CREATE TABLE users (
    id VARCHAR(50),
    name VARCHAR(100),
    email VARCHAR(100)
) PARTITION BY HASH (id);

CREATE TABLE users_0 PARTITION OF users FOR VALUES WITH (MODULUS 4, REMAINDER 0);
CREATE TABLE users_1 PARTITION OF users FOR VALUES WITH (MODULUS 4, REMAINDER 1);
CREATE TABLE users_2 PARTITION OF users FOR VALUES WITH (MODULUS 4, REMAINDER 2);
CREATE TABLE users_3 PARTITION OF users FOR VALUES WITH (MODULUS 4, REMAINDER 3);
```

**Partitioning in Java**:
```java
@Repository
class PartitionedOrderRepository {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    /**
     * Partitioning Benefits:
     * - Faster queries (query only relevant partition)
     * - Easier maintenance (drop old partitions)
     * - Better performance for time-series data
     */
    
    public List<Order> getOrdersByDateRange(LocalDate start, LocalDate end) {
        // Query automatically routes to correct partitions
        String sql = """
            SELECT * FROM orders 
            WHERE created_at BETWEEN ? AND ?
            ORDER BY created_at DESC
            """;
        
        return jdbcTemplate.query(
            sql,
            new Object[]{start, end},
            new OrderRowMapper()
        );
    }
    
    public void archiveOldOrders(LocalDate cutoffDate) {
        // Drop old partitions (fast!)
        String partitionName = "orders_" + cutoffDate.format(DateTimeFormatter.ofPattern("yyyy_MM"));
        String sql = "DROP TABLE IF EXISTS " + partitionName;
        jdbcTemplate.execute(sql);
    }
}
```

---

## 5. Query Performance Analysis

### 5.1 Slow Query Detection

**Slow Query Log Analysis**:
```java
@Component
class SlowQueryDetector {
    
    @Autowired
    private DataSource dataSource;
    
    private static final long SLOW_QUERY_THRESHOLD = 1000; // 1 second
    
    @Aspect
    @Component
    class QueryPerformanceAspect {
        
        @Around("execution(* org.springframework.jdbc.core.JdbcTemplate.*(..))")
        public Object profileQuery(ProceedingJoinPoint joinPoint) throws Throwable {
            long startTime = System.currentTimeMillis();
            
            try {
                Object result = joinPoint.proceed();
                long duration = System.currentTimeMillis() - startTime;
                
                if (duration > SLOW_QUERY_THRESHOLD) {
                    String query = extractQuery(joinPoint);
                    logger.warn("Slow query detected: {}ms - {}", duration, query);
                    recordSlowQuery(query, duration);
                }
                
                return result;
            } catch (Throwable e) {
                long duration = System.currentTimeMillis() - startTime;
                logger.error("Query failed after {}ms", duration, e);
                throw e;
            }
        }
        
        private String extractQuery(ProceedingJoinPoint joinPoint) {
            Object[] args = joinPoint.getArgs();
            if (args.length > 0 && args[0] instanceof String) {
                return (String) args[0];
            }
            return "Unknown query";
        }
        
        private void recordSlowQuery(String query, long duration) {
            // Record to monitoring system
            metricsService.recordSlowQuery(query, duration);
        }
    }
}
```

### 5.2 Query Plan Analysis

**EXPLAIN Plan Parsing**:
```java
@Component
class QueryPlanAnalyzer {
    
    @Autowired
    private DataSource dataSource;
    
    public QueryPlan analyzeQueryPlan(String sql) {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("EXPLAIN ANALYZE " + sql);
             ResultSet rs = stmt.executeQuery()) {
            
            StringBuilder plan = new StringBuilder();
            while (rs.next()) {
                plan.append(rs.getString(1)).append("\n");
            }
            
            return parseQueryPlan(plan.toString());
        } catch (SQLException e) {
            throw new RuntimeException("Query plan analysis failed", e);
        }
    }
    
    private QueryPlan parseQueryPlan(String planText) {
        QueryPlan plan = new QueryPlan();
        
        // Parse execution plan
        if (planText.contains("Seq Scan")) {
            plan.addWarning("Full table scan detected - consider adding index");
        }
        
        if (planText.contains("Nested Loop")) {
            plan.addInfo("Using nested loop join");
        }
        
        if (planText.contains("Hash Join")) {
            plan.addInfo("Using hash join");
        }
        
        // Extract execution time
        // Pattern: "Execution Time: X.XXX ms"
        Pattern timePattern = Pattern.compile("Execution Time: (\\d+\\.\\d+) ms");
        Matcher matcher = timePattern.matcher(planText);
        if (matcher.find()) {
            plan.setExecutionTime(Double.parseDouble(matcher.group(1)));
        }
        
        return plan;
    }
}
```

---

## 6. Practical Database Optimization Examples

### 6.1 E-Commerce Database Optimization

**Optimized Schema**:
```sql
-- Users Table with Indexes
CREATE TABLE users (
    id VARCHAR(50) PRIMARY KEY,
    email VARCHAR(100) NOT NULL,
    name VARCHAR(100),
    status VARCHAR(20),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Indexes
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_status ON users(status);
CREATE INDEX idx_users_status_created ON users(status, created_at);

-- Orders Table with Partitioning
CREATE TABLE orders (
    id VARCHAR(50) PRIMARY KEY,
    user_id VARCHAR(50) NOT NULL,
    total DECIMAL(10,2),
    status VARCHAR(20),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) PARTITION BY RANGE (created_at);

-- Foreign Key Index
CREATE INDEX idx_orders_user_id ON orders(user_id);
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_orders_created ON orders(created_at);
```

**Optimized Queries**:
```java
@Repository
class OptimizedECommerceRepository {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    // Optimized: Uses indexes, single query
    public List<UserOrderSummary> getUserOrderSummary(String userId) {
        String sql = """
            SELECT 
                u.id, u.name, u.email,
                COUNT(o.id) as order_count,
                SUM(o.total) as total_spent
            FROM users u
            INNER JOIN orders o ON u.id = o.user_id
            WHERE u.id = ?
            GROUP BY u.id, u.name, u.email
            """;
        
        return jdbcTemplate.query(sql, new Object[]{userId}, new UserOrderSummaryRowMapper());
    }
    
    // Optimized: Cursor-based pagination
    public List<Order> getRecentOrders(String lastOrderId, int limit) {
        String sql = """
            SELECT * FROM orders 
            WHERE id > ? 
            ORDER BY id 
            LIMIT ?
            """;
        return jdbcTemplate.query(sql, new Object[]{lastOrderId, limit}, new OrderRowMapper());
    }
}
```

---

## Summary: Part 3

### Key Takeaways

1. **Query Optimization**: Avoid N+1, use JOINs, batch operations, pagination
2. **Index Strategy**: Right indexes, composite indexes, covering indexes
3. **Connection Pooling**: Proper sizing, monitoring, tuning
4. **Schema Optimization**: Normalization vs denormalization, partitioning
5. **Performance Analysis**: Slow query detection, query plan analysis

### Next Steps

**Part 4** will cover:
- Load Testing and Capacity Planning
- Performance Testing Strategies
- Capacity Planning Methodology
- Stress Testing and Chaos Engineering

---

**Master database optimization to achieve 5-10x query performance improvements!**

