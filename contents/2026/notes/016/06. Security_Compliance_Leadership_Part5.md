# Security and Compliance Leadership for Principal Engineers

## Part 5: Incident Response and Security Operations

---

## Table of Contents

1. [Incident Response Fundamentals](#1-incident-response-fundamentals)
2. [Incident Response Process](#2-incident-response-process)
3. [Security Monitoring and Detection](#3-security-monitoring-and-detection)
4. [Security Operations Center (SOC)](#4-security-operations-center-soc)
5. [Incident Response Playbooks](#5-incident-response-playbooks)
6. [Post-Incident Activities](#6-post-incident-activities)
7. [Practical Examples](#7-practical-examples)

---

## 1. Incident Response Fundamentals

### 1.1 What is Incident Response?

**Definition**: Organized approach to addressing and managing security incidents, breaches, and cyber threats.

**Objectives**:
- Minimize damage
- Reduce recovery time
- Preserve evidence
- Restore normal operations
- Learn and improve

### 1.2 Types of Security Incidents

```java
/**
 * Security Incident Types:
 * 
 * 1. Data Breach:
 *    - Unauthorized access to data
 *    - Data exfiltration
 *    - PII/PHI exposure
 * 
 * 2. Malware Infection:
 *    - Ransomware
 *    - Trojans
 *    - Worms
 * 
 * 3. Denial of Service (DoS):
 *    - DDoS attacks
 *    - Resource exhaustion
 *    - Service unavailability
 * 
 * 4. Unauthorized Access:
 *    - Account compromise
 *    - Privilege escalation
 *    - Insider threat
 * 
 * 5. Phishing:
 *    - Email phishing
 *    - Credential theft
 *    - Social engineering
 * 
 * 6. System Compromise:
 *    - Server compromise
 *    - Application compromise
 *    - Network intrusion
 */
```

### 1.3 Incident Severity Levels

```java
enum IncidentSeverity {
    CRITICAL(1, "Critical", "Immediate response required", "CISO, Security Team, Legal"),
    HIGH(2, "High", "Response within 1 hour", "Security Team, Management"),
    MEDIUM(3, "Medium", "Response within 4 hours", "Security Team"),
    LOW(4, "Low", "Response within 24 hours", "Security Team");
    
    private int level;
    private String name;
    private String responseTime;
    private String stakeholders;
    
    IncidentSeverity(int level, String name, String responseTime, String stakeholders) {
        this.level = level;
        this.name = name;
        this.responseTime = responseTime;
        this.stakeholders = stakeholders;
    }
}

class SecurityIncident {
    private String id;
    private IncidentType type;
    private IncidentSeverity severity;
    private String description;
    private Instant detectedAt;
    private Instant resolvedAt;
    private IncidentStatus status;
    private List<String> affectedSystems;
    private List<String> indicatorsOfCompromise;
}
```

---

## 2. Incident Response Process

### 2.1 NIST Incident Response Lifecycle

**Six Phases**:

```java
/**
 * NIST Incident Response Lifecycle:
 * 
 * Phase 1: Preparation
 *    - Incident response plan
 *    - Tools and resources
 *    - Training and awareness
 *    - Communication plans
 * 
 * Phase 2: Detection and Analysis
 *    - Monitoring and detection
 *    - Incident identification
 *    - Analysis and classification
 *    - Documentation
 * 
 * Phase 3: Containment
 *    - Short-term containment
 *    - Long-term containment
 *    - Evidence preservation
 * 
 * Phase 4: Eradication
 *    - Remove threat
 *    - Patch vulnerabilities
 *    - Remove malware
 *    - Close attack vectors
 * 
 * Phase 5: Recovery
 *    - Restore systems
 *    - Validate functionality
 *    - Monitor for recurrence
 *    - Return to normal operations
 * 
 * Phase 6: Post-Incident Activity
 *    - Lessons learned
 *    - Documentation
 *    - Process improvement
 *    - Training updates
 */
```

### 2.2 Incident Response Team

**Roles and Responsibilities**:

```java
/**
 * Incident Response Team Roles:
 * 
 * 1. Incident Response Manager:
 *    - Overall coordination
 *    - Decision making
 *    - Communication
 * 
 * 2. Security Analysts:
 *    - Threat analysis
 *    - Forensics
 *    - Investigation
 * 
 * 3. System Administrators:
 *    - System access
 *    - Configuration changes
 *    - System restoration
 * 
 * 4. Network Engineers:
 *    - Network analysis
 *    - Traffic monitoring
 *    - Network containment
 * 
 * 5. Legal Counsel:
 *    - Legal requirements
 *    - Regulatory compliance
 *    - Notification requirements
 * 
 * 6. Public Relations:
 *    - External communication
 *    - Media relations
 *    - Customer notification
 * 
 * 7. Management:
 *    - Business decisions
 *    - Resource allocation
 *    - Risk acceptance
 */
```

### 2.3 Incident Response Implementation

**Incident Response Service**:

```java
@Service
class IncidentResponseService {
    
    @Autowired
    private SecurityMonitoringService monitoringService;
    
    @Autowired
    private NotificationService notificationService;
    
    @Autowired
    private IncidentRepository incidentRepository;
    
    @Autowired
    private ForensicsService forensicsService;
    
    public SecurityIncident handleIncident(IncidentDetection detection) {
        // Phase 1: Detection and Analysis
        SecurityIncident incident = analyzeIncident(detection);
        
        // Phase 2: Containment
        containIncident(incident);
        
        // Phase 3: Eradication
        eradicateThreat(incident);
        
        // Phase 4: Recovery
        recoverSystems(incident);
        
        // Phase 5: Post-Incident
        postIncidentActivity(incident);
        
        return incident;
    }
    
    private SecurityIncident analyzeIncident(IncidentDetection detection) {
        // Classify incident
        IncidentType type = classifyIncident(detection);
        IncidentSeverity severity = assessSeverity(detection);
        
        // Create incident record
        SecurityIncident incident = new SecurityIncident();
        incident.setId(UUID.randomUUID().toString());
        incident.setType(type);
        incident.setSeverity(severity);
        incident.setDetectedAt(Instant.now());
        incident.setStatus(IncidentStatus.OPEN);
        incident.setDescription(detection.getDescription());
        
        // Collect indicators of compromise
        List<String> iocs = collectIOCs(detection);
        incident.setIndicatorsOfCompromise(iocs);
        
        // Notify stakeholders
        notifyStakeholders(incident);
        
        // Save incident
        incidentRepository.save(incident);
        
        return incident;
    }
    
    private void containIncident(SecurityIncident incident) {
        // Short-term containment
        if (incident.getSeverity() == IncidentSeverity.CRITICAL) {
            // Immediate containment
            isolateAffectedSystems(incident);
            blockMaliciousIPs(incident);
            disableCompromisedAccounts(incident);
        }
        
        // Long-term containment
        implementTemporaryControls(incident);
        preserveEvidence(incident);
        
        incident.setStatus(IncidentStatus.CONTAINED);
        incidentRepository.save(incident);
    }
    
    private void eradicateThreat(SecurityIncident incident) {
        // Remove malware
        removeMalware(incident);
        
        // Patch vulnerabilities
        patchVulnerabilities(incident);
        
        // Close attack vectors
        closeAttackVectors(incident);
        
        // Verify eradication
        verifyEradication(incident);
        
        incident.setStatus(IncidentStatus.ERADICATED);
        incidentRepository.save(incident);
    }
    
    private void recoverSystems(SecurityIncident incident) {
        // Restore from backups
        restoreSystems(incident);
        
        // Validate functionality
        validateSystems(incident);
        
        // Monitor for recurrence
        monitorForRecurrence(incident);
        
        // Return to normal operations
        returnToNormalOperations(incident);
        
        incident.setStatus(IncidentStatus.RECOVERED);
        incident.setResolvedAt(Instant.now());
        incidentRepository.save(incident);
    }
    
    private void postIncidentActivity(SecurityIncident incident) {
        // Conduct lessons learned
        conductLessonsLearned(incident);
        
        // Update documentation
        updateDocumentation(incident);
        
        // Improve processes
        improveProcesses(incident);
        
        // Update training
        updateTraining(incident);
        
        incident.setStatus(IncidentStatus.CLOSED);
        incidentRepository.save(incident);
    }
}
```

---

## 3. Security Monitoring and Detection

### 3.1 Security Monitoring Architecture

**Monitoring Layers**:

```java
/**
 * Security Monitoring Layers:
 * 
 * Layer 1: Network Monitoring
 *    - Traffic analysis
 *    - Intrusion detection
 *    - DDoS detection
 * 
 * Layer 2: Application Monitoring
 *    - Application logs
 *    - Error tracking
 *    - Performance monitoring
 * 
 * Layer 3: System Monitoring
 *    - System logs
 *    - Process monitoring
 *    - File integrity monitoring
 * 
 * Layer 4: User Activity Monitoring
 *    - Authentication logs
 *    - Access logs
 *    - Behavior analytics
 * 
 * Layer 5: Threat Intelligence
 *    - External threat feeds
 *    - IOC matching
 *    - Threat hunting
 */
```

### 3.2 Security Event Detection

**SIEM Integration**:

```java
@Service
class SecurityEventDetectionService {
    
    @Autowired
    private SIEMService siemService;
    
    @Autowired
    private ThreatIntelligenceService threatIntelligence;
    
    @Autowired
    private AnomalyDetectionService anomalyDetection;
    
    public List<SecurityEvent> detectSecurityEvents() {
        List<SecurityEvent> events = new ArrayList<>();
        
        // Detect suspicious login attempts
        events.addAll(detectSuspiciousLogins());
        
        // Detect privilege escalation
        events.addAll(detectPrivilegeEscalation());
        
        // Detect data exfiltration
        events.addAll(detectDataExfiltration());
        
        // Detect malware
        events.addAll(detectMalware());
        
        // Detect DDoS
        events.addAll(detectDDoS());
        
        return events;
    }
    
    private List<SecurityEvent> detectSuspiciousLogins() {
        List<SecurityEvent> events = new ArrayList<>();
        
        // Multiple failed login attempts
        List<LoginAttempt> failedAttempts = siemService.getFailedLoginAttempts(
            Duration.ofMinutes(15));
        
        Map<String, Long> attemptsByUser = failedAttempts.stream()
            .collect(Collectors.groupingBy(LoginAttempt::getUsername, Collectors.counting()));
        
        attemptsByUser.entrySet().stream()
            .filter(entry -> entry.getValue() >= 5)
            .forEach(entry -> {
                SecurityEvent event = new SecurityEvent(
                    EventType.SUSPICIOUS_LOGIN,
                    IncidentSeverity.HIGH,
                    "Multiple failed login attempts for user: " + entry.getKey()
                );
                events.add(event);
            });
        
        // Login from unusual location
        List<LoginAttempt> logins = siemService.getRecentLogins(Duration.ofHours(1));
        for (LoginAttempt login : logins) {
            if (isUnusualLocation(login)) {
                SecurityEvent event = new SecurityEvent(
                    EventType.UNUSUAL_LOGIN_LOCATION,
                    IncidentSeverity.MEDIUM,
                    "Login from unusual location: " + login.getIpAddress()
                );
                events.add(event);
            }
        }
        
        return events;
    }
    
    private List<SecurityEvent> detectPrivilegeEscalation() {
        List<SecurityEvent> events = new ArrayList<>();
        
        // Check for privilege escalation attempts
        List<AccessLog> accessLogs = siemService.getAccessLogs(Duration.ofHours(24));
        
        for (AccessLog log : accessLogs) {
            if (log.getAction().equals("GRANT_ROLE") || 
                log.getAction().equals("CHANGE_PERMISSIONS")) {
                SecurityEvent event = new SecurityEvent(
                    EventType.PRIVILEGE_ESCALATION,
                    IncidentSeverity.HIGH,
                    "Privilege escalation attempt by: " + log.getUserId()
                );
                events.add(event);
            }
        }
        
        return events;
    }
    
    private List<SecurityEvent> detectDataExfiltration() {
        List<SecurityEvent> events = new ArrayList<>();
        
        // Detect large data transfers
        List<DataTransfer> transfers = siemService.getDataTransfers(Duration.ofHours(1));
        
        for (DataTransfer transfer : transfers) {
            if (transfer.getSize() > 100 * 1024 * 1024) { // 100MB
                SecurityEvent event = new SecurityEvent(
                    EventType.DATA_EXFILTRATION,
                    IncidentSeverity.CRITICAL,
                    "Large data transfer detected: " + transfer.getSize() + " bytes"
                );
                events.add(event);
            }
        }
        
        return events;
    }
    
    private boolean isUnusualLocation(LoginAttempt login) {
        // Check if IP is from known location
        String userLocation = getUserLocation(login.getUsername());
        String loginLocation = getLocationFromIP(login.getIpAddress());
        
        return !userLocation.equals(loginLocation);
    }
}
```

### 3.3 Threat Intelligence Integration

```java
@Service
class ThreatIntelligenceService {
    
    @Autowired
    private ThreatFeedClient threatFeedClient;
    
    @Autowired
    private IOCRepository iocRepository;
    
    public void checkIOCs(SecurityEvent event) {
        // Get IOCs from threat feeds
        List<IOC> iocs = threatFeedClient.getIOCs();
        
        // Check if event matches any IOC
        for (IOC ioc : iocs) {
            if (matchesIOC(event, ioc)) {
                // Raise alert
                raiseAlert(event, ioc);
            }
        }
    }
    
    private boolean matchesIOC(SecurityEvent event, IOC ioc) {
        // Check IP addresses
        if (ioc.getType() == IOCType.IP_ADDRESS) {
            return event.getSourceIp().equals(ioc.getValue());
        }
        
        // Check domains
        if (ioc.getType() == IOCType.DOMAIN) {
            return event.getDomain().equals(ioc.getValue());
        }
        
        // Check file hashes
        if (ioc.getType() == IOCType.FILE_HASH) {
            return event.getFileHash().equals(ioc.getValue());
        }
        
        return false;
    }
}

enum IOCType {
    IP_ADDRESS, DOMAIN, FILE_HASH, URL, EMAIL
}

class IOC {
    private IOCType type;
    private String value;
    private String source;
    private Instant firstSeen;
    private Instant lastSeen;
    private ThreatLevel threatLevel;
}
```

---

## 4. Security Operations Center (SOC)

### 4.1 SOC Functions

```java
/**
 * SOC Functions:
 * 
 * 1. Monitoring:
 *    - 24/7 security monitoring
 *    - Event correlation
 *    - Alert triage
 * 
 * 2. Detection:
 *    - Threat detection
 *    - Anomaly detection
 *    - IOC matching
 * 
 * 3. Analysis:
 *    - Incident analysis
 *    - Threat analysis
 *    - Root cause analysis
 * 
 * 4. Response:
 *    - Incident response
 *    - Containment
 *    - Eradication
 * 
 * 5. Reporting:
 *    - Security reports
 *    - Metrics and KPIs
 *    - Executive briefings
 */
```

### 4.2 SOC Tools and Technologies

```java
/**
 * SOC Tools Stack:
 * 
 * 1. SIEM (Security Information and Event Management):
 *    - Splunk
 *    - IBM QRadar
 *    - ArcSight
 *    - LogRhythm
 * 
 * 2. Threat Intelligence:
 *    - ThreatConnect
 *    - Recorded Future
 *    - Anomali
 * 
 * 3. Endpoint Detection and Response (EDR):
 *    - CrowdStrike
 *    - Carbon Black
 *    - SentinelOne
 * 
 * 4. Network Detection:
 *    - Wireshark
 *    - Zeek (Bro)
 *    - Suricata
 * 
 * 5. Forensics:
 *    - Volatility
 *    - SIFT
 *    - Autopsy
 */
```

### 4.3 SOC Metrics and KPIs

```java
@Service
class SOCMetricsService {
    
    public SOCMetrics calculateMetrics(Instant startDate, Instant endDate) {
        SOCMetrics metrics = new SOCMetrics();
        
        // Mean Time to Detect (MTTD)
        metrics.setMeanTimeToDetect(calculateMTTD(startDate, endDate));
        
        // Mean Time to Respond (MTTR)
        metrics.setMeanTimeToRespond(calculateMTTR(startDate, endDate));
        
        // Mean Time to Resolve (MTTR)
        metrics.setMeanTimeToResolve(calculateMTTR(startDate, endDate));
        
        // False Positive Rate
        metrics.setFalsePositiveRate(calculateFalsePositiveRate(startDate, endDate));
        
        // Incident Count
        metrics.setIncidentCount(getIncidentCount(startDate, endDate));
        
        // Alert Volume
        metrics.setAlertVolume(getAlertVolume(startDate, endDate));
        
        return metrics;
    }
    
    private Duration calculateMTTD(Instant startDate, Instant endDate) {
        List<SecurityIncident> incidents = incidentRepository
            .findByDetectedAtBetween(startDate, endDate);
        
        long totalSeconds = incidents.stream()
            .mapToLong(incident -> 
                Duration.between(incident.getOccurredAt(), incident.getDetectedAt())
                    .getSeconds())
            .sum();
        
        return Duration.ofSeconds(totalSeconds / incidents.size());
    }
    
    private Duration calculateMTTR(Instant startDate, Instant endDate) {
        List<SecurityIncident> incidents = incidentRepository
            .findByDetectedAtBetween(startDate, endDate);
        
        long totalSeconds = incidents.stream()
            .mapToLong(incident -> 
                Duration.between(incident.getDetectedAt(), incident.getContainedAt())
                    .getSeconds())
            .sum();
        
        return Duration.ofSeconds(totalSeconds / incidents.size());
    }
}

class SOCMetrics {
    private Duration meanTimeToDetect;
    private Duration meanTimeToRespond;
    private Duration meanTimeToResolve;
    private double falsePositiveRate;
    private int incidentCount;
    private int alertVolume;
}
```

---

## 5. Incident Response Playbooks

### 5.1 Data Breach Playbook

```java
@Service
class DataBreachPlaybook {
    
    public void executeDataBreachResponse(SecurityIncident incident) {
        // Step 1: Immediate Containment
        containBreach(incident);
        
        // Step 2: Assess Scope
        BreachScope scope = assessBreachScope(incident);
        
        // Step 3: Notify Stakeholders
        notifyStakeholders(incident, scope);
        
        // Step 4: Regulatory Notification
        if (scope.isPIIExposed()) {
            notifyRegulators(incident, scope);
        }
        
        // Step 5: Customer Notification
        if (scope.requiresCustomerNotification()) {
            notifyCustomers(incident, scope);
        }
        
        // Step 6: Forensics
        conductForensics(incident);
        
        // Step 7: Remediation
        remediateBreach(incident);
        
        // Step 8: Post-Incident
        postIncidentActivity(incident);
    }
    
    private void containBreach(SecurityIncident incident) {
        // Isolate affected systems
        isolateSystems(incident.getAffectedSystems());
        
        // Disable compromised accounts
        disableAccounts(incident.getCompromisedAccounts());
        
        // Block malicious IPs
        blockIPs(incident.getMaliciousIPs());
        
        // Change credentials
        rotateCredentials(incident);
    }
    
    private BreachScope assessBreachScope(SecurityIncident incident) {
        BreachScope scope = new BreachScope();
        
        // Identify affected data
        scope.setAffectedDataTypes(identifyAffectedData(incident));
        
        // Count affected records
        scope.setAffectedRecordCount(countAffectedRecords(incident));
        
        // Identify affected individuals
        scope.setAffectedIndividuals(identifyAffectedIndividuals(incident));
        
        return scope;
    }
    
    private void notifyRegulators(SecurityIncident incident, BreachScope scope) {
        // GDPR: Notify within 72 hours
        if (scope.isGDPRApplicable()) {
            gdprNotificationService.notifySupervisoryAuthority(incident, scope);
        }
        
        // HIPAA: Notify within 60 days
        if (scope.isHIPAAApplicable()) {
            hipaaNotificationService.notifyHHS(incident, scope);
        }
        
        // State regulations
        notifyStateRegulators(incident, scope);
    }
}
```

### 5.2 Ransomware Playbook

```java
@Service
class RansomwarePlaybook {
    
    public void executeRansomwareResponse(SecurityIncident incident) {
        // Step 1: Isolate Affected Systems
        isolateAffectedSystems(incident);
        
        // Step 2: Identify Ransomware Type
        RansomwareType type = identifyRansomwareType(incident);
        
        // Step 3: Assess Impact
        RansomwareImpact impact = assessImpact(incident);
        
        // Step 4: Decision: Pay or Not
        RansomwareDecision decision = makeDecision(incident, type, impact);
        
        if (decision == RansomwareDecision.RESTORE_FROM_BACKUP) {
            // Step 5: Restore from Backup
            restoreFromBackup(incident);
        } else if (decision == RansomwareDecision.PAY_RANSOM) {
            // Step 5: Pay Ransom (last resort)
            payRansom(incident);
        }
        
        // Step 6: Eradicate Ransomware
        eradicateRansomware(incident);
        
        // Step 7: Restore Systems
        restoreSystems(incident);
        
        // Step 8: Post-Incident
        postIncidentActivity(incident);
    }
    
    private RansomwareDecision makeDecision(SecurityIncident incident, 
                                           RansomwareType type, 
                                           RansomwareImpact impact) {
        // Decision criteria:
        // 1. Backup availability
        // 2. Business impact
        // 3. Ransom amount
        // 4. Decryption key availability
        
        if (hasRecentBackup(incident)) {
            return RansomwareDecision.RESTORE_FROM_BACKUP;
        }
        
        if (impact.getBusinessImpact() == BusinessImpact.CRITICAL && 
            impact.getRansomAmount() < 100000) {
            // Consider paying only if critical and amount is reasonable
            return RansomwareDecision.PAY_RANSOM;
        }
        
        return RansomwareDecision.DO_NOT_PAY;
    }
}
```

### 5.3 DDoS Attack Playbook

```java
@Service
class DDoSPlaybook {
    
    public void executeDDoSResponse(SecurityIncident incident) {
        // Step 1: Detect DDoS
        DDoSCharacteristics characteristics = analyzeDDoS(incident);
        
        // Step 2: Activate DDoS Protection
        activateDDoSProtection(characteristics);
        
        // Step 3: Scale Resources
        scaleResources(characteristics);
        
        // Step 4: Block Malicious Traffic
        blockMaliciousTraffic(characteristics);
        
        // Step 5: Monitor and Adjust
        monitorAndAdjust(incident);
        
        // Step 6: Post-Incident
        postIncidentActivity(incident);
    }
    
    private void activateDDoSProtection(DDoSCharacteristics characteristics) {
        // Activate CDN DDoS protection
        cdnService.enableDDoSProtection();
        
        // Activate WAF rules
        wafService.enableDDoSRules();
        
        // Activate rate limiting
        rateLimitingService.enableAggressiveRateLimiting();
    }
    
    private void scaleResources(DDoSCharacteristics characteristics) {
        // Auto-scale application servers
        autoScalingService.scaleUp(characteristics.getTrafficVolume());
        
        // Scale load balancers
        loadBalancerService.scaleUp();
        
        // Scale database connections
        databaseService.scaleConnections();
    }
    
    private void blockMaliciousTraffic(DDoSCharacteristics characteristics) {
        // Block source IPs
        for (String ip : characteristics.getSourceIPs()) {
            firewallService.blockIP(ip);
        }
        
        // Block geographic regions if applicable
        if (characteristics.isGeographic()) {
            firewallService.blockRegion(characteristics.getRegion());
        }
    }
}
```

---

## 6. Post-Incident Activities

### 6.1 Lessons Learned Process

```java
@Service
class LessonsLearnedService {
    
    public LessonsLearned conductLessonsLearned(SecurityIncident incident) {
        LessonsLearned lessons = new LessonsLearned();
        
        // What went well?
        lessons.setWhatWentWell(identifySuccesses(incident));
        
        // What went wrong?
        lessons.setWhatWentWrong(identifyFailures(incident));
        
        // What could be improved?
        lessons.setImprovements(identifyImprovements(incident));
        
        // Root cause analysis
        lessons.setRootCause(conductRootCauseAnalysis(incident));
        
        // Action items
        lessons.setActionItems(createActionItems(incident, lessons));
        
        // Update documentation
        updateDocumentation(lessons);
        
        // Update training
        updateTraining(lessons);
        
        return lessons;
    }
    
    private List<String> identifySuccesses(SecurityIncident incident) {
        List<String> successes = new ArrayList<>();
        
        // Fast detection
        if (incident.getDetectionTime() < Duration.ofMinutes(15)) {
            successes.add("Fast incident detection");
        }
        
        // Effective containment
        if (incident.getContainmentTime() < Duration.ofHours(1)) {
            successes.add("Quick containment");
        }
        
        // Good communication
        if (incident.getCommunicationScore() > 8) {
            successes.add("Effective communication");
        }
        
        return successes;
    }
    
    private List<String> identifyFailures(SecurityIncident incident) {
        List<String> failures = new ArrayList<>();
        
        // Slow detection
        if (incident.getDetectionTime() > Duration.ofHours(24)) {
            failures.add("Slow incident detection");
        }
        
        // Inadequate monitoring
        if (!incident.wasDetectedByMonitoring()) {
            failures.add("Inadequate security monitoring");
        }
        
        // Poor response
        if (incident.getResponseTime() > Duration.ofHours(4)) {
            failures.add("Slow incident response");
        }
        
        return failures;
    }
    
    private List<ActionItem> createActionItems(SecurityIncident incident, 
                                               LessonsLearned lessons) {
        List<ActionItem> actionItems = new ArrayList<>();
        
        // Improve detection
        if (lessons.getWhatWentWrong().contains("Slow incident detection")) {
            actionItems.add(new ActionItem(
                "Improve security monitoring",
                "Implement additional monitoring tools",
                Priority.HIGH,
                Duration.ofDays(30)
            ));
        }
        
        // Update playbooks
        actionItems.add(new ActionItem(
            "Update incident response playbooks",
            "Incorporate lessons learned",
            Priority.MEDIUM,
            Duration.ofDays(14)
        ));
        
        // Training
        actionItems.add(new ActionItem(
            "Conduct incident response training",
            "Train team on updated procedures",
            Priority.MEDIUM,
            Duration.ofDays(60)
        ));
        
        return actionItems;
    }
}
```

### 6.2 Incident Documentation

```java
@Entity
class IncidentReport {
    @Id
    private String id;
    
    private String incidentId;
    private String title;
    private String executiveSummary;
    private String detailedDescription;
    private IncidentTimeline timeline;
    private BreachScope scope;
    private RootCauseAnalysis rootCause;
    private LessonsLearned lessonsLearned;
    private List<ActionItem> actionItems;
    private List<String> recommendations;
    private Instant createdAt;
    private String createdBy;
}

class IncidentTimeline {
    private List<TimelineEvent> events = new ArrayList<>();
    
    public void addEvent(String time, String event, String description) {
        events.add(new TimelineEvent(time, event, description));
    }
}

class TimelineEvent {
    private String time;
    private String event;
    private String description;
}
```

---

## 7. Practical Examples

### 7.1 Complete Incident Response System

```java
@RestController
@RequestMapping("/api/incidents")
class IncidentResponseController {
    
    @Autowired
    private IncidentResponseService incidentResponseService;
    
    @PostMapping("/detect")
    public ResponseEntity<SecurityIncident> detectIncident(
            @RequestBody IncidentDetection detection) {
        SecurityIncident incident = incidentResponseService.handleIncident(detection);
        return ResponseEntity.ok(incident);
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<SecurityIncident> getIncident(@PathVariable String id) {
        SecurityIncident incident = incidentResponseService.getIncident(id);
        return ResponseEntity.ok(incident);
    }
    
    @PostMapping("/{id}/contain")
    public ResponseEntity<Void> containIncident(@PathVariable String id) {
        incidentResponseService.containIncident(id);
        return ResponseEntity.ok().build();
    }
    
    @PostMapping("/{id}/eradicate")
    public ResponseEntity<Void> eradicateIncident(@PathVariable String id) {
        incidentResponseService.eradicateIncident(id);
        return ResponseEntity.ok().build();
    }
    
    @PostMapping("/{id}/recover")
    public ResponseEntity<Void> recoverIncident(@PathVariable String id) {
        incidentResponseService.recoverIncident(id);
        return ResponseEntity.ok().build();
    }
    
    @PostMapping("/{id}/close")
    public ResponseEntity<Void> closeIncident(@PathVariable String id) {
        incidentResponseService.closeIncident(id);
        return ResponseEntity.ok().build();
    }
}
```

### 7.2 Security Monitoring Dashboard

```java
@RestController
@RequestMapping("/api/security/dashboard")
class SecurityDashboardController {
    
    @Autowired
    private SecurityMonitoringService monitoringService;
    
    @Autowired
    private SOCMetricsService metricsService;
    
    @GetMapping("/metrics")
    public ResponseEntity<SOCMetrics> getMetrics(
            @RequestParam Instant startDate,
            @RequestParam Instant endDate) {
        SOCMetrics metrics = metricsService.calculateMetrics(startDate, endDate);
        return ResponseEntity.ok(metrics);
    }
    
    @GetMapping("/events")
    public ResponseEntity<List<SecurityEvent>> getRecentEvents(
            @RequestParam(defaultValue = "24") int hours) {
        List<SecurityEvent> events = monitoringService.getRecentEvents(
            Duration.ofHours(hours));
        return ResponseEntity.ok(events);
    }
    
    @GetMapping("/incidents")
    public ResponseEntity<List<SecurityIncident>> getActiveIncidents() {
        List<SecurityIncident> incidents = monitoringService.getActiveIncidents();
        return ResponseEntity.ok(incidents);
    }
    
    @GetMapping("/threats")
    public ResponseEntity<List<Threat>> getActiveThreats() {
        List<Threat> threats = monitoringService.getActiveThreats();
        return ResponseEntity.ok(threats);
    }
}
```

---

## Summary: Part 5

### Key Concepts

1. **Incident Response**: Organized approach to managing security incidents
2. **NIST Lifecycle**: Preparation, Detection, Containment, Eradication, Recovery, Post-Incident
3. **Security Monitoring**: Multi-layer monitoring and detection
4. **SOC Operations**: 24/7 security operations center
5. **Playbooks**: Standardized response procedures
6. **Post-Incident**: Lessons learned and continuous improvement

### Key Metrics

- **MTTD** (Mean Time to Detect): How quickly incidents are detected
- **MTTR** (Mean Time to Respond): How quickly incidents are responded to
- **MTTR** (Mean Time to Resolve): How quickly incidents are resolved
- **False Positive Rate**: Percentage of false alarms

### Best Practices

1. **Prepare**: Have incident response plan ready
2. **Detect Quickly**: Implement comprehensive monitoring
3. **Respond Fast**: Automated response where possible
4. **Document Everything**: Maintain detailed incident records
5. **Learn and Improve**: Continuous improvement based on lessons learned

---

**Master incident response and security operations to protect your organization!**

