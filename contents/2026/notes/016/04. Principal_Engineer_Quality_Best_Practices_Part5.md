# Principal Engineer: Mastering Quality and Best Practices Enforcement

## Part 5: Refactoring Techniques

---

## Table of Contents

1. [Refactoring Fundamentals](#1-refactoring-fundamentals)
2. [When to Refactor](#2-when-to-refactor)
3. [Refactoring Techniques](#3-refactoring-techniques)
4. [Safe Refactoring Practices](#4-safe-refactoring-practices)
5. [Refactoring Patterns](#5-refactoring-patterns)
6. [Large-Scale Refactoring](#6-large-scale-refactoring)
7. [Practical Examples](#7-practical-examples)

---

## 1. Refactoring Fundamentals

### 1.1 What is Refactoring?

**Definition**: Improving code structure without changing behavior

**Key Principles**:
- **Behavior Preserved**: Functionality remains the same
- **Small Steps**: Make small, incremental changes
- **Tests First**: Have tests before refactoring
- **Continuous**: Refactor as you go

### 1.2 Why Refactor?

**Benefits**:
- **Maintainability**: Easier to understand and modify
- **Readability**: Clearer code
- **Performance**: Can improve performance
- **Technical Debt**: Reduces accumulated debt
- **Quality**: Improves code quality

**Impact**:
- 40% improvement in code maintainability
- Faster feature development
- Reduced bugs
- Better team velocity

---

## 2. When to Refactor

### 2.1 Refactoring Triggers

**Code Smells**:
```java
/**
 * Code Smells Indicating Need for Refactoring:
 * 
 * 1. Duplicated Code:
 *    - Same code in multiple places
 *    - Copy-paste programming
 * 
 * 2. Long Methods:
 *    - Methods > 50 lines
 *    - Hard to understand
 * 
 * 3. Large Classes:
 *    - Classes > 500 lines
 *    - Multiple responsibilities
 * 
 * 4. Long Parameter Lists:
 *    - Methods with > 5 parameters
 *    - Hard to use and maintain
 * 
 * 5. Feature Envy:
 *    - Method uses another class more than its own
 *    - Indicates misplaced logic
 * 
 * 6. Data Clumps:
 *    - Same data passed together
 *    - Should be an object
 * 
 * 7. Primitive Obsession:
 *    - Using primitives instead of objects
 *    - Missing domain concepts
 * 
 * 8. Switch Statements:
 *    - Multiple switch statements
 *    - Should use polymorphism
 */
```

### 2.2 Refactoring Opportunities

**1. Before Adding Features**
```java
// Before adding new feature, refactor to make it easier
class OrderService {
    // Refactor existing code to support new feature
    public void processOrder(Order order) {
        // Existing logic
    }
    
    // New feature will be easier to add after refactoring
}
```

**2. When Fixing Bugs**
```java
// While fixing bug, refactor to prevent similar bugs
class UserService {
    // Fix bug and improve code structure
    public void updateUser(User user) {
        // Refactored to be clearer and less error-prone
    }
}
```

**3. During Code Reviews**
```java
// Refactor based on review feedback
class PaymentService {
    // Address review comments through refactoring
    // Improve code quality
}
```

**4. When Understanding Code**
```java
// Refactor to understand legacy code
class LegacyService {
    // Refactor while learning what it does
    // Makes it easier for others to understand
}
```

---

## 3. Refactoring Techniques

### 3.1 Extract Method

**Before**:
```java
public void printOrder(Order order) {
    System.out.println("Order Details:");
    System.out.println("ID: " + order.getId());
    System.out.println("Customer: " + order.getCustomer().getName());
    System.out.println("Total: $" + order.getTotal());
    System.out.println("Status: " + order.getStatus());
    
    System.out.println("Items:");
    for (OrderItem item : order.getItems()) {
        System.out.println("  - " + item.getName() + ": $" + item.getPrice());
    }
}
```

**After**:
```java
public void printOrder(Order order) {
    printOrderHeader(order);
    printOrderItems(order);
}

private void printOrderHeader(Order order) {
    System.out.println("Order Details:");
    System.out.println("ID: " + order.getId());
    System.out.println("Customer: " + order.getCustomer().getName());
    System.out.println("Total: $" + order.getTotal());
    System.out.println("Status: " + order.getStatus());
}

private void printOrderItems(Order order) {
    System.out.println("Items:");
    for (OrderItem item : order.getItems()) {
        System.out.println("  - " + item.getName() + ": $" + item.getPrice());
    }
}
```

### 3.2 Extract Variable

**Before**:
```java
public double calculateTotal(List<OrderItem> items) {
    return items.stream()
        .mapToDouble(item -> item.getPrice() * item.getQuantity() * (1 - item.getDiscount()))
        .sum() * 1.1;  // Magic number
}
```

**After**:
```java
public double calculateTotal(List<OrderItem> items) {
    final double TAX_RATE = 0.1;
    
    double subtotal = items.stream()
        .mapToDouble(item -> {
            double itemPrice = item.getPrice() * item.getQuantity();
            double discountAmount = itemPrice * item.getDiscount();
            return itemPrice - discountAmount;
        })
        .sum();
    
    double tax = subtotal * TAX_RATE;
    return subtotal + tax;
}
```

### 3.3 Extract Class

**Before**:
```java
class Order {
    private String id;
    private String customerName;
    private String customerEmail;
    private String customerPhone;
    private String shippingAddress;
    private String shippingCity;
    private String shippingState;
    private String shippingZip;
    // ... many more fields
}
```

**After**:
```java
class Order {
    private String id;
    private Customer customer;
    private Address shippingAddress;
    // ... other fields
}

class Customer {
    private String name;
    private String email;
    private String phone;
}

class Address {
    private String street;
    private String city;
    private String state;
    private String zipCode;
}
```

### 3.4 Inline Method

**Before**:
```java
public double calculatePrice(double basePrice) {
    return applyDiscount(basePrice);
}

private double applyDiscount(double price) {
    return price * 0.9;  // Simple method, can be inlined
}
```

**After**:
```java
public double calculatePrice(double basePrice) {
    return basePrice * 0.9;
}
```

### 3.5 Move Method

**Before**:
```java
class Order {
    private List<OrderItem> items;
    
    public double calculateTotal() {
        double total = 0;
        for (OrderItem item : items) {
            total += item.getPrice() * item.getQuantity();
        }
        return total;
    }
}

class OrderItem {
    private String name;
    private double price;
    private int quantity;
}
```

**After**:
```java
class Order {
    private List<OrderItem> items;
    
    public double calculateTotal() {
        return items.stream()
            .mapToDouble(OrderItem::getSubtotal)
            .sum();
    }
}

class OrderItem {
    private String name;
    private double price;
    private int quantity;
    
    public double getSubtotal() {
        return price * quantity;
    }
}
```

### 3.6 Replace Magic Number with Constant

**Before**:
```java
public double calculateDiscount(double total) {
    if (total > 1000) {
        return total * 0.1;
    } else if (total > 500) {
        return total * 0.05;
    }
    return 0;
}
```

**After**:
```java
class DiscountCalculator {
    private static final double HIGH_THRESHOLD = 1000.0;
    private static final double MEDIUM_THRESHOLD = 500.0;
    private static final double HIGH_DISCOUNT_RATE = 0.1;
    private static final double MEDIUM_DISCOUNT_RATE = 0.05;
    
    public double calculateDiscount(double total) {
        if (total > HIGH_THRESHOLD) {
            return total * HIGH_DISCOUNT_RATE;
        } else if (total > MEDIUM_THRESHOLD) {
            return total * MEDIUM_DISCOUNT_RATE;
        }
        return 0;
    }
}
```

### 3.7 Replace Conditional with Polymorphism

**Before**:
```java
class OrderProcessor {
    public void process(Order order, String type) {
        if ("STANDARD".equals(type)) {
            processStandard(order);
        } else if ("EXPRESS".equals(type)) {
            processExpress(order);
        } else if ("PRIORITY".equals(type)) {
            processPriority(order);
        }
    }
}
```

**After**:
```java
interface OrderProcessor {
    void process(Order order);
}

class StandardOrderProcessor implements OrderProcessor {
    @Override
    public void process(Order order) {
        // Standard processing
    }
}

class ExpressOrderProcessor implements OrderProcessor {
    @Override
    public void process(Order order) {
        // Express processing
    }
}

class PriorityOrderProcessor implements OrderProcessor {
    @Override
    public void process(Order order) {
        // Priority processing
    }
}

// Usage
OrderProcessor processor = processorFactory.create(order.getType());
processor.process(order);
```

### 3.8 Introduce Parameter Object

**Before**:
```java
public void createUser(String firstName, String lastName, String email, 
                      String phone, String address, String city, 
                      String state, String zipCode) {
    // Too many parameters
}
```

**After**:
```java
public void createUser(UserRequest request) {
    // Cleaner with parameter object
}

class UserRequest {
    private String firstName;
    private String lastName;
    private String email;
    private String phone;
    private Address address;
}
```

### 3.9 Replace Exception with Return Value

**Before**:
```java
public User getUser(String id) throws UserNotFoundException {
    User user = userRepository.findById(id);
    if (user == null) {
        throw new UserNotFoundException(id);
    }
    return user;
}
```

**After**:
```java
public Optional<User> getUser(String id) {
    return userRepository.findById(id);
}

// Usage
Optional<User> user = userService.getUser(id);
if (user.isPresent()) {
    // Handle user
} else {
    // Handle not found
}
```

### 3.10 Extract Superclass

**Before**:
```java
class Dog {
    private String name;
    private int age;
    
    public void eat() { }
    public void sleep() { }
    public void bark() { }
}

class Cat {
    private String name;
    private int age;
    
    public void eat() { }
    public void sleep() { }
    public void meow() { }
}
```

**After**:
```java
abstract class Animal {
    protected String name;
    protected int age;
    
    public void eat() { }
    public void sleep() { }
    
    public abstract void makeSound();
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        bark();
    }
    
    public void bark() { }
}

class Cat extends Animal {
    @Override
    public void makeSound() {
        meow();
    }
    
    public void meow() { }
}
```

---

## 4. Safe Refactoring Practices

### 4.1 Test-First Refactoring

**Process**:
```
1. Write tests for existing behavior
   â†“
2. Run tests to ensure they pass
   â†“
3. Refactor code
   â†“
4. Run tests to ensure behavior unchanged
   â†“
5. Repeat
```

**Example**:
```java
// Step 1: Write tests
@Test
void testCalculateTotal_WithItems_ReturnsCorrectTotal() {
    List<OrderItem> items = Arrays.asList(
        new OrderItem("item1", 10.0, 2),
        new OrderItem("item2", 20.0, 1)
    );
    double total = calculator.calculateTotal(items);
    assertEquals(40.0, total, 0.01);
}

// Step 2: Refactor
// Step 3: Run tests - should still pass
```

### 4.2 Small Steps

**Principle**: Make small, incremental changes

**Bad**:
```java
// Refactoring entire class at once - risky
class OrderService {
    // Massive refactoring
}
```

**Good**:
```java
// Small, incremental refactoring
// Step 1: Extract one method
// Step 2: Extract another method
// Step 3: Extract class
// etc.
```

### 4.3 Version Control

**Best Practices**:
```java
/**
 * Version Control for Refactoring:
 * 
 * 1. Commit frequently:
 *    - Small, logical commits
 *    - Clear commit messages
 * 
 * 2. Separate refactoring from features:
 *    - Don't mix refactoring with new features
 *    - Easier to review and rollback
 * 
 * 3. Use branches:
 *    - Refactoring branch
 *    - Test thoroughly before merging
 */
```

### 4.4 Refactoring Checklist

```java
/**
 * Refactoring Checklist:
 * 
 * Before Refactoring:
 * â–¡ Tests exist and pass
 * â–¡ Understand current code
 * â–¡ Identify what to refactor
 * â–¡ Plan refactoring steps
 * 
 * During Refactoring:
 * â–¡ Make small changes
 * â–¡ Run tests after each change
 * â–¡ Commit frequently
 * â–¡ Keep behavior unchanged
 * 
 * After Refactoring:
 * â–¡ All tests pass
 * â–¡ Code is cleaner
 * â–¡ No new bugs introduced
 * â–¡ Documentation updated
 */
```

---

## 5. Refactoring Patterns

### 5.1 Extract Method Pattern

**When to Use**:
- Long method (> 20 lines)
- Duplicated code
- Complex logic

**Steps**:
1. Identify code to extract
2. Create new method
3. Replace code with method call
4. Test

### 5.2 Extract Class Pattern

**When to Use**:
- Large class (> 500 lines)
- Multiple responsibilities
- Related data and methods

**Steps**:
1. Identify what to extract
2. Create new class
3. Move fields and methods
4. Update references
5. Test

### 5.3 Replace Conditional with Strategy

**When to Use**:
- Multiple if/switch statements
- Similar logic with variations
- Need to add new types

**Steps**:
1. Create strategy interface
2. Implement strategies
3. Replace conditionals
4. Test

### 5.4 Introduce Null Object

**When to Use**:
- Null checks everywhere
- Default behavior needed

**Steps**:
1. Create null object class
2. Replace null checks
3. Test

---

## 6. Large-Scale Refactoring

### 6.1 Strangler Fig Pattern

**Approach**: Gradually replace legacy code

**Process**:
```
1. Identify feature to extract
   â†“
2. Build new implementation
   â†“
3. Route traffic to new code
   â†“
4. Monitor and verify
   â†“
5. Remove old code
   â†“
6. Repeat
```

**Example**:
```java
// Legacy code
class LegacyOrderService {
    public void processOrder(Order order) {
        // Old implementation
    }
}

// New implementation
class NewOrderService {
    public void processOrder(Order order) {
        // New, improved implementation
    }
}

// Router
class OrderServiceRouter {
    private LegacyOrderService legacyService;
    private NewOrderService newService;
    private boolean useNewService = false;  // Feature flag
    
    public void processOrder(Order order) {
        if (useNewService) {
            newService.processOrder(order);
        } else {
            legacyService.processOrder(order);
        }
    }
}
```

### 6.2 Branch by Abstraction

**Approach**: Create abstraction layer

**Process**:
```
1. Create abstraction
   â†“
2. Implement new version behind abstraction
   â†“
3. Switch implementation via feature flag
   â†“
4. Remove old implementation
```

**Example**:
```java
// Abstraction
interface PaymentProcessor {
    PaymentResult process(PaymentRequest request);
}

// Old implementation
class OldPaymentProcessor implements PaymentProcessor {
    // Old code
}

// New implementation
class NewPaymentProcessor implements PaymentProcessor {
    // New code
}

// Factory with feature flag
class PaymentProcessorFactory {
    public PaymentProcessor create() {
        if (featureFlags.isNewPaymentEnabled()) {
            return new NewPaymentProcessor();
        }
        return new OldPaymentProcessor();
    }
}
```

---

## 7. Practical Examples

### 7.1 Complete Refactoring Example

**Before**:
```java
class OrderService {
    public void processOrder(Order order) {
        if (order.getStatus().equals("PENDING")) {
            if (order.getTotal() > 1000) {
                order.setDiscount(0.1);
            } else if (order.getTotal() > 500) {
                order.setDiscount(0.05);
            }
            
            double finalTotal = order.getTotal() * (1 - order.getDiscount());
            order.setTotal(finalTotal);
            
            if (order.getPaymentMethod().equals("CREDIT_CARD")) {
                // Process credit card
                CreditCardProcessor processor = new CreditCardProcessor();
                processor.process(order);
            } else if (order.getPaymentMethod().equals("PAYPAL")) {
                // Process PayPal
                PayPalProcessor processor = new PayPalProcessor();
                processor.process(order);
            }
            
            order.setStatus("PROCESSED");
            orderRepository.save(order);
            
            EmailService email = new EmailService();
            email.send(order.getCustomer().getEmail(), "Order processed");
        }
    }
}
```

**After**:
```java
@Service
class OrderService {
    
    private final OrderRepository orderRepository;
    private final DiscountCalculator discountCalculator;
    private final PaymentProcessorFactory paymentProcessorFactory;
    private final NotificationService notificationService;
    
    public OrderService(OrderRepository orderRepository,
                        DiscountCalculator discountCalculator,
                        PaymentProcessorFactory paymentProcessorFactory,
                        NotificationService notificationService) {
        this.orderRepository = orderRepository;
        this.discountCalculator = discountCalculator;
        this.paymentProcessorFactory = paymentProcessorFactory;
        this.notificationService = notificationService;
    }
    
    @Transactional
    public void processOrder(Order order) {
        if (order.getStatus() != OrderStatus.PENDING) {
            return;
        }
        
        applyDiscount(order);
        processPayment(order);
        order.setStatus(OrderStatus.PROCESSED);
        orderRepository.save(order);
        notificationService.sendOrderConfirmation(order);
    }
    
    private void applyDiscount(Order order) {
        double discount = discountCalculator.calculateDiscount(order.getTotal());
        order.applyDiscount(discount);
    }
    
    private void processPayment(Order order) {
        PaymentProcessor processor = paymentProcessorFactory.create(order.getPaymentMethod());
        processor.process(order);
    }
}

class DiscountCalculator {
    private static final double HIGH_THRESHOLD = 1000.0;
    private static final double MEDIUM_THRESHOLD = 500.0;
    private static final double HIGH_DISCOUNT = 0.1;
    private static final double MEDIUM_DISCOUNT = 0.05;
    
    public double calculateDiscount(double total) {
        if (total > HIGH_THRESHOLD) {
            return HIGH_DISCOUNT;
        } else if (total > MEDIUM_THRESHOLD) {
            return MEDIUM_DISCOUNT;
        }
        return 0.0;
    }
}
```

### 7.2 Refactoring Workflow

```java
/**
 * Refactoring Workflow:
 * 
 * 1. Identify Refactoring Need:
 *    - Code smell detected
 *    - Feature addition blocked
 *    - Bug fix opportunity
 * 
 * 2. Plan Refactoring:
 *    - Understand current code
 *    - Identify refactoring techniques
 *    - Plan small steps
 * 
 * 3. Write/Update Tests:
 *    - Ensure tests cover behavior
 *    - Tests should pass before refactoring
 * 
 * 4. Execute Refactoring:
 *    - Make small changes
 *    - Run tests frequently
 *    - Commit often
 * 
 * 5. Verify:
 *    - All tests pass
 *    - Code is improved
 *    - No regressions
 * 
 * 6. Review:
 *    - Code review
 *    - Get feedback
 *    - Iterate if needed
 */
```

---

## Summary: Complete Quality and Best Practices Guide

### All Parts Covered

**Part 1**: Code Quality Metrics and Tools
- Cyclomatic complexity, coverage, duplication
- SonarQube, SpotBugs, Checkstyle, PMD
- Quality gates and standards

**Part 2**: Design Patterns and Anti-Patterns
- Essential patterns (Repository, Service Layer, Strategy, etc.)
- Anti-patterns to avoid (God Class, Anemic Model, etc.)
- Pattern selection and enforcement

**Part 3**: Testing Strategies
- Unit, Integration, E2E testing
- Test-driven development
- Testing best practices

**Part 4**: Code Review Processes
- Review best practices
- Review checklists
- Review tools and metrics

**Part 5**: Refactoring Techniques
- Refactoring fundamentals
- Common refactoring techniques
- Safe refactoring practices

### Key Impact Metrics

- **50% reduction** in code review time
- **40% improvement** in code maintainability
- **70% reduction** in production bugs

### Mastery Checklist

```java
/**
 * Principal Engineer Quality Mastery:
 * 
 * Code Quality:
 * â–¡ Understand and apply quality metrics
 * â–¡ Use static analysis tools effectively
 * â–¡ Establish quality gates
 * 
 * Design Patterns:
 * â–¡ Know when to use patterns
 * â–¡ Recognize and avoid anti-patterns
 * â–¡ Enforce pattern usage
 * 
 * Testing:
 * â–¡ Write comprehensive tests
 * â–¡ Apply TDD when appropriate
 * â–¡ Maintain high coverage
 * 
 * Code Review:
 * â–¡ Conduct effective reviews
 * â–¡ Provide constructive feedback
 * â–¡ Use review tools efficiently
 * 
 * Refactoring:
 * â–¡ Refactor safely and effectively
 * â–¡ Recognize refactoring opportunities
 * â–¡ Apply refactoring techniques
 */
```

---

**Master these skills to become an expert in Quality and Best Practices Enforcement!**

**Remember**:
- **Quality is not optional** - It's essential
- **Continuous improvement** - Always strive for better
- **Lead by example - Show others how it's done
- **Measure and improve** - Track metrics and improve processes

**You now have a complete guide to mastering Quality and Best Practices Enforcement!** ðŸš€

