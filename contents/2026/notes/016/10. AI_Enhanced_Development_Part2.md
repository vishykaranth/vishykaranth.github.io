# AI-Enhanced Development and Modern Practices: Master Guide for Principal Engineers

## Part 2: Prompt Engineering for Code Generation

---

## Table of Contents

1. [Fundamentals of Prompt Engineering](#1-fundamentals-of-prompt-engineering)
2. [Prompt Patterns and Templates](#2-prompt-patterns-and-templates)
3. [Context Management](#3-context-management)
4. [Advanced Prompting Techniques](#4-advanced-prompting-techniques)
5. [Domain-Specific Prompts](#5-domain-specific-prompts)
6. [Prompt Optimization](#6-prompt-optimization)

---

## 1. Fundamentals of Prompt Engineering

### 1.1 What is Prompt Engineering?

**Definition**: Prompt engineering is the art and science of crafting inputs (prompts) to AI models to get the desired outputs. For code generation, it's about writing prompts that produce high-quality, correct, and maintainable code.

### 1.2 Why Prompt Engineering Matters

**Impact on Code Quality**:
- **Clear prompts** → Better code suggestions
- **Context-rich prompts** → More accurate implementations
- **Structured prompts** → Consistent code style
- **Iterative prompts** → Refined solutions

### 1.3 Core Principles

**Principle 1: Clarity**
```
BAD: "Make a service"
GOOD: "Create a Spring Boot service class that manages user authentication, 
      validates JWT tokens, and integrates with a user repository"
```

**Principle 2: Context**
```
BAD: "Write a function"
GOOD: "In a Spring Boot microservice for an e-commerce platform, 
      write a function that calculates order total including tax and shipping, 
      applies discount codes, and handles edge cases like negative values"
```

**Principle 3: Specificity**
```
BAD: "Add error handling"
GOOD: "Add comprehensive error handling with:
      - Custom exceptions for business logic errors
      - Proper HTTP status codes (400 for validation, 404 for not found)
      - Error response DTOs with error codes and messages
      - Logging of all errors with appropriate levels"
```

**Principle 4: Structure**
```
BAD: "Do everything"
GOOD: "Step 1: Create entity class
      Step 2: Create repository interface
      Step 3: Create service class with business logic
      Step 4: Create REST controller
      Step 5: Add unit tests"
```

---

## 2. Prompt Patterns and Templates

### 2.1 Code Generation Pattern

**Template Structure**:
```
CONTEXT: [Technology stack, framework, domain]
REQUIREMENT: [What needs to be built]
CONSTRAINTS: [Limitations, requirements]
OUTPUT FORMAT: [Code structure, style]
EXAMPLES: [Similar code if available]
```

**Example**:
```
CONTEXT: Spring Boot 3.x microservice, Java 17, PostgreSQL database
REQUIREMENT: Create a complete REST API for product management
CONSTRAINTS: 
  - Use JPA for persistence
  - Implement pagination for list endpoints
  - Add input validation
  - Include error handling
  - Follow RESTful conventions
OUTPUT FORMAT: 
  - Entity class with JPA annotations
  - Repository interface extending JpaRepository
  - Service class with business logic
  - REST controller with CRUD operations
  - DTOs for request/response
  - Exception handling
EXAMPLES: [Reference existing UserController if available]
```

### 2.2 Refactoring Pattern

**Template**:
```
REFACTORING TASK: [What needs to be refactored]
CURRENT CODE: [Paste existing code]
GOALS: [What to achieve]
CONSTRAINTS: [What must be maintained]
OUTPUT: [Expected result]
```

**Example**:
```
REFACTORING TASK: Refactor this service class to follow SOLID principles
CURRENT CODE:
[Paste code]
GOALS:
  - Single Responsibility Principle
  - Dependency Injection
  - Better testability
  - Improved error handling
CONSTRAINTS:
  - Maintain backward compatibility
  - Keep existing API contracts
  - Preserve business logic
OUTPUT: Refactored code with explanations
```

### 2.3 Test Generation Pattern

**Template**:
```
TEST REQUIREMENTS: [What to test]
CODE UNDER TEST: [Paste code]
TEST FRAMEWORK: [JUnit, TestNG, etc.]
COVERAGE GOALS: [What scenarios to cover]
OUTPUT: [Test class with all test cases]
```

**Example**:
```
TEST REQUIREMENTS: Create comprehensive unit tests for OrderService
CODE UNDER TEST:
[Paste OrderService code]
TEST FRAMEWORK: JUnit 5, Mockito
COVERAGE GOALS:
  - Happy path scenarios
  - Edge cases (null inputs, empty collections)
  - Error scenarios (validation failures, exceptions)
  - Boundary conditions
  - Integration with mocked dependencies
OUTPUT: Complete test class with:
  - Setup methods
  - Test methods with descriptive names
  - Assertions
  - Mock verifications
```

### 2.4 Documentation Pattern

**Template**:
```
DOCUMENTATION TYPE: [API docs, code comments, README]
CODE TO DOCUMENT: [Paste code]
AUDIENCE: [Developers, users, etc.]
FORMAT: [JavaDoc, Markdown, OpenAPI, etc.]
LEVEL OF DETAIL: [Brief, comprehensive]
```

**Example**:
```
DOCUMENTATION TYPE: JavaDoc comments and API documentation
CODE TO DOCUMENT:
[Paste service class]
AUDIENCE: Other developers on the team
FORMAT: JavaDoc with OpenAPI annotations
LEVEL OF DETAIL: Comprehensive
Include:
  - Class-level documentation
  - Method documentation with parameters and return values
  - Example usage
  - Exception documentation
  - Thread safety notes
```

---

## 3. Context Management

### 3.1 Why Context Matters

**Context provides**:
- **Technology stack**: Framework, language version, libraries
- **Domain knowledge**: Business rules, constraints
- **Architecture**: Patterns, design decisions
- **Existing code**: Style, conventions, patterns

### 3.2 Building Context

**Step 1: Technology Stack**
```
I'm working with:
- Java 17
- Spring Boot 3.2
- Spring Data JPA
- PostgreSQL 15
- Redis for caching
- JUnit 5 and Mockito for testing
```

**Step 2: Domain Context**
```
This is an e-commerce platform where:
- Users can create orders
- Orders contain multiple items
- Each item has quantity and price
- Orders can have discount codes
- Orders must be paid before shipping
- Inventory must be checked before order creation
```

**Step 3: Architecture Context**
```
The system follows:
- Microservices architecture
- RESTful APIs
- Event-driven communication (Kafka)
- CQRS pattern for reads/writes
- Repository pattern for data access
```

**Step 4: Code Style Context**
```
Code style follows:
- Google Java Style Guide
- Use Lombok for boilerplate
- Immutable DTOs
- Builder pattern for complex objects
- Optional for nullable returns
```

### 3.3 Context in Prompts

**Complete Context Example**:
```
CONTEXT:
Technology: Java 17, Spring Boot 3.2, PostgreSQL, Redis
Domain: E-commerce order processing
Architecture: Microservices, REST APIs, Event-driven
Patterns: Repository, Service Layer, DTO

REQUIREMENT:
Create a service to process orders with:
1. Inventory validation
2. Price calculation with discounts
3. Payment processing
4. Order persistence
5. Event publishing

CONSTRAINTS:
- Transactional operations
- Optimistic locking for inventory
- Retry logic for payment failures
- Comprehensive error handling
- Logging for audit trail

OUTPUT:
Complete service class with all methods, error handling, and logging
```

### 3.4 Maintaining Context Across Sessions

**Context File Template**:
```markdown
# Project Context

## Technology Stack
- Java 17
- Spring Boot 3.2
- PostgreSQL 15
- Redis 7
- Kafka 3.5

## Architecture
- Microservices
- REST APIs
- Event-driven
- CQRS

## Patterns
- Repository Pattern
- Service Layer
- DTO Pattern
- Builder Pattern

## Code Style
- Google Java Style Guide
- Lombok for boilerplate
- Immutable DTOs

## Domain Rules
[Add domain-specific rules]
```

**Using Context File**:
```
[Paste context file]

Based on this context, create [specific requirement]
```

---

## 4. Advanced Prompting Techniques

### 4.1 Chain of Thought Prompting

**Technique**: Break down complex problems into steps

**Example**:
```
Let's solve this step by step:

Problem: Design a rate limiter for API endpoints

Step 1: What are the requirements?
- Limit requests per user/IP
- Time window (e.g., 100 requests per minute)
- Distributed system (multiple servers)
- Need to track requests across instances

Step 2: What algorithms can we use?
- Token bucket
- Sliding window
- Fixed window counter

Step 3: How do we implement it?
- Use Redis for distributed tracking
- Implement sliding window algorithm
- Create a filter/interceptor

Step 4: How do we test it?
- Unit tests for algorithm
- Integration tests with Redis
- Load tests for performance

Step 5: Provide complete implementation
```

### 4.2 Few-Shot Learning

**Technique**: Provide examples to guide the AI

**Example**:
```
I need a service method that follows this pattern:

Example 1:
@Service
public class UserService {
    public User getUser(String id) {
        return userRepository.findById(id)
            .orElseThrow(() -> new UserNotFoundException(id));
    }
}

Example 2:
@Service
public class ProductService {
    public Product getProduct(String id) {
        return productRepository.findById(id)
            .orElseThrow(() -> new ProductNotFoundException(id));
    }
}

Now create OrderService with the same pattern:
- getOrder method
- Custom exception OrderNotFoundException
- Same error handling style
```

### 4.3 Role-Playing Prompts

**Technique**: Ask AI to act as a specific role

**Example**:
```
Act as a Senior Principal Engineer reviewing this code:

[Paste code]

Provide feedback as if you're doing a code review:
1. What's good about this code?
2. What needs improvement?
3. What are potential security issues?
4. What are performance concerns?
5. What are the risks?
6. What are alternative approaches?
7. Provide refactored code with explanations
```

### 4.4 Iterative Refinement

**Technique**: Start broad, then refine

**Iteration 1**:
```
Create a REST controller for user management
```

**Iteration 2**:
```
Create a REST controller for user management with:
- GET /users/{id} - Get user by ID
- POST /users - Create user
- PUT /users/{id} - Update user
- DELETE /users/{id} - Delete user
```

**Iteration 3**:
```
Create a REST controller for user management with:
- GET /users/{id} - Get user by ID (returns 404 if not found)
- POST /users - Create user (validates input, returns 201)
- PUT /users/{id} - Update user (validates input, returns 404 if not found)
- DELETE /users/{id} - Delete user (returns 404 if not found)

Requirements:
- Use Spring Boot annotations
- Return ResponseEntity
- Include proper HTTP status codes
- Add input validation
- Handle exceptions
- Include JavaDoc comments
```

### 4.5 Constraint-Based Prompting

**Technique**: Specify constraints explicitly

**Example**:
```
Create a caching service with these constraints:

MUST HAVE:
- Thread-safe implementation
- TTL (time-to-live) support
- Size limit with LRU eviction
- Null-safe operations

MUST NOT HAVE:
- External dependencies (use in-memory only)
- Synchronous blocking operations
- Memory leaks

SHOULD HAVE:
- Metrics for cache hits/misses
- Configurable TTL
- Event listeners for cache events

SHOULD NOT HAVE:
- Distributed caching (single JVM only)
- Persistence

OUTPUT:
Complete implementation with unit tests
```

---

## 5. Domain-Specific Prompts

### 5.1 Microservices Prompts

**Service Creation**:
```
Create a microservice for [domain] with:

1. Service Structure:
   - Entity classes with JPA annotations
   - Repository interfaces
   - Service layer with business logic
   - REST controller with OpenAPI annotations
   - DTOs for API contracts
   - Exception handling

2. Configuration:
   - Application properties
   - Database configuration
   - Logging configuration

3. Testing:
   - Unit tests for service layer
   - Integration tests for repository
   - Controller tests with MockMvc

4. Documentation:
   - README with setup instructions
   - API documentation (OpenAPI/Swagger)
   - Architecture diagram description

Technology: Spring Boot 3.2, Java 17, PostgreSQL
```

### 5.2 Event-Driven Architecture Prompts

**Event Producer**:
```
Create an event producer service that:

1. Publishes events to Kafka when:
   - Order is created
   - Order is updated
   - Order is cancelled

2. Event Structure:
   - Event ID (UUID)
   - Event type
   - Timestamp
   - Payload (order data)
   - Version

3. Error Handling:
   - Retry logic for failed publishes
   - Dead letter queue for failed events
   - Monitoring and alerting

4. Configuration:
   - Kafka producer configuration
   - Topic configuration
   - Serialization (JSON)

Technology: Spring Boot, Spring Kafka, Java 17
```

**Event Consumer**:
```
Create an event consumer that:

1. Consumes events from Kafka topic "order-events"
2. Processes events:
   - Update inventory
   - Send notifications
   - Update analytics

3. Error Handling:
   - Retry with exponential backoff
   - Dead letter queue
   - Idempotent processing

4. Monitoring:
   - Track processing time
   - Track success/failure rates
   - Alert on failures

Technology: Spring Boot, Spring Kafka, Java 17
```

### 5.3 Database Design Prompts

**Schema Design**:
```
Design a database schema for [domain] with:

1. Entities:
   [List entities]

2. Relationships:
   [Describe relationships]

3. Constraints:
   - Primary keys
   - Foreign keys
   - Unique constraints
   - Check constraints
   - Indexes for performance

4. Considerations:
   - Normalization (3NF)
   - Performance (indexes)
   - Scalability (partitioning strategy)
   - Data integrity

OUTPUT:
- SQL DDL statements
- Entity classes (JPA)
- Repository interfaces
- Migration scripts (Liquibase/Flyway)
```

### 5.4 Security Prompts

**Authentication Service**:
```
Create a secure authentication service with:

1. Features:
   - JWT token generation and validation
   - Password hashing (BCrypt)
   - Token refresh mechanism
   - Role-based access control

2. Security Requirements:
   - Secure password storage
   - Token expiration
   - Refresh token rotation
   - Rate limiting for login attempts
   - Account lockout after failed attempts

3. API Endpoints:
   - POST /auth/login
   - POST /auth/refresh
   - POST /auth/logout
   - GET /auth/validate

4. Error Handling:
   - Invalid credentials (401)
   - Expired tokens (401)
   - Rate limit exceeded (429)

Technology: Spring Boot, Spring Security, JWT, Java 17
```

---

## 6. Prompt Optimization

### 6.1 Measuring Prompt Effectiveness

**Metrics**:
- **Code Quality**: Does generated code meet standards?
- **Correctness**: Is the code functionally correct?
- **Completeness**: Are all requirements met?
- **Maintainability**: Is code easy to understand and modify?

### 6.2 Common Prompt Mistakes

**Mistake 1: Too Vague**
```
BAD: "Make it better"
GOOD: "Refactor to use dependency injection, add error handling, 
      and improve testability"
```

**Mistake 2: Missing Context**
```
BAD: "Create a service"
GOOD: "Create a Spring Boot service for order processing in an 
      e-commerce microservice that uses JPA and Redis"
```

**Mistake 3: Too Many Requirements**
```
BAD: "Create everything with all features"
GOOD: "Create basic CRUD operations first, then we'll add advanced features"
```

**Mistake 4: No Examples**
```
BAD: "Follow best practices"
GOOD: "Follow the same pattern as UserService (see example below)"
```

### 6.3 Prompt Refinement Process

**Step 1: Initial Prompt**
```
Create a user service
```

**Step 2: Add Context**
```
Create a user service in a Spring Boot application using JPA
```

**Step 3: Add Requirements**
```
Create a user service in a Spring Boot application using JPA with:
- CRUD operations
- Input validation
- Error handling
```

**Step 4: Add Constraints**
```
Create a user service in a Spring Boot application using JPA with:
- CRUD operations
- Input validation
- Error handling
- Transactional operations
- Custom exceptions
- Logging
```

**Step 5: Add Examples**
```
Create a user service following the same pattern as ProductService:
[Paste ProductService example]
```

### 6.4 Prompt Templates Library

**Create Reusable Templates**:

**Template 1: Service Class**
```
Create a [Domain]Service class in Spring Boot with:

1. Dependencies:
   - [Domain]Repository (injected)
   - [Other dependencies]

2. Methods:
   - [Method 1] with [description]
   - [Method 2] with [description]

3. Requirements:
   - Transactional operations
   - Error handling
   - Logging
   - Input validation

4. Output:
   - Complete service class
   - JavaDoc comments
   - Unit tests
```

**Template 2: REST Controller**
```
Create a REST controller for [Domain] with:

1. Endpoints:
   - GET /api/[domain]/{id}
   - POST /api/[domain]
   - PUT /api/[domain]/{id}
   - DELETE /api/[domain]/{id}

2. Requirements:
   - OpenAPI annotations
   - Input validation
   - Proper HTTP status codes
   - Error handling
   - Pagination for list endpoints

3. Output:
   - Complete controller class
   - DTOs
   - Exception handlers
```

**Template 3: Test Class**
```
Create comprehensive tests for [Class] with:

1. Test Framework: JUnit 5, Mockito

2. Test Coverage:
   - Happy path scenarios
   - Edge cases
   - Error scenarios
   - Boundary conditions

3. Requirements:
   - Descriptive test names
   - Arrange-Act-Assert pattern
   - Mock verifications
   - Exception testing

4. Output:
   - Complete test class
   - Setup methods
   - Test methods
```

---

## Summary: Part 2

### Key Takeaways

1. **Clear Prompts**: Be specific and descriptive
2. **Context is King**: Provide comprehensive context
3. **Structure Matters**: Use templates and patterns
4. **Iterate**: Refine prompts for better results
5. **Domain-Specific**: Adapt prompts to your domain

### Prompt Engineering Checklist

- [ ] Clear and specific requirements
- [ ] Technology stack specified
- [ ] Domain context provided
- [ ] Constraints and limitations stated
- [ ] Examples provided (if applicable)
- [ ] Output format specified
- [ ] Error handling requirements
- [ ] Testing requirements
- [ ] Documentation requirements

### Next Steps

**Part 3** will cover:
- AI-Assisted Code Review
- Quality Assurance with AI
- Automated Testing with AI
- Code Analysis and Refactoring

---

**Master prompt engineering to get 2-3x better code generation results!**

