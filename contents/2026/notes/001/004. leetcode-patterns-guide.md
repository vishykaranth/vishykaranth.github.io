# Data Structure and Algorithm Patterns for LeetCode Interviews - Complete Guide

## Table of Contents
1. [Common Algorithm Patterns](#common-algorithm-patterns)
2. [Data Structures](#data-structures)
3. [Problem-Solving Strategies](#problem-solving-strategies)
4. [Time & Space Complexity](#time--space-complexity)
5. [LeetCode Problem Categories](#leetcode-problem-categories)
6. [Pattern-Based Problem Solving](#pattern-based-problem-solving)
7. [Interview Tips](#interview-tips)
8. [Practice Problems by Pattern](#practice-problems-by-pattern)
9. [Quick Reference](#quick-reference)

---

## Common Algorithm Patterns

### 1. Two Pointers

**Pattern:**
- Use two pointers moving in different directions
- Often used for sorted arrays or strings
- O(n) time complexity

**When to Use:**
- Sorted arrays
- Palindrome checking
- Pair sum problems
- Removing duplicates

**Template:**
```java
public int twoPointers(int[] nums) {
    int left = 0;
    int right = nums.length - 1;
    
    while (left < right) {
        // Process elements at left and right
        if (condition) {
            left++;
        } else {
            right--;
        }
    }
    
    return result;
}
```

**Example: Two Sum (Sorted Array)**
```java
public int[] twoSum(int[] numbers, int target) {
    int left = 0;
    int right = numbers.length - 1;
    
    while (left < right) {
        int sum = numbers[left] + numbers[right];
        if (sum == target) {
            return new int[]{left + 1, right + 1};
        } else if (sum < target) {
            left++;
        } else {
            right--;
        }
    }
    
    return new int[]{};
}
```

**LeetCode Problems:**
- Two Sum II (167)
- Valid Palindrome (125)
- Container With Most Water (11)
- 3Sum (15)
- Trapping Rain Water (42)

---

### 2. Sliding Window

**Pattern:**
- Maintain a window of elements
- Expand or shrink window based on condition
- O(n) time complexity

**When to Use:**
- Subarray/substring problems
- Maximum/minimum in window
- Fixed size window problems

**Template:**
```java
public int slidingWindow(int[] nums, int k) {
    int left = 0;
    int right = 0;
    int result = 0;
    
    while (right < nums.length) {
        // Expand window
        // Add nums[right] to window
        
        while (window needs to shrink) {
            // Shrink window
            // Remove nums[left] from window
            left++;
        }
        
        // Update result
        result = Math.max(result, windowSize);
        right++;
    }
    
    return result;
}
```

**Example: Maximum Sum Subarray of Size K**
```java
public int maxSumSubarray(int[] nums, int k) {
    int maxSum = 0;
    int windowSum = 0;
    int left = 0;
    
    for (int right = 0; right < nums.length; right++) {
        windowSum += nums[right];
        
        if (right >= k - 1) {
            maxSum = Math.max(maxSum, windowSum);
            windowSum -= nums[left];
            left++;
        }
    }
    
    return maxSum;
}
```

**LeetCode Problems:**
- Maximum Average Subarray I (643)
- Longest Substring Without Repeating Characters (3)
- Minimum Window Substring (76)
- Sliding Window Maximum (239)
- Fruit Into Baskets (904)

---

### 3. Fast & Slow Pointers

**Pattern:**
- Two pointers moving at different speeds
- Used for cycle detection, finding middle
- O(n) time complexity

**When to Use:**
- Linked list problems
- Cycle detection
- Finding middle element
- Palindrome in linked list

**Template:**
```java
public boolean hasCycle(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;
    
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        
        if (slow == fast) {
            return true; // Cycle detected
        }
    }
    
    return false;
}
```

**Example: Find Middle of Linked List**
```java
public ListNode middleNode(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;
    
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    
    return slow;
}
```

**LeetCode Problems:**
- Linked List Cycle (141)
- Linked List Cycle II (142)
- Middle of the Linked List (876)
- Remove Nth Node From End (19)
- Palindrome Linked List (234)

---

### 4. Merge Intervals

**Pattern:**
- Sort intervals by start time
- Merge overlapping intervals
- O(n log n) time complexity

**When to Use:**
- Interval problems
- Overlapping intervals
- Meeting room problems

**Template:**
```java
public int[][] merge(int[][] intervals) {
    Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
    
    List<int[]> merged = new ArrayList<>();
    int[] current = intervals[0];
    
    for (int i = 1; i < intervals.length; i++) {
        if (intervals[i][0] <= current[1]) {
            // Merge intervals
            current[1] = Math.max(current[1], intervals[i][1]);
        } else {
            merged.add(current);
            current = intervals[i];
        }
    }
    
    merged.add(current);
    return merged.toArray(new int[merged.size()][]);
}
```

**LeetCode Problems:**
- Merge Intervals (56)
- Insert Interval (57)
- Meeting Rooms (252)
- Meeting Rooms II (253)
- Non-overlapping Intervals (435)

---

### 5. In-place Reversal of Linked List

**Pattern:**
- Reverse linked list in-place
- Use three pointers: prev, curr, next
- O(n) time, O(1) space

**Template:**
```java
public ListNode reverseList(ListNode head) {
    ListNode prev = null;
    ListNode curr = head;
    
    while (curr != null) {
        ListNode next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
    }
    
    return prev;
}
```

**LeetCode Problems:**
- Reverse Linked List (206)
- Reverse Linked List II (92)
- Reverse Nodes in k-Group (25)
- Swap Nodes in Pairs (24)

---

### 6. Tree Breadth-First Search (BFS)

**Pattern:**
- Level-order traversal using queue
- Process nodes level by level
- O(n) time, O(n) space

**Template:**
```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) return result;
    
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        int levelSize = queue.size();
        List<Integer> currentLevel = new ArrayList<>();
        
        for (int i = 0; i < levelSize; i++) {
            TreeNode node = queue.poll();
            currentLevel.add(node.val);
            
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
        
        result.add(currentLevel);
    }
    
    return result;
}
```

**LeetCode Problems:**
- Binary Tree Level Order Traversal (102)
- Binary Tree Zigzag Level Order Traversal (103)
- Right Side View (199)
- Average of Levels in Binary Tree (637)
- Minimum Depth of Binary Tree (111)

---

### 7. Tree Depth-First Search (DFS)

**Pattern:**
- Recursive or iterative traversal
- Pre-order, in-order, post-order
- O(n) time, O(h) space (h = height)

**Templates:**

**Pre-order (Root → Left → Right):**
```java
public void preorder(TreeNode root) {
    if (root == null) return;
    
    // Process root
    System.out.println(root.val);
    
    // Traverse left
    preorder(root.left);
    
    // Traverse right
    preorder(root.right);
}
```

**In-order (Left → Root → Right):**
```java
public void inorder(TreeNode root) {
    if (root == null) return;
    
    inorder(root.left);
    System.out.println(root.val);
    inorder(root.right);
}
```

**Post-order (Left → Right → Root):**
```java
public void postorder(TreeNode root) {
    if (root == null) return;
    
    postorder(root.left);
    postorder(root.right);
    System.out.println(root.val);
}
```

**LeetCode Problems:**
- Maximum Depth of Binary Tree (104)
- Path Sum (112)
- Same Tree (100)
- Symmetric Tree (101)
- Validate Binary Search Tree (98)

---

### 8. Subsets/Backtracking

**Pattern:**
- Generate all subsets/combinations
- Use backtracking
- O(2^n) time complexity

**Template:**
```java
public List<List<Integer>> subsets(int[] nums) {
    List<List<Integer>> result = new ArrayList<>();
    backtrack(result, new ArrayList<>(), nums, 0);
    return result;
}

private void backtrack(List<List<Integer>> result, 
                      List<Integer> current, 
                      int[] nums, 
                      int start) {
    result.add(new ArrayList<>(current));
    
    for (int i = start; i < nums.length; i++) {
        current.add(nums[i]);
        backtrack(result, current, nums, i + 1);
        current.remove(current.size() - 1);
    }
}
```

**LeetCode Problems:**
- Subsets (78)
- Subsets II (90)
- Combinations (77)
- Permutations (46)
- Combination Sum (39)

---

### 9. Modified Binary Search

**Pattern:**
- Binary search with variations
- Find target, find boundary, find rotation point
- O(log n) time complexity

**Template:**
```java
public int binarySearch(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;
}
```

**Variations:**

**Find First Occurrence:**
```java
public int findFirst(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    int result = -1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (nums[mid] == target) {
            result = mid;
            right = mid - 1; // Continue searching left
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return result;
}
```

**LeetCode Problems:**
- Binary Search (704)
- Search in Rotated Sorted Array (33)
- Find First and Last Position (34)
- Search Insert Position (35)
- Find Peak Element (162)

---

### 10. Top K Elements

**Pattern:**
- Use heap (PriorityQueue) to find top K
- Min heap for top K largest
- Max heap for top K smallest
- O(n log k) time complexity

**Template:**
```java
public int[] topK(int[] nums, int k) {
    PriorityQueue<Integer> minHeap = new PriorityQueue<>();
    
    for (int num : nums) {
        minHeap.offer(num);
        if (minHeap.size() > k) {
            minHeap.poll();
        }
    }
    
    int[] result = new int[k];
    for (int i = k - 1; i >= 0; i--) {
        result[i] = minHeap.poll();
    }
    
    return result;
}
```

**LeetCode Problems:**
- Kth Largest Element (215)
- Top K Frequent Elements (347)
- Top K Frequent Words (692)
- Find K Closest Points (973)
- Kth Smallest Element (230)

---

### 11. K-way Merge

**Pattern:**
- Merge K sorted lists/arrays
- Use heap to merge efficiently
- O(n log k) time complexity

**Template:**
```java
public ListNode mergeKLists(ListNode[] lists) {
    PriorityQueue<ListNode> minHeap = new PriorityQueue<>(
        (a, b) -> a.val - b.val
    );
    
    for (ListNode list : lists) {
        if (list != null) {
            minHeap.offer(list);
        }
    }
    
    ListNode dummy = new ListNode(0);
    ListNode current = dummy;
    
    while (!minHeap.isEmpty()) {
        ListNode node = minHeap.poll();
        current.next = node;
        current = current.next;
        
        if (node.next != null) {
            minHeap.offer(node.next);
        }
    }
    
    return dummy.next;
}
```

**LeetCode Problems:**
- Merge K Sorted Lists (23)
- Kth Smallest in Sorted Matrix (378)
- Find K Pairs with Smallest Sums (373)

---

### 12. Dynamic Programming

**Pattern:**
- Break problem into subproblems
- Store results of subproblems
- Bottom-up or top-down approach

**Template (Bottom-up):**
```java
public int dp(int n) {
    int[] dp = new int[n + 1];
    dp[0] = baseCase1;
    dp[1] = baseCase2;
    
    for (int i = 2; i <= n; i++) {
        dp[i] = recurrenceRelation(dp[i-1], dp[i-2]);
    }
    
    return dp[n];
}
```

**Template (Top-down with Memoization):**
```java
Map<Integer, Integer> memo = new HashMap<>();

public int dp(int n) {
    if (n <= 1) return n;
    
    if (memo.containsKey(n)) {
        return memo.get(n);
    }
    
    int result = dp(n - 1) + dp(n - 2);
    memo.put(n, result);
    return result;
}
```

**DP Patterns:**

**1. 1D DP:**
```java
// Fibonacci
dp[i] = dp[i-1] + dp[i-2]

// Climbing Stairs
dp[i] = dp[i-1] + dp[i-2]

// House Robber
dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i])
```

**2. 2D DP:**
```java
// Unique Paths
dp[i][j] = dp[i-1][j] + dp[i][j-1]

// Edit Distance
dp[i][j] = min(
    dp[i-1][j] + 1,      // Delete
    dp[i][j-1] + 1,      // Insert
    dp[i-1][j-1] + cost  // Replace
)
```

**3. Knapsack:**
```java
// 0/1 Knapsack
dp[i][w] = max(
    dp[i-1][w],                    // Don't take
    dp[i-1][w-weight[i]] + value[i]  // Take
)
```

**LeetCode Problems:**
- Climbing Stairs (70)
- House Robber (198)
- Coin Change (322)
- Longest Increasing Subsequence (300)
- Edit Distance (72)
- Unique Paths (62)
- 0/1 Knapsack variations

---

### 13. Union Find (Disjoint Set)

**Pattern:**
- Track connected components
- Union and find operations
- Path compression and union by rank

**Template:**
```java
class UnionFind {
    private int[] parent;
    private int[] rank;
    
    public UnionFind(int n) {
        parent = new int[n];
        rank = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    
    public int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // Path compression
        }
        return parent[x];
    }
    
    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        
        if (rootX == rootY) return;
        
        // Union by rank
        if (rank[rootX] < rank[rootY]) {
            parent[rootX] = rootY;
        } else if (rank[rootX] > rank[rootY]) {
            parent[rootY] = rootX;
        } else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }
    }
}
```

**LeetCode Problems:**
- Number of Islands (200)
- Friend Circles (547)
- Redundant Connection (684)
- Accounts Merge (721)

---

### 14. Trie (Prefix Tree)

**Pattern:**
- Store strings with common prefixes
- Fast prefix matching
- O(m) time for search (m = length of word)

**Template:**
```java
class TrieNode {
    TrieNode[] children;
    boolean isWord;
    
    public TrieNode() {
        children = new TrieNode[26];
        isWord = false;
    }
}

class Trie {
    private TrieNode root;
    
    public Trie() {
        root = new TrieNode();
    }
    
    public void insert(String word) {
        TrieNode current = root;
        for (char c : word.toCharArray()) {
            int index = c - 'a';
            if (current.children[index] == null) {
                current.children[index] = new TrieNode();
            }
            current = current.children[index];
        }
        current.isWord = true;
    }
    
    public boolean search(String word) {
        TrieNode node = searchPrefix(word);
        return node != null && node.isWord;
    }
    
    public boolean startsWith(String prefix) {
        return searchPrefix(prefix) != null;
    }
    
    private TrieNode searchPrefix(String prefix) {
        TrieNode current = root;
        for (char c : prefix.toCharArray()) {
            int index = c - 'a';
            if (current.children[index] == null) {
                return null;
            }
            current = current.children[index];
        }
        return current;
    }
}
```

**LeetCode Problems:**
- Implement Trie (208)
- Word Search II (212)
- Add and Search Word (211)
- Longest Word in Dictionary (720)

---

### 15. Graph Algorithms

**Patterns:**

**1. BFS (Shortest Path):**
```java
public int shortestPath(int[][] graph, int start, int end) {
    Queue<Integer> queue = new LinkedList<>();
    Set<Integer> visited = new HashSet<>();
    queue.offer(start);
    visited.add(start);
    int level = 0;
    
    while (!queue.isEmpty()) {
        int size = queue.size();
        for (int i = 0; i < size; i++) {
            int node = queue.poll();
            if (node == end) return level;
            
            for (int neighbor : graph[node]) {
                if (!visited.contains(neighbor)) {
                    visited.add(neighbor);
                    queue.offer(neighbor);
                }
            }
        }
        level++;
    }
    
    return -1;
}
```

**2. DFS:**
```java
public void dfs(int node, boolean[] visited, int[][] graph) {
    visited[node] = true;
    
    for (int neighbor : graph[node]) {
        if (!visited[neighbor]) {
            dfs(neighbor, visited, graph);
        }
    }
}
```

**3. Topological Sort:**
```java
public int[] topologicalSort(int numCourses, int[][] prerequisites) {
    List<Integer>[] graph = new ArrayList[numCourses];
    int[] inDegree = new int[numCourses];
    
    for (int i = 0; i < numCourses; i++) {
        graph[i] = new ArrayList<>();
    }
    
    for (int[] edge : prerequisites) {
        graph[edge[1]].add(edge[0]);
        inDegree[edge[0]]++;
    }
    
    Queue<Integer> queue = new LinkedList<>();
    for (int i = 0; i < numCourses; i++) {
        if (inDegree[i] == 0) {
            queue.offer(i);
        }
    }
    
    int[] result = new int[numCourses];
    int index = 0;
    
    while (!queue.isEmpty()) {
        int node = queue.poll();
        result[index++] = node;
        
        for (int neighbor : graph[node]) {
            inDegree[neighbor]--;
            if (inDegree[neighbor] == 0) {
                queue.offer(neighbor);
            }
        }
    }
    
    return index == numCourses ? result : new int[0];
}
```

**LeetCode Problems:**
- Number of Islands (200)
- Course Schedule (207)
- Clone Graph (133)
- Word Ladder (127)
- Network Delay Time (743)

---

## Data Structures

### Arrays

**Operations:**
- Access: O(1)
- Search: O(n)
- Insert: O(n)
- Delete: O(n)

**Common Patterns:**
- Two pointers
- Sliding window
- Binary search
- Sorting

### Linked Lists

**Operations:**
- Access: O(n)
- Search: O(n)
- Insert: O(1) at head
- Delete: O(1) if node known

**Common Patterns:**
- Fast & slow pointers
- Reversal
- Dummy node
- Two pointers

### Stacks

**Operations:**
- Push: O(1)
- Pop: O(1)
- Peek: O(1)

**Use Cases:**
- Valid parentheses
- Monotonic stack
- Expression evaluation
- DFS (iterative)

### Queues

**Operations:**
- Enqueue: O(1)
- Dequeue: O(1)
- Peek: O(1)

**Use Cases:**
- BFS
- Level-order traversal
- Sliding window maximum

### Heaps (Priority Queue)

**Operations:**
- Insert: O(log n)
- Extract min/max: O(log n)
- Peek: O(1)

**Use Cases:**
- Top K elements
- K-way merge
- Dijkstra's algorithm

### Hash Tables

**Operations:**
- Insert: O(1) average
- Search: O(1) average
- Delete: O(1) average

**Use Cases:**
- Frequency counting
- Two sum problems
- Caching
- Deduplication

### Trees

**Binary Tree:**
- Height: O(log n) balanced, O(n) worst
- Traversal: O(n)

**Binary Search Tree:**
- Search: O(log n) average
- Insert: O(log n) average
- Delete: O(log n) average

**Use Cases:**
- Hierarchical data
- Search operations
- Range queries

### Graphs

**Representation:**
- Adjacency list: O(V + E) space
- Adjacency matrix: O(V²) space

**Algorithms:**
- BFS: O(V + E)
- DFS: O(V + E)
- Dijkstra: O((V + E) log V)
- Topological sort: O(V + E)

---

## Problem-Solving Strategies

### 1. Understand the Problem

**Steps:**
1. Read problem carefully
2. Identify input/output
3. Understand constraints
4. Identify edge cases
5. Clarify requirements

### 2. Identify Pattern

**Questions:**
- Is it a known pattern?
- What data structure fits?
- What algorithm applies?
- Similar problems?

### 3. Design Algorithm

**Steps:**
1. Think of brute force first
2. Optimize step by step
3. Consider time/space complexity
4. Handle edge cases

### 4. Code Implementation

**Best Practices:**
- Clean, readable code
- Meaningful variable names
- Handle edge cases
- Add comments for complex logic

### 5. Test & Debug

**Steps:**
1. Test with examples
2. Test edge cases
3. Test boundary conditions
4. Verify time/space complexity

---

## Time & Space Complexity

### Common Complexities

**Time:**
- O(1): Constant
- O(log n): Logarithmic
- O(n): Linear
- O(n log n): Linearithmic
- O(n²): Quadratic
- O(2^n): Exponential

**Space:**
- O(1): Constant
- O(n): Linear
- O(n²): Quadratic

### Complexity Analysis

**Common Operations:**
- Array access: O(1)
- Array search: O(n)
- Hash table operations: O(1) average
- Binary search: O(log n)
- Sorting: O(n log n)
- Tree traversal: O(n)
- Graph traversal: O(V + E)

---

## LeetCode Problem Categories

### 1. Array & String
- Two pointers
- Sliding window
- Hash table
- Sorting

### 2. Linked List
- Fast & slow pointers
- Reversal
- Dummy node
- Two pointers

### 3. Tree
- DFS
- BFS
- Binary search tree
- Tree construction

### 4. Graph
- BFS/DFS
- Topological sort
- Shortest path
- Union find

### 5. Dynamic Programming
- 1D DP
- 2D DP
- Knapsack
- String DP

### 6. Backtracking
- Subsets
- Permutations
- Combinations
- N-Queens

### 7. Greedy
- Activity selection
- Interval scheduling
- Minimum spanning tree

### 8. Math
- Number theory
- Geometry
- Probability

---

## Pattern-Based Problem Solving

### Pattern Recognition Flowchart

```
Problem
  ↓
Is it sorted? → Yes → Two Pointers / Binary Search
  ↓ No
Subarray/Substring? → Yes → Sliding Window
  ↓ No
Linked List? → Yes → Fast & Slow / Reversal
  ↓ No
Tree? → Yes → DFS / BFS
  ↓ No
Graph? → Yes → BFS / DFS / Topological Sort
  ↓ No
All combinations? → Yes → Backtracking
  ↓ No
Optimization? → Yes → DP / Greedy
  ↓ No
Top K? → Yes → Heap
  ↓ No
Prefix matching? → Yes → Trie
```

---

## Interview Tips

### 1. Communication

**Best Practices:**
- Think out loud
- Ask clarifying questions
- Explain your approach
- Discuss trade-offs

### 2. Problem Solving

**Steps:**
1. Understand problem (2-3 min)
2. Discuss approach (3-5 min)
3. Code solution (15-20 min)
4. Test & optimize (5-10 min)

### 3. Coding

**Best Practices:**
- Clean, readable code
- Handle edge cases
- Meaningful variable names
- Add comments for complex logic

### 4. Optimization

**Questions:**
- Can we optimize time?
- Can we optimize space?
- What are trade-offs?
- Is optimization necessary?

---

## Practice Problems by Pattern

### Two Pointers
- Two Sum (1)
- Two Sum II (167)
- 3Sum (15)
- Container With Most Water (11)
- Valid Palindrome (125)

### Sliding Window
- Longest Substring Without Repeating Characters (3)
- Minimum Window Substring (76)
- Maximum Average Subarray I (643)
- Sliding Window Maximum (239)

### Fast & Slow Pointers
- Linked List Cycle (141)
- Middle of the Linked List (876)
- Remove Nth Node From End (19)
- Palindrome Linked List (234)

### Merge Intervals
- Merge Intervals (56)
- Insert Interval (57)
- Meeting Rooms (252)
- Non-overlapping Intervals (435)

### Tree BFS
- Binary Tree Level Order Traversal (102)
- Right Side View (199)
- Average of Levels in Binary Tree (637)

### Tree DFS
- Maximum Depth of Binary Tree (104)
- Path Sum (112)
- Validate Binary Search Tree (98)
- Same Tree (100)

### Backtracking
- Subsets (78)
- Permutations (46)
- Combination Sum (39)
- N-Queens (51)

### Binary Search
- Binary Search (704)
- Search in Rotated Sorted Array (33)
- Find First and Last Position (34)

### Top K
- Kth Largest Element (215)
- Top K Frequent Elements (347)
- Top K Frequent Words (692)

### Dynamic Programming
- Climbing Stairs (70)
- House Robber (198)
- Coin Change (322)
- Longest Increasing Subsequence (300)
- Edit Distance (72)

### Graph
- Number of Islands (200)
- Course Schedule (207)
- Clone Graph (133)
- Word Ladder (127)

---

## Quick Reference

### Pattern Cheat Sheet

| Pattern | Time | Space | When to Use |
|---------|------|-------|-------------|
| Two Pointers | O(n) | O(1) | Sorted arrays, palindromes |
| Sliding Window | O(n) | O(1) | Subarray/substring problems |
| Fast & Slow | O(n) | O(1) | Linked list, cycle detection |
| Merge Intervals | O(n log n) | O(n) | Interval problems |
| Tree BFS | O(n) | O(n) | Level-order traversal |
| Tree DFS | O(n) | O(h) | Tree traversal |
| Backtracking | O(2^n) | O(n) | All combinations |
| Binary Search | O(log n) | O(1) | Sorted arrays |
| Top K | O(n log k) | O(k) | Top K elements |
| DP | O(n²) | O(n) | Optimization problems |
| Graph BFS | O(V+E) | O(V) | Shortest path |
| Graph DFS | O(V+E) | O(V) | Connected components |

### Data Structure Operations

| Structure | Access | Search | Insert | Delete |
|-----------|--------|--------|--------|--------|
| Array | O(1) | O(n) | O(n) | O(n) |
| Linked List | O(n) | O(n) | O(1) | O(1) |
| Stack | O(n) | O(n) | O(1) | O(1) |
| Queue | O(n) | O(n) | O(1) | O(1) |
| Heap | O(1) | O(n) | O(log n) | O(log n) |
| Hash Table | N/A | O(1) | O(1) | O(1) |
| BST | O(log n) | O(log n) | O(log n) | O(log n) |

### Common Algorithms

| Algorithm | Time | Space |
|-----------|------|-------|
| Quick Sort | O(n log n) | O(log n) |
| Merge Sort | O(n log n) | O(n) |
| Binary Search | O(log n) | O(1) |
| BFS | O(V+E) | O(V) |
| DFS | O(V+E) | O(V) |
| Dijkstra | O((V+E)log V) | O(V) |

---

## Summary

### Key Takeaways

1. **Pattern Recognition**: Learn common patterns
2. **Practice**: Solve problems by pattern
3. **Time/Space**: Understand complexity
4. **Communication**: Think out loud
5. **Optimization**: Optimize after brute force

### Study Plan

**Week 1-2: Basic Patterns**
- Two pointers
- Sliding window
- Fast & slow pointers

**Week 3-4: Tree & Graph**
- Tree DFS/BFS
- Graph algorithms
- Topological sort

**Week 5-6: Advanced Patterns**
- Dynamic programming
- Backtracking
- Greedy

**Week 7-8: Practice & Review**
- Mock interviews
- Review patterns
- Solve hard problems

---

**Guide Complete** - Master these patterns and you'll be ready for LeetCode interviews!

