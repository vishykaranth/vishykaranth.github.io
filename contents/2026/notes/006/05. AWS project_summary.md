#  Docker Container Guidelines - Project Summary

## Overview
This document summarizes the standard guidelines and best practices for building, deploying, and maintaining Docker containers for  projects.

---

## 1. Base Images and Infrastructure

### Standard Base OS Images
- **Requirement**: Use Standard DevOps build base OS images only
- **Action**: Check available images at ** Base images**
- **Process**: If a new layer is needed, contact DevOps team for centralized creation and maintenance

### CI/CD Pipelines
- **CI Pipeline**: Work with DevOps to use standard CI pipeline for repository and artifact generation
- **CD Pipeline**: Use standard CD pipeline for deployment to Dev Cluster
- **Reference**: See ** Build and Deployment Process** and **Deployment to Dev Cluster**

---

## 2. Kubernetes Deployment

### Namespaces
- **Location**: Deploy containers in team's K8s namespace
- **Reference**: Check **Integration Test Setup Namespaces**
- **Action**: If namespace doesn't exist or isn't listed, request and add it to the page

### Security
- **Secrets Management**: Store sensitive information (credentials, private keys) in **Hashicorp Vault**
- **Security Scans**: 
  - **Snyk**: Run scans on BitBucket repo, file defects for direct usage issues with upgrades, incorporate into CI pipeline
  - **BurpSuite**: Incorporate into CD pipeline, address High/Medium issues before each sprint ends

---

## 3. Continuous Deployment and Testing

### Deployment Process
- **Reference**: Follow **Continuous Deployment for  Components** process
- **Integration**: Use standard CD pipeline for deployment and testing

### Integration Testing
Build integration tests using standard automation tools and reporting infrastructure. 

**Available Testing Frameworks:**
- **K6-based API automation**: **API Testing Framework Test Harness Proposal (Based on K6)**
- **Selenium-based UI automation**: **UI Test Automation Framework**
- **Cypress-based component testing**: **Creating e2e test cases**
- **Pytest**: Document best practices & reporting scheme

### Test Reporting
- **Tool**: Use **QMetry** for test case and test result reporting

---

## 4. Health and Monitoring

### Health Endpoints
- **Requirement**: Define `/health` endpoint and metrics for container
- **Reference**: See **Guidelines for components**
- **Purpose**: Proactive detection of performance issues and errors in production

### Metrics
- **Consideration**: Define necessary metrics for health monitoring and performance tracking
- **Benefit**: Early detection prevents escalation of issues

---

## 5. API Design and Security

### Access Control
- **Requirement**: Review API endpoints with architect
- **Focus**: Define role permissions and resource/data filtering
- **Reference**: **Access control in the services**

### Traceability
- **Requirement**: Follow API traceability requirements
- **Reference**: **Guidelines for components**

---

## 6. Helm Charts and Resource Management

### Helm Charts
- **Requirement**: Use standard Helm Chart
- **Reference**: **Helm charts | Best practices**
- **Action**: Review details and samples

### Resource Utilization
- **Requirement**: Define min and max resource utilization for container
- **Tracking**: List containers in ** Component list** spreadsheet

### Auto-scaling
- **Requirement**: Document auto-scaling and replica counts
- **Action**: Work with DevOps engineer to test early

---

## 7. Storage and Data Security

### File Storage
- **Standard**: Use  Drive (EFS)
- **Alternative**: If additional storage needed beyond Drive, discuss with architect and DevOps engineer first

### Data Security Review
- **Requirement**: Review data security with architect
- **Timing**: Before implementation

---

## 8. Code Build and Deploy Infrastructure

### Source Code Management

#### Git Repository Structure
- **Platform**: All source code stored in Git (BitBucket)
- **Repository Organization**:
  - Each microservice has a separate git repository
  - Libraries should have independent git repositories
  - Each repository has one primary output artifact

#### Source Code Standards
- **Source Organization**: Follow language-specific conventions (e.g., Maven source layout for Java projects)
- **Exclusions**: Source repositories must NOT include:
  - Secrets or environment-specific configurations
  - Dependencies (should be managed by build tools)
  - Tool-generated sources

### Build Process

#### Continuous Integration
- **Tool**: Jenkins is used for continuous integration
- **Configuration**: 
  - Builds performed on all commits
  - Only select branches have builds retained for longer periods
  - Source repositories use Jenkins pipelines for builds

#### Microservice Builds
- **Dockerfile**: Each microservice has a Dockerfile in its root
- **Build Method**: Builds performed using Dockerfile
- **Artifact Publishing**: 
  - Microservices: Published to Docker image repository
  - Other repositories: Published to appropriate artifact repository hosted by Nexus

#### End-to-End Integration Tests
- **Pipeline**: Jenkins Pipeline for continuous end-to-end integration tests
- **Schedule**: Daily (can also be run on demand)
- **Process**: 
  - Deploys entire application from pre-determined branches
  - Deploys to integration-test environment
  - Runs end-to-end tests
  - If successful, tags corresponding sources and images

### Deployment Infrastructure

#### Deployment Automation
- **Tool**: Jenkins used for deployment automation
- **Method**: Pipeline for automated deployment of managed services

#### Deployment Pipeline Structure
One or more pipelines perform three independent steps (can be triggered separately):

1. **Cluster Setup**
   - Setup Kubernetes cluster
   - Include managed services to be made available

2. **Namespace Configuration**
   - Setup/configure namespace for platform use

3. **Platform Deployment**
   - Deploy platform into namespace

#### Deployment Tools
- **Infrastructure**: Terraform for infrastructure portions
- **Application**: Helm for application deployment
- **Separation**: Infrastructure and application deployment are separate

#### Deployment Models

**Fully Managed Applications:**
- Pipelines setup clusters and/or namespaces for applications built by the platform
- Split between infrastructure (Terraform) and application (Helm)
- Allows automated deployment of fully managed applications

**Customer-Provided Infrastructure:**
- Helm charts can be used to deploy into pre-provisioned infrastructure
- For applications that are not fully managed

#### Deployment Principles
- **Namespace Isolation**: Platform lives within designated namespace
- **Concurrent Deployments**: Multiple independent deployments can run concurrently in different namespaces in the same cluster
- **Infrastructure as Code**: All deployment sources maintained in Git
- **Reproducibility**: Should be possible to destroy and recreate deployment infrastructure from Git (except secrets)

---

## 9. Amazon ECS (Elastic Container Service) POC

### Overview

**Amazon ECS** is a fully managed container orchestration service that allows you to run, stop, and manage Docker containers on a cluster.

#### Key Benefits
- **Managed Service**: AWS handles cluster management, no control plane to manage
- **Native Integration**: ALB, CloudWatch, IAM, ECR, VPC
- **Cost Efficient**: Pay only for resources used (especially with Fargate)
- **Scalability**: Scale from 1 to thousands of containers
- **Security**: Task-level isolation, IAM roles per task

---

### Launch Types

#### 1. Fargate (Serverless)

**What You Manage:**
- Task Definition
- Container images
- CPU/Memory settings
- Networking configuration

**What AWS Manages:**
- EC2 instances
- Cluster capacity
- OS patching
- Docker daemon
- Agent updates

**Pros:**
- No EC2 instances to manage
- Pay per task (vCPU + memory per second)
- Automatic scaling of infrastructure
- Enhanced security isolation

**Cons:**
- Slightly higher cost per compute unit
- No GPU support (as of early 2025)
- Limited to specific CPU/memory combinations
- No persistent storage (EFS only)

**Use Fargate When:**
- You want serverless simplicity
- Workloads are variable/unpredictable
- Team is small / no dedicated ops
- You need quick scaling
- Security isolation is critical

---

#### 2. EC2 Launch Type

**What You Manage:**
- EC2 instances
- Instance types
- AMI updates
- Cluster capacity
- ECS Agent
- Task Definition
- Container images

**What AWS Manages:**
- Control plane
- Scheduling

**Pros:**
- Lower cost for steady workloads
- GPU support
- Full control over instances
- Use Spot instances for cost savings
- Persistent local storage
- Any instance type

**Cons:**
- Must manage EC2 fleet
- Capacity planning required
- OS patching responsibility
- More complex setup

**Use EC2 When:**
- Cost optimization is priority (steady workloads)
- You need GPUs
- You need large tasks (>16 vCPU)
- You need specific instance types
- You want Spot instances for big savings
- You need local persistent storage

---

### ECS Architecture & Core Concepts

#### ECS Hierarchy

```
AWS Account
    └── ECS Cluster (logical grouping)
            ├── Service (maintains desired count)
            │       │
            │       ├── Task (running container instance)
            │       ├── Task
            │       └── Task
            │
            └── Task Definition (blueprint/template)
                    │
                    ├── Container Definition 1
                    ├── Container Definition 2
                    └── Container Definition N
```

#### Core Concepts

**Cluster:**
- Logical grouping of tasks or services
- Can span multiple AZs
- Contains Services and Tasks
- Can use Fargate, EC2, or both

**Task Definition:**
- Blueprint describing how containers should run
- Includes: Docker image(s), CPU/Memory, environment variables, port mappings, volumes, IAM roles, logging configuration

**Task:**
- Running instance of a Task Definition
- One task can have multiple containers
- Has its own ENI (Elastic Network Interface)
- Gets private IP in VPC

**Service:**
- Manages long-running tasks
- Ensures desired count is maintained
- Includes: deployment configuration, load balancer integration, auto scaling rules, service discovery

---

### Task Definitions

#### Key Parameters

```json
{
    "family": "my-app",
    "networkMode": "awsvpc",
    "requiresCompatibilities": ["FARGATE"],
    "cpu": "256",
    "memory": "512",
    "executionRoleArn": "arn:aws:iam::...:role/ecsTaskExecutionRole",
    "taskRoleArn": "arn:aws:iam::...:role/ecsTaskRole",
    "containerDefinitions": [...]
}
```

#### Network Modes

| Mode | Description | Use Case |
|------|-------------|----------|
| **awsvpc** | Each task gets its own ENI | Required for Fargate, recommended for EC2 |
| **bridge** | Docker's built-in virtual network | Legacy EC2 applications |
| **host** | Uses EC2 host's network | High performance needs |
| **none** | No network connectivity | Batch jobs with no network needs |

#### CPU and Memory (Fargate)

Valid combinations for Fargate:

| CPU (units) | Memory (MB) Options |
|-------------|---------------------|
| 256 (.25 vCPU) | 512, 1024, 2048 |
| 512 (.5 vCPU) | 1024 - 4096 |
| 1024 (1 vCPU) | 2048 - 8192 |
| 2048 (2 vCPU) | 4096 - 16384 |
| 4096 (4 vCPU) | 8192 - 30720 |
| 8192 (8 vCPU) | 16384 - 61440 |
| 16384 (16 vCPU) | 32768 - 122880 |

#### Container Definitions

**Key Elements:**
- **Essential vs Non-Essential**: Essential containers stop the task if they fail
- **Multi-Container Patterns**: Sidecar, Ambassador, Init containers
- **Environment Variables**: Hardcoded or from Secrets Manager/Parameter Store
- **Health Checks**: Container-level health monitoring
- **Logging**: CloudWatch Logs integration

**Common Patterns:**
- **Sidecar**: Logging, monitoring containers alongside main app
- **Ambassador**: Proxy pattern for external communication
- **Init Containers**: Pre-initialization tasks using `dependsOn`

---

### Networking in ECS

#### VPC Architecture

**Typical Setup:**
- **Public Subnets**: NAT Gateways, ALB
- **Private Subnets**: ECS Tasks
- **Security Groups**: ALB SG allows 80/443 from internet, Task SG allows only from ALB SG

#### awsvpc Network Mode (Fargate Default)

**Benefits:**
- Each task has unique IP
- Security groups at task level
- VPC Flow Logs per task
- Direct VPC connectivity

#### VPC Endpoints (Private Access)

**Required endpoints for Fargate:**
- `com.amazonaws.region.ecr.api` - ECR API
- `com.amazonaws.region.ecr.dkr` - ECR Docker
- `com.amazonaws.region.s3` - S3 (for ECR layers)
- `com.amazonaws.region.logs` - CloudWatch Logs

**Benefits:** No internet/NAT Gateway needed for AWS service access

---

### Services & Scheduling

#### Service Types

**Replica Service (Most Common):**
- Maintains desired count of tasks
- Spreads across AZs
- Replaces failed tasks
- Integrates with load balancer

**Daemon Service (EC2 only):**
- Runs exactly ONE task per EC2 instance
- Used for monitoring agents, log collectors
- Automatically added to new instances
- Not available on Fargate

#### Task Placement (EC2 Launch Type)

**Placement Strategies:**
- **binpack**: Pack tasks tightly to minimize instances used
- **spread**: Spread across specified attribute (AZ, instance)
- **random**: Place randomly

**Placement Constraints:**
- **distinctInstance**: One task per EC2 instance
- **memberOf**: Place on instances matching expression

---

### Load Balancing

#### Load Balancer Types

| Type | Protocol | Use Case |
|------|----------|----------|
| **Application Load Balancer (ALB)** | HTTP/HTTPS | Web applications, REST APIs |
| **Network Load Balancer (NLB)** | TCP/UDP | High performance, static IP needs |
| **Gateway Load Balancer (GWLB)** | IP | Network appliances (firewalls) |

#### Target Group Types

| Type | Description | Use With |
|------|-------------|----------|
| **IP** | Register by IP address | Fargate (required), awsvpc mode |
| **Instance** | Register by EC2 instance ID | EC2 launch type with bridge/host mode |
| **Lambda** | Invoke Lambda function | Serverless backends |

#### ALB Architecture with ECS

```
Internet → ALB (Listener Rules)
              ├── /api/* → API Target Group → ECS Service (API)
              ├── /* → Web Target Group → ECS Service (Web)
              └── /admin/* → Admin Target Group → ECS Service (Admin)
```

---

### Auto Scaling

#### Types of Auto Scaling

**Service Auto Scaling:**
- **Target Tracking**: Keep CPU at 70% (recommended)
- **Step Scaling**: Different actions at different thresholds
- **Scheduled Scaling**: Scale at specific times

**Cluster Auto Scaling (EC2 only):**
- Capacity Provider links Auto Scaling Group to ECS Cluster
- Automatically scales EC2 instances
- Supports Spot instances

#### Metrics for Scaling

- **ECSServiceAverageCPUUtilization**: CPU-bound applications
- **ECSServiceAverageMemoryUtilization**: Memory-bound applications
- **ALBRequestCountPerTarget**: Request-based scaling
- **Custom CloudWatch Metric**: Business-specific (queue depth, etc.)

---

### Service Discovery

#### AWS Cloud Map Integration

**How It Works:**
1. Service A queries DNS: "service-b.local"
2. Cloud Map (Route 53) returns IP: 10.0.3.45
3. Service A connects to Service B

**Configuration:**
- **DNS Namespace**: Standard service discovery (A/SRV records)
- **HTTP Namespace**: API calls to Cloud Map (complex service mesh)

**Benefits:**
- Automatic service registration
- Health check integration
- Multi-AZ support

---

### Security

#### IAM Roles

**Two Types of Roles:**

**Execution Role:**
- Used BY ECS to:
  - Pull images from ECR
  - Push logs to CloudWatch
  - Retrieve secrets from Secrets Manager
  - Get parameters from Parameter Store

**Task Role:**
- Used BY YOUR APPLICATION to:
  - Access S3 buckets
  - Query DynamoDB
  - Call other AWS services
  - Send messages to SQS

#### Secrets Management

**Best Practices:**
- ✅ Store secrets in Secrets Manager or Parameter Store
- ✅ Reference secrets in task definition
- ✅ Rotate secrets automatically
- ✅ Use least privilege for execution role
- ❌ Don't hardcode secrets
- ❌ Don't store in environment variables (visible in console)
- ❌ Don't commit secrets to code repository

#### Network Security

**Security Layers:**
1. **VPC Level**: Private subnets for tasks, VPC endpoints
2. **Security Group Level**: ALB SG allows 80/443, Task SG allows only from ALB SG
3. **Task Level**: awsvpc mode for isolation, each task has own ENI
4. **Container Level**: Non-root user, read-only root filesystem, no privileged mode

---

### Logging & Monitoring

#### Logging Drivers

| Driver | Destination | Use Case |
|--------|-------------|----------|
| **awslogs** | CloudWatch Logs | Standard AWS logging |
| **splunk** | Splunk | Enterprise logging |
| **fluentd** | Fluentd | Custom log routing |
| **awsfirelens** | Any destination | Flexible log routing |

#### CloudWatch Logs Configuration

```json
"logConfiguration": {
    "logDriver": "awslogs",
    "options": {
        "awslogs-group": "/ecs/my-app",
        "awslogs-region": "us-east-1",
        "awslogs-stream-prefix": "ecs",
        "awslogs-create-group": "true"
    }
}
```

#### Key Metrics to Monitor

**ECS Service Metrics:**
- CPUUtilization
- MemoryUtilization
- RunningTaskCount
- PendingTaskCount

**ALB Metrics:**
- RequestCount
- TargetResponseTime
- HTTPCode_Target_2XX_Count
- HTTPCode_Target_5XX_Count
- HealthyHostCount
- UnHealthyHostCount

#### Container Insights

**Provides:**
- Automatic dashboards
- Performance metrics at cluster/service/task level
- Resource utilization graphs
- Anomaly detection
- Integration with CloudWatch Alarms

---

### Deployment Strategies

#### 1. Rolling Update (Default)

**Process:**
- Gradually replaces old tasks with new ones
- Maintains service availability
- Configurable: minimumHealthyPercent, maximumPercent

**Configuration:**
```json
{
    "deploymentConfiguration": {
        "minimumHealthyPercent": 50,
        "maximumPercent": 200
    }
}
```

#### 2. Blue/Green Deployment (with CodeDeploy)

**Process:**
1. Deploy v2 to Green target group
2. Test Green deployment
3. Switch ALB listener to Green
4. Keep Blue for rollback
5. Terminate Blue when confident

**Benefits:** Zero-downtime, instant rollback

#### 3. Canary Deployment

**Process:**
- Traffic split: 90% → v1, 10% → v2
- Monitor for errors
- Gradually increase v2 traffic if OK
- Roll back to 100% v1 if errors

#### 4. Circuit Breaker

**Logic:**
- Monitors deployment health
- If >50% tasks failing, automatically rolls back
- Prevents bad deployments from affecting production

**Configuration:**
```json
{
    "deploymentConfiguration": {
        "deploymentCircuitBreaker": {
            "enable": true,
            "rollback": true
        }
    }
}
```

---

### ECS vs EKS vs Other Options

#### Comparison Matrix

| Feature | ECS | EKS | App Runner | Lambda |
|---------|-----|-----|------------|--------|
| **Complexity** | Low | High | Very Low | Very Low |
| **Control** | Medium | High | Low | Low |
| **Kubernetes** | No | Yes | No | No |
| **Container Support** | Docker | Docker | Docker | OCI Images |
| **Serverless Option** | Fargate | Fargate | Built-in | Built-in |
| **Pricing** | Per task | Per cluster + nodes | Per request | Per invocation |
| **Best For** | AWS-native workloads | K8s expertise needed | Simple web apps | Event-driven |

#### Decision Tree

```
Do you need Kubernetes?
│
├── Yes → EKS
│         ├── Have K8s expertise? → EKS with EC2
│         └── Want serverless? → EKS with Fargate
│
└── No → Is it a simple web app?
         │
         ├── Yes → App Runner (simplest)
         │
         └── No → ECS
                  ├── Variable workloads → Fargate
                  └── Steady workloads → EC2 (cost savings)
```

**When to Use Each:**
- **ECS**: AWS-native experience, no K8s expertise needed, tight AWS integration
- **EKS**: Kubernetes compatibility, existing K8s manifests, K8s ecosystem tools
- **App Runner**: Zero infrastructure management, simple web apps, fastest time to production
- **Lambda**: Event-driven workloads, short-running tasks, extreme scale-to-zero

---

### Quick Reference Commands

#### Cluster Operations
```bash
# Create cluster
aws ecs create-cluster --cluster-name my-cluster

# List clusters
aws ecs list-clusters

# Delete cluster
aws ecs delete-cluster --cluster my-cluster
```

#### Service Operations
```bash
# Create service
aws ecs create-service --cluster my-cluster --service-name my-service \
    --task-definition my-task:1 --desired-count 2

# Update service (scale)
aws ecs update-service --cluster my-cluster --service my-service \
    --desired-count 5

# Force new deployment
aws ecs update-service --cluster my-cluster --service my-service \
    --force-new-deployment

# Delete service
aws ecs update-service --cluster my-cluster --service my-service \
    --desired-count 0
aws ecs delete-service --cluster my-cluster --service my-service
```

#### Task Operations
```bash
# List tasks
aws ecs list-tasks --cluster my-cluster

# Describe task
aws ecs describe-tasks --cluster my-cluster --tasks TASK_ARN

# Run standalone task
aws ecs run-task --cluster my-cluster --task-definition my-task:1

# Stop task
aws ecs stop-task --cluster my-cluster --task TASK_ARN
```

#### Debugging
```bash
# View logs
aws logs tail /ecs/my-app --follow

# Exec into container
aws ecs execute-command --cluster my-cluster --task TASK_ARN \
    --container app --interactive --command "/bin/sh"

# Check service events
aws ecs describe-services --cluster my-cluster --services my-service \
    --query 'services[0].events[0:10]'
```

---

## 10. Key Contacts and Resources

### Key Resources
-  Base images
-  Build and Deployment Process
- Deployment to Dev Cluster
- Integration Test Setup Namespaces
- Continuous Deployment for  Components
- API Testing Framework Test Harness Proposal (Based on K6)
- UI Test Automation Framework
- Creating e2e test cases
- Guidelines for components
- Access control in the services
- Helm charts | Best practices
-  Component list

---

## Checklist Summary

- [ ] Use Standard DevOps base OS images
- [ ] Set up standard CI pipeline with DevOps
- [ ] Set up standard CD pipeline with DevOps
- [ ] Deploy to team's K8s namespace
- [ ] Store secrets in Hashicorp Vault
- [ ] Follow Continuous Deployment process
- [ ] Build integration tests (API/UI/Component)
- [ ] Use QMetry for test reporting
- [ ] Define `/health` endpoint and metrics
- [ ] Review API endpoints with architect
- [ ] Follow API traceability requirements
- [ ] Use standard Helm Chart
- [ ] Define resource utilization (min/max)
- [ ] Document auto-scaling and replica counts
- [ ] Run Snyk scans in CI pipeline
- [ ] Incorporate BurpSuite scans in CD pipeline
- [ ] Review data security with architect
- [ ] Address High/Medium security issues before sprint ends
- [ ] Store source code in BitBucket (_WS account)
- [ ] Create separate git repository for each microservice
- [ ] Create independent git repository for libraries
- [ ] Follow language-specific source organization conventions
- [ ] Exclude secrets and environment-specific configs from source repos
- [ ] Exclude dependencies and tool-generated sources from source repos
- [ ] Include Dockerfile in microservice root
- [ ] Set up Jenkins pipeline for CI builds
- [ ] Configure builds on all commits
- [ ] Publish artifacts to appropriate repository (Docker/Nexus)
- [ ] Set up end-to-end integration test pipeline (daily schedule)
- [ ] Tag sources and images after successful integration tests
- [ ] Use Terraform for infrastructure deployment
- [ ] Use Helm for application deployment
- [ ] Maintain deployment sources in Git
- [ ] Ensure infrastructure can be destroyed and recreated from Git

---

## Notes

- All guidelines should be followed for any Docker container built for 
- Work closely with DevOps, QA Automation, and Architecture teams
- Security and testing are critical components of the process
- Early testing and documentation save time and prevent issues later

