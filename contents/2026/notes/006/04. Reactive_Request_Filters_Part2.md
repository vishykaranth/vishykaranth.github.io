# Reactive Request Filters: Path Rewriting and Header Transformation

## Part 2: Reactive Filter Architecture

The Platform Proxy Service implements reactive, non-blocking request/response filters using Spring Cloud Gateway's WebFlux framework. These filters handle path rewriting, header transformation, query parameter manipulation, and URI reconstruction in a fully reactive manner.

---

## 1. Spring Cloud Gateway Filter Architecture

### 1.1 GlobalFilter Interface

The system implements Spring Cloud Gateway's `GlobalFilter` interface for request/response interception:

```java
package org.springframework.cloud.gateway.filter;

public interface GlobalFilter {
    Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain);
}
```

### 1.2 Filter Ordering

Filters are ordered using the `Ordered` interface to control execution sequence:

```java
public class GlobalRequestFilter implements GlobalFilter, Ordered {
    
    @Override
    public int getOrder() {
        return -2;  // Higher priority (lower number = earlier execution)
    }
}
```

**Filter Execution Order:**
1. `GlobalRequestFilter` (Order: -2) - Processes incoming requests
2. Route matching and forwarding
3. `GlobalResponseFilter` (Order: -2) - Processes outgoing responses

---

## 2. GlobalRequestFilter - Request Processing

### 2.1 Complete Filter Implementation

```java
package ai.jiffy.proxy.filter;

import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.cloud.gateway.route.Route;
import org.springframework.core.Ordered;
import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.http.server.reactive.ServerHttpRequest.Builder;
import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.util.UriComponentsBuilder;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import org.slf4j.MDC;

public class GlobalRequestFilter implements GlobalFilter, Ordered {
    
    private static final Logger logger = LoggerFactory.getLogger(GlobalRequestFilter.class);
    
    private final RouteAuthCache routeAuthCache;
    private final FileHandlerService fileHandlerService;
    private final IAMTokenConfig iamTokenConfig;
    private final HelperService helperService;
    private final String domainUrl;
    
    public GlobalRequestFilter(RouteAuthCache routeAuthCache, 
            FileHandlerService fileHandlerService,
            IAMTokenConfig iamTokenConfig, 
            String domainUrl, 
            HelperService helperService) {
        this.routeAuthCache = routeAuthCache;
        this.fileHandlerService = fileHandlerService;
        this.iamTokenConfig = iamTokenConfig;
        this.domainUrl = domainUrl;
        this.helperService = helperService;
    }
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        logger.info("[Route Request Filter] Processing incoming request");
        
        ServerHttpRequest incomingRequest = exchange.getRequest();
        
        // Extract Jiffy headers for multi-tenant context
        String tenantId = Objects.requireNonNull(
            incomingRequest.getHeaders().get("X-Jiffy-Tenant-ID")).get(0);
        String appId = Objects.requireNonNull(
            incomingRequest.getHeaders().get("X-Jiffy-App-ID")).get(0);
        String userId = Objects.requireNonNull(
            incomingRequest.getHeaders().get("X-Jiffy-User-ID")).get(0);
        
        // Set MDC for logging context
        MDC.put("tenantId", tenantId);
        MDC.put("appId", appId);
        MDC.put("userId", userId);
        
        AuthInfo authInfo = AuthInfo.newBuilder()
            .setUserId(userId)
            .setTenantId(tenantId)
            .setAppId(appId)
            .build();
        
        // Log request body and headers (reactive)
        Flux<DataBuffer> reqBody = incomingRequest.getBody();
        Utils.logRequestBody(reqBody, "Incoming");
        Utils.logHeaders(incomingRequest.getHeaders(), "Incoming");
        
        // Get matched route from exchange
        Route route = (Route) exchange.getAttributes().get(GATEWAY_ROUTE_ATTR);
        logger.info("[Route Request Filter] Rewriting incoming request path");
        
        // Decode path (may contain spaces and special characters)
        String path = incomingRequest.getURI().getPath();
        
        // Fetch connector configuration from cache/config manager
        Map<String, Object> configuration = getConnectorConfiguration(
            path, authInfo, route.getMetadata());
        logger.info("[Route Request Filter] Configuration fetch completed");
        
        // Get base URL from configuration (supports different environments)
        URI baseURI = getBaseURI(configuration);
        UriComponentsBuilder uriComponentsBuilder = getUriComponentsBuilder(baseURI, route);
        
        // Update route with base URI from configuration
        Route newRoute = updateRouteWithBaseURI(exchange, route, baseURI);
        
        // Rewrite the path: remove /api/external/providerName/serviceName prefix
        String externalPath = pathReWrite(exchange, newRoute);
        logger.info("[Route Request Filter] Path rewrite completed: {}", externalPath);
        
        // Handle query parameters
        String rawQuery = incomingRequest.getURI().getQuery();
        if (rawQuery != null) {
            logger.info("[Route Request Filter] Processing query params: {}", rawQuery);
            
            // Spring Cloud Gateway removes plus signs (+) from query params
            // We need to preserve them by parsing raw query string
            String[] queryParts = rawQuery.split("&");
            for (String query : queryParts) {
                // Split on first "=" only (value may contain "=")
                String[] parts = query.split("=", 2);
                uriComponentsBuilder.queryParam(
                    parts[0], 
                    parts.length == 2 ? parts[1] : null
                );
            }
            logger.info("[Route Request Filter] Query params updated");
        }
        
        // Build final URI
        URI uri = uriComponentsBuilder.build().toUri();
        
        // Build external request with mutated URI and path
        Builder requestBuilder = incomingRequest.mutate()
            .uri(uri)
            .path(externalPath);
        
        logger.info("[Route Request Filter] Adding authentication and additional headers");
        
        // Add authentication and additional headers
        addAdditionalHeaders(configuration, requestBuilder);
        
        // Build final request
        ServerHttpRequest request = requestBuilder
            .contextPath("/")
            .build();
        
        // Log routing information
        Set<URI> uris = exchange.getAttributeOrDefault(
            GATEWAY_ORIGINAL_REQUEST_URL_ATTR, Collections.emptySet());
        String originalUri = uris.isEmpty() ? "Unknown" : uris.iterator().next().toString();
        logger.info("[Route Request Filter] Incoming request {} routed to: {}", 
            originalUri, request.getURI());
        
        // Build cache key for configuration
        String configKey = getCacheKey(path, tenantId, appId, 
            CACHE_TYPE_CONFIG + "#" + configuration.get(ENV).toString(), 
            route.getMetadata());
        
        // Handle custom request body transformation (e.g., DocuSign)
        if (!route.getMetadata().isEmpty() && 
            route.getMetadata().containsKey("REQUEST_BODY")) {
            
            configuration.put("domainUrl", domainUrl);
            logger.info("[Route Request Filter] Processing custom request body");
            
            CustomRequestBody customRequest = getCustomRequest(
                route.getMetadata().get("REQUEST_BODY").toString(),
                exchange,
                fileHandlerService,
                authInfo,
                request.getHeaders(),
                configuration
            );
            
            RequestDecorator requestDecorator = new RequestDecorator(
                request,
                customRequest.getBodyBytes(),
                customRequest.getHeaders(),
                routeAuthCache,
                configKey,
                iamTokenConfig
            );
            
            return chain.filter(exchange.mutate().request(requestDecorator).build());
        }
        
        // Standard request (no custom body transformation)
        RequestDecorator requestDecorator = new RequestDecorator(
            request, 
            null,
            request.getHeaders(),
            routeAuthCache,
            configKey,
            iamTokenConfig
        );
        
        return chain.filter(exchange.mutate()
            .request(requestDecorator)
            .build());
    }
}
```

---

## 3. Path Rewriting Implementation

### 3.1 Path Rewrite Logic

The `pathReWrite` method transforms internal API paths to external service paths:

```java
package ai.jiffy.proxy.filter;

public class Utils {
    
    public static final int PATH_SPLIT_INDEX_NUMBER = 6;
    
    /**
     * Rewrites the path of the incoming request based on the route configuration.
     * 
     * Example transformation:
     * Input:  /api/external/salesforce/contacts/v1/accounts/123
     * Output: /services/data/v58.0/accounts/123
     * 
     * @param exchange The ServerWebExchange object
     * @param route The Route object containing target URI
     * @return The rewritten external path
     */
    public static String pathReWrite(ServerWebExchange exchange, Route route) {
        ServerHttpRequest req = exchange.getRequest();
        
        // Preserve original request URL for logging
        addOriginalRequestUrl(exchange, req.getURI());
        
        // Get raw path (preserves encoded characters)
        String path = req.getURI().getRawPath();
        String[] pathParts = path.split("/");
        
        // Extract path segments after /api/external/providerName/serviceName
        // PATH_SPLIT_INDEX_NUMBER = 6 means we skip:
        // [0] = "" (empty from leading slash)
        // [1] = "api"
        // [2] = "external"
        // [3] = "providerName"
        // [4] = "serviceName"
        // [5] = "version" (optional)
        // [6+] = actual API path
        String newPath = "/" + String.join("/", 
            Arrays.copyOfRange(pathParts, PATH_SPLIT_INDEX_NUMBER, pathParts.length));
        
        // Preserve trailing slash if present
        if (path.endsWith("/")) {
            newPath = newPath + "/";
        }
        
        // Get base URI from route
        URI uri = route.getUri();
        String uriRawPath = uri.getRawPath();
        
        // Combine base URI path with rewritten path
        String externalPath = uriRawPath + newPath;
        
        // Create mutated request with new path
        ServerHttpRequest request = req.mutate()
            .uri(uri)
            .path(externalPath)
            .contextPath("/")
            .build();
        
        // Store modified URI in exchange attributes
        exchange.getAttributes().put(GATEWAY_REQUEST_URL_ATTR, request.getURI());
        
        return externalPath;
    }
}
```

### 3.2 Path Rewriting Examples

**Example 1: Salesforce API**
```
Incoming:  /api/external/salesforce/contacts/v1/sobjects/Account/001XX000003DGbY
Base URI:   https://instance.salesforce.com
Route Path: /services/data/v58.0
Result:     https://instance.salesforce.com/services/data/v58.0/sobjects/Account/001XX000003DGbY
```

**Example 2: REST API with Query Parameters**
```
Incoming:  /api/external/stripe/payments/v1/charges?limit=10&starting_after=ch_123
Base URI:  https://api.stripe.com
Route Path: /v1
Result:    https://api.stripe.com/v1/charges?limit=10&starting_after=ch_123
```

**Example 3: Nested Resource Path**
```
Incoming:  /api/external/github/repos/v3/repos/owner/repo/issues/123/comments
Base URI:  https://api.github.com
Route Path: /repos
Result:    https://api.github.com/repos/owner/repo/issues/123/comments
```

---

## 4. Header Transformation

### 4.1 Adding Authentication Headers

```java
/**
 * Adds authentication and additional headers to the request
 */
private void addAdditionalHeaders(Map<String, Object> configuration, 
        Builder requestBuilder) {
    
    // Get authentication provider
    AccessTokenProvider accessTokenProvider = getAccessTokenProvider(configuration);
    
    // Get additional headers required by the provider
    // (e.g., API keys in custom headers, OAuth scopes, etc.)
    Map<String, String> additionalAuthHeaders = 
        accessTokenProvider.getAdditionalAuthHeaders();
    
    if (additionalAuthHeaders != null && !additionalAuthHeaders.isEmpty()) {
        for (Entry<String, String> entry : additionalAuthHeaders.entrySet()) {
            requestBuilder.header(entry.getKey(), entry.getValue());
        }
    }
}
```

### 4.2 Header Transformation Examples

**Example 1: API Key in Custom Header**
```java
// Provider requires API key in X-API-Key header
Map<String, String> headers = new HashMap<>();
headers.put("X-API-Key", apiKey);
headers.put("X-Request-ID", UUID.randomUUID().toString());
return headers;
```

**Example 2: OAuth 2.0 with Custom Headers**
```java
// OAuth provider requires additional headers
Map<String, String> headers = new HashMap<>();
headers.put("Authorization", "Bearer " + accessToken);
headers.put("X-Client-Version", "1.0.0");
headers.put("Accept", "application/json");
return headers;
```

**Example 3: Preserving Original Headers**
```java
// In RequestDecorator.getHeaders()
HttpHeaders newHeaders = new HttpHeaders();
newHeaders.putAll(headers);  // Preserve original headers

// Add authentication
newHeaders.put("Authorization", "Bearer " + token);

// Add provider-specific headers
additionalHeaders.forEach((key, value) -> 
    newHeaders.put(key, Collections.singletonList(value)));

return newHeaders;
```

---

## 5. URI Reconstruction

### 5.1 Base URI from Configuration

```java
/**
 * Extracts base URI from configuration
 * Supports environment-specific base URLs (dev, qa, production)
 */
private static URI getBaseURI(Map<String, Object> configuration) {
    String baseUrlObject = (String) configuration.getOrDefault(BASE_URL, null);
    
    if (baseUrlObject == null) {
        logger.info("[Route Request Filter] Base URL not found in configuration, " +
            "falling back to URI from database");
        return null;  // Will use route URI from database
    }
    
    URI baseURI;
    try {
        baseURI = new URI(baseUrlObject);
    } catch (Exception e) {
        throw new ProxyException("Error while reading base URL from configuration: " + 
            e.getMessage());
    }
    return baseURI;
}
```

### 5.2 URI Components Builder

```java
/**
 * Builds URI components from base URI or route URI
 */
private static UriComponentsBuilder getUriComponentsBuilder(URI baseURI, Route route) {
    // Fallback to database URI if configuration base URL not found
    if (baseURI == null) {
        logger.info("[Route Request Filter] Using URI from database: {}", route.getUri());
        return UriComponentsBuilder.fromUri(route.getUri());
    }
    return UriComponentsBuilder.fromUri(baseURI);
}
```

### 5.3 Route Update with Base URI

```java
/**
 * Updates the route with base URI from configuration
 * This ensures Spring Cloud Gateway uses the correct target URI
 */
private static Route updateRouteWithBaseURI(ServerWebExchange exchange, 
        Route route, URI baseURI) {
    
    if (baseURI == null) {
        logger.info("[Route Request Filter] Base URL not found, using default route");
        return route;  // Return original route
    }
    
    // Build new route with updated URI
    Route newRoute = Route.async()
        .id(route.getId())
        .uri(baseURI)  // Updated URI from configuration
        .order(route.getOrder())
        .asyncPredicate(route.getPredicate())
        .filters(route.getFilters())
        .metadata(route.getMetadata())
        .build();
    
    // Update exchange with new route
    exchange.getAttributes().put(GATEWAY_ROUTE_ATTR, newRoute);
    
    return newRoute;
}
```

---

## 6. Query Parameter Handling

### 6.1 Query Parameter Preservation

Spring Cloud Gateway automatically URL-encodes query parameters, which can cause issues with special characters like `+`. The filter preserves the raw query string:

```java
// Get raw query string (before Spring encoding)
String rawQuery = incomingRequest.getURI().getQuery();

if (rawQuery != null) {
    logger.info("[Route Request Filter] Raw query params: {}", rawQuery);
    
    // Split by "&" to get individual parameters
    String[] queryParts = rawQuery.split("&");
    
    for (String query : queryParts) {
        // Split on first "=" only (value may contain "=")
        String[] parts = query.split("=", 2);
        String paramName = parts[0];
        String paramValue = parts.length == 2 ? parts[1] : null;
        
        // Add to URI builder (will be properly encoded)
        uriComponentsBuilder.queryParam(paramName, paramValue);
    }
    
    logger.info("[Route Request Filter] Query params updated");
}
```

### 6.2 Query Parameter Examples

**Example 1: Simple Parameters**
```
Input:  ?name=John&age=30
Output: ?name=John&age=30
```

**Example 2: Encoded Values**
```
Input:  ?search=hello+world&filter=active
Output: ?search=hello%2Bworld&filter=active
```

**Example 3: Complex Values**
```
Input:  ?ids=1,2,3&metadata={"key":"value"}
Output: ?ids=1%2C2%2C3&metadata=%7B%22key%22%3A%22value%22%7D
```

---

## 7. Reactive Request Body Logging

### 7.1 Non-Blocking Body Logging

```java
/**
 * Logs request body in a non-blocking, reactive manner
 */
public static void logRequestBody(Flux<DataBuffer> dataBufferFlux, String message) {
    // Join all DataBuffers into a single buffer
    Mono<Object> stringMono = DataBufferUtils.join(dataBufferFlux)
        .map(dataBuffer -> {
            byte[] bytes = new byte[dataBuffer.readableByteCount()];
            dataBuffer.read(bytes);
            DataBufferUtils.release(dataBuffer);  // Release buffer
            return new String(bytes);
        });
    
    // Subscribe asynchronously (non-blocking)
    stringMono.subscribe(
        result -> logger.debug("[Filter Utils {}] Request Body: {}", message, result),
        throwable -> logger.error("[Filter Utils] Request Body Error: {}", 
            throwable.getMessage())
    );
}
```

### 7.2 Header Logging

```java
/**
 * Logs HTTP headers in JSON format
 */
public static void logHeaders(HttpHeaders headers, String message) {
    try {
        Map<String, String> singleValueMap = headers.toSingleValueMap();
        String headerString = mapper.writeValueAsString(singleValueMap);
        logger.debug("[Filter Utils {}] Headers: {}", message, headerString);
    } catch (Exception ex) {
        // Silently fail logging (non-critical)
        logger.warn("[Filter Utils] Error logging headers: {}", ex.getMessage());
    }
}
```

---

## 8. Configuration Retrieval

### 8.1 Connector Configuration Loading

```java
/**
 * Retrieves connector configuration from cache
 * Falls back to database/config manager if cache miss
 */
private Map<String, Object> getConnectorConfiguration(String path, 
        AuthInfo authInfo, Map<String, Object> metadata) {
    
    // Get app environment (dev, qa, production)
    String env = getEnvCache(path, authInfo, metadata);
    
    // Build cache key
    String key = getCacheKey(path, authInfo.getTenantId(), authInfo.getAppId(), 
        CACHE_TYPE_CONFIG + "#" + env, metadata);
    
    try {
        // Get from cache (loads from DB/config manager if missing)
        return routeAuthCache.get(key);
    } catch (ExecutionException e) {
        throw new ProxyException("Error fetching connector configuration: " + 
            e.getMessage());
    }
}
```

### 8.2 Environment Cache

```java
/**
 * Gets environment-specific configuration
 */
private String getEnvCache(String path, AuthInfo authInfo, 
        Map<String, Object> metadata) {
    try {
        // Get app environment from helper service
        String appEnv = helperService.getAppEnv(authInfo);
        
        // Build environment cache key
        String envKey = getCacheKey(path, authInfo.getTenantId(), 
            authInfo.getAppId(), CACHE_TYPE_ENV + "#" + appEnv, metadata);
        
        // Get environment data from cache
        Map<String, Object> data = routeAuthCache.get(envKey);
        return data.get(ENV).toString();
        
    } catch (JsonProcessingException | ExecutionException e) {
        throw new ProxyException("Error fetching environment configuration: " + 
            e.getMessage());
    }
}
```

---

## 9. Performance Optimizations

### 9.1 Reactive Non-Blocking Operations

- **Flux/Mono**: All operations use reactive streams
- **No Thread Blocking**: No `.block()` calls in filter chain
- **Backpressure Handling**: Automatic backpressure management
- **Memory Efficient**: DataBuffers released after processing

### 9.2 Caching Strategy

- **Configuration Cache**: 30-minute TTL reduces database queries
- **Token Cache**: Prevents redundant token requests
- **Environment Cache**: Caches environment-specific settings

### 9.3 Lazy Evaluation

- **Request Body**: Only read when needed (custom transformations)
- **Headers**: Only transformed when required
- **Configuration**: Loaded on-demand from cache

---

## 10. Error Handling

### 10.1 Exception Propagation

```java
try {
    // Configuration retrieval
    Map<String, Object> configuration = getConnectorConfiguration(...);
    
    // URI building
    URI baseURI = getBaseURI(configuration);
    
    // Path rewriting
    String externalPath = pathReWrite(exchange, newRoute);
    
} catch (ProxyException e) {
    // Wrap and propagate
    throw new ProxyException("Error in request filter: " + e.getMessage(), e);
}
```

### 10.2 Fallback Mechanisms

- **Base URI**: Falls back to database URI if configuration missing
- **Route**: Uses original route if base URI not found
- **Headers**: Preserves original headers if transformation fails

---

## Summary

The reactive request filter architecture provides:

1. **Path Rewriting**: Transforms internal paths to external service paths
2. **Header Transformation**: Adds authentication and provider-specific headers
3. **URI Reconstruction**: Builds target URIs from configuration
4. **Query Parameter Handling**: Preserves and properly encodes query parameters
5. **Reactive Processing**: Fully non-blocking, backpressure-aware operations
6. **Configuration Management**: Cached configuration retrieval with fallbacks
7. **Error Handling**: Graceful degradation with fallback mechanisms

This architecture ensures high performance, reliability, and flexibility for routing requests to diverse external service providers.

