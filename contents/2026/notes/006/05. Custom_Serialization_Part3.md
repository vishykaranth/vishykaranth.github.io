# Custom Serialization: Request/Response Body Transformation

## Part 3: Custom Body Transformation Architecture

The Platform Proxy Service implements a pluggable custom serialization system that allows provider-specific request and response body transformations. This enables integration with services that require non-standard data formats, file handling, or complex payload structures.

---

## 1. Custom Serialization Architecture

### 1.1 CustomRequestBody Interface

The system defines interfaces for custom request and response body transformations:

```java
package ai.jiffy.proxy.custom.requestbody;

import java.util.Map;
import org.springframework.http.HttpHeaders;

/**
 * Interface for custom request body transformations
 * Implementations handle provider-specific request formatting
 */
public interface CustomRequestBody {
    /**
     * Returns the transformed request body as byte array
     * @return Transformed request body bytes
     */
    byte[] getBodyBytes();
    
    /**
     * Returns modified headers for the transformed request
     * @return HttpHeaders with updated Content-Length, Content-Type, etc.
     */
    HttpHeaders getHeaders();
}
```

### 1.2 CustomResponseBody Interface

```java
package ai.jiffy.proxy.custom.responsebody;

import ai.jiffy.proxy.service.FileHandlerService;
import jiffy.model.ApplicationOuterClass.AuthInfo;

/**
 * Interface for custom response body transformations
 * Implementations handle provider-specific response formatting
 */
public interface CustomResponseBody {
    /**
     * Returns the transformed response body as byte array
     * @return Transformed response body bytes
     */
    byte[] getResponseBytes();
}
```

---

## 2. Dynamic Provider Instantiation

### 2.1 Request Body Provider Factory

```java
package ai.jiffy.proxy.filter;

public class Utils {
    
    /**
     * Dynamically instantiates a CustomRequestBody implementation
     * 
     * @param className Fully qualified class name of the custom request body handler
     * @param exchange ServerWebExchange for accessing request data
     * @param fileHandlerService Service for file operations
     * @param authInfo Authentication information (tenant, app, user)
     * @param headers Original request headers
     * @param configuration Route configuration
     * @return CustomRequestBody instance
     */
    public static CustomRequestBody getCustomRequest(
            String className, 
            ServerWebExchange exchange,
            FileHandlerService fileHandlerService, 
            AuthInfo authInfo, 
            HttpHeaders headers,
            Map<String, Object> configuration) {
        
        try {
            // Load the custom request body class
            Class<?> c = Class.forName(className);
            Class<? extends CustomRequestBody> customReqBodyClass = 
                c.asSubclass(CustomRequestBody.class);
            
            // Instantiate using constructor:
            // (ServerWebExchange, FileHandlerService, AuthInfo, HttpHeaders, Map)
            return customReqBodyClass.getConstructor(
                ServerWebExchange.class, 
                FileHandlerService.class, 
                AuthInfo.class, 
                HttpHeaders.class, 
                Map.class
            ).newInstance(exchange, fileHandlerService, authInfo, headers, configuration);
            
        } catch (Exception ex) {
            throw new ProxyException(
                "Error instantiating custom request body handler: " + getErrorMessage(ex));
        }
    }
}
```

### 2.2 Response Body Provider Factory

```java
/**
 * Dynamically instantiates a CustomResponseBody implementation
 */
public static CustomResponseBody getCustomResponse(
        String className, 
        byte[] content,
        FileHandlerService fileHandlerService, 
        AuthInfo authInfo) {
    
    try {
        // Load the custom response body class
        Class<?> c = Class.forName(className);
        Class<? extends CustomResponseBody> customRespBodyClass = 
            c.asSubclass(CustomResponseBody.class);
        
        // Instantiate using constructor:
        // (byte[], FileHandlerService, AuthInfo)
        return customRespBodyClass.getConstructor(
            byte[].class, 
            FileHandlerService.class, 
            AuthInfo.class
        ).newInstance(content, fileHandlerService, authInfo);
        
    } catch (Exception ex) {
        throw new ProxyException(
            "Error instantiating custom response body handler: " + getErrorMessage(ex));
    }
}
```

---

## 3. DocuSign Request Body Transformation

### 3.1 DocuSign Request Body Implementation

DocuSign requires special handling for envelope creation with file attachments:

```java
package ai.jiffy.proxy.custom.requestbody.docusign;

import ai.jiffy.proxy.custom.requestbody.CustomRequestBody;
import ai.jiffy.proxy.service.FileHandlerService;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import jiffy.model.ApplicationOuterClass.AuthInfo;
import org.springframework.http.HttpHeaders;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Base64;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicReference;

public class DocusignRequestBody implements CustomRequestBody {
    
    private static final Logger logger = LoggerFactory.getLogger(DocusignRequestBody.class);
    private static final ObjectMapper mapper = new ObjectMapper();
    public static final String DOCUMENTS = "documents";
    
    private final ObjectNode newRequestBody;
    private final HttpHeaders headers;
    
    public DocusignRequestBody(ServerWebExchange serverWebExchange,
            FileHandlerService fileHandlerService, 
            AuthInfo authInfo, 
            HttpHeaders headers, 
            Map<String, Object> configuration) {
        this.headers = headers;
        this.newRequestBody = read(serverWebExchange, configuration, 
            fileHandlerService, authInfo);
    }
    
    /**
     * Reads and transforms the incoming request body
     */
    private ObjectNode read(ServerWebExchange serverWebExchange, 
            Map<String, Object> configuration,
            FileHandlerService fileHandlerService, 
            AuthInfo authInfo) {
        
        AtomicReference<ObjectNode> requestBody = new AtomicReference<>(
            new ObjectMapper().createObjectNode());
        
        // Convert reactive request body to JsonNode
        Mono<JsonNode> jsonNodeMono = convertToFluxJsonNode(
            serverWebExchange.getRequest().getBody());
        
        // Subscribe to get the JSON node (blocking for simplicity, 
        // but could be made fully reactive)
        jsonNodeMono.subscribe(node -> {
            requestBody.set((ObjectNode) node);
        });
        
        ObjectNode intermittentObject = requestBody.get();
        
        // Transform the request body
        return getNewRequestBody(intermittentObject, configuration, 
            fileHandlerService, authInfo);
    }
    
    /**
     * Transforms the request body:
     * 1. Downloads files from Jiffy Drive
     * 2. Converts files to Base64
     * 3. Adds files to envelope documents
     * 4. Adds event notification callback URL
     */
    public ObjectNode getNewRequestBody(ObjectNode intermittentObject, 
            Map<String, Object> configuration,
            FileHandlerService fileHandlerService, 
            AuthInfo authInfo) {
        
        List<Map<String, String>> newDocuments = new ArrayList<>();
        
        // Process documents array if present
        if (intermittentObject.has(DOCUMENTS)) {
            ArrayNode documents = (ArrayNode) intermittentObject.get(DOCUMENTS);
            
            for (JsonNode document : documents) {
                // Get file path from document
                String path = document.get("path").asText();
                
                // Download file from Jiffy Drive
                byte[] fileContent = fileHandlerService.downloadFilesAsByteArray(
                    path, 
                    authInfo.getTenantId(), 
                    authInfo.getAppId(), 
                    authInfo.getUserId()
                );
                
                // Convert to Base64 (DocuSign requirement)
                String base64Content = Base64.getEncoder().encodeToString(fileContent);
                
                // Extract filename from path
                String filePath = document.get("path").asText();
                String fileName = filePath.substring(filePath.lastIndexOf('/') + 1);
                
                // Build document map
                HashMap<String, String> newDocument = new HashMap<>();
                newDocument.put("name", fileName);
                newDocument.put("documentId", document.get("id").asText());
                newDocument.put("documentBase64", base64Content);
                newDocuments.add(newDocument);
            }
        }
        
        // Convert to JsonNode for manipulation
        JsonNode createEnvelopeRequest = mapper.convertValue(intermittentObject, JsonNode.class);
        
        // Extract envelope object
        ObjectNode envelope = mapper.convertValue(
            createEnvelopeRequest.get("envelope"), ObjectNode.class);
        
        // Add transformed documents to envelope
        if (!newDocuments.isEmpty()) {
            ArrayNode envelopeDocuments = mapper.convertValue(newDocuments, ArrayNode.class);
            envelope.set("documents", envelopeDocuments);
        }
        
        // Set default status if not present
        if (!envelope.has("status")) {
            envelope.put("status", "sent");
        }
        
        // Add event notification callback URL
        String callBackUrl = getCallBackUrl(configuration, authInfo);
        EventNotification eventNotification = EventNotification.builder()
            .url(callBackUrl)
            .events(Arrays.asList(
                "recipient-completed", 
                "recipient-delivered", 
                "recipient-declined"
            ))
            .build();
        
        JsonNode eventNotificationNode = mapper.valueToTree(eventNotification);
        envelope.set("eventNotification", eventNotificationNode);
        
        return envelope;
    }
    
    /**
     * Generates callback URL for DocuSign webhooks
     */
    private String getCallBackUrl(Map<String, Object> configuration, AuthInfo authInfo) {
        String domainUrl = configuration.get("domainUrl").toString();
        return String.format(
            "%s/proxy/v1/listener/tenant/%s/app/%s/topic/docusign",
            domainUrl, 
            authInfo.getTenantId(), 
            authInfo.getAppId()
        );
    }
    
    @Override
    public byte[] getBodyBytes() {
        try {
            String newBody = mapper.writeValueAsString(newRequestBody);
            return newBody.getBytes();
        } catch (IOException e) {
            throw new ProxyException("Error serializing DocuSign request body: " + 
                e.getMessage());
        }
    }
    
    @Override
    public HttpHeaders getHeaders() {
        try {
            String newBody = mapper.writeValueAsString(newRequestBody);
            HttpHeaders httpHeaders = new HttpHeaders();
            httpHeaders.putAll(headers);
            
            // Update Content-Length with new body size
            httpHeaders.setContentLength(newBody.getBytes().length);
            
            // Ensure Content-Type is application/json
            httpHeaders.setContentType(MediaType.APPLICATION_JSON);
            
            return httpHeaders;
        } catch (Exception ex) {
            throw new ProxyException("Error preparing DocuSign request headers: " + 
                ex.getMessage());
        }
    }
}
```

### 3.2 DocuSign Request Transformation Example

**Input Request:**
```json
{
  "envelope": {
    "emailSubject": "Please sign this document",
    "status": "sent"
  },
  "documents": [
    {
      "id": "1",
      "path": "private/tenant-123/app-456/contract.pdf"
    }
  ]
}
```

**Transformed Request:**
```json
{
  "emailSubject": "Please sign this document",
  "status": "sent",
  "documents": [
    {
      "name": "contract.pdf",
      "documentId": "1",
      "documentBase64": "JVBERi0xLjQKJeLjz9MKMSAwIG9iago8PC..."
    }
  ],
  "eventNotification": {
    "url": "https://domain.com/proxy/v1/listener/tenant/123/app/456/topic/docusign",
    "events": ["recipient-completed", "recipient-delivered", "recipient-declined"]
  }
}
```

---

## 4. DocuSign Response Body Transformation

### 4.1 DocuSign Download Response Implementation

DocuSign returns ZIP files for document downloads. The system transforms these to Jiffy Drive file references:

```java
package ai.jiffy.proxy.custom.responsebody.docusign;

import ai.jiffy.proxy.custom.responsebody.CustomResponseBody;
import ai.jiffy.proxy.drive.UploadResponse;
import ai.jiffy.proxy.service.FileHandlerService;
import com.fasterxml.jackson.databind.ObjectMapper;
import jiffy.model.ApplicationOuterClass.AuthInfo;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

public class DocusignDownloadResponse implements CustomResponseBody {
    
    private static final ObjectMapper mapper = new ObjectMapper();
    
    private final FileHandlerService fileHandlerService;
    private final AuthInfo authInfo;
    private final byte[] content;  // ZIP file content from DocuSign
    
    public DocusignDownloadResponse(byte[] content, 
            FileHandlerService fileHandlerService, 
            AuthInfo authInfo) {
        this.fileHandlerService = fileHandlerService;
        this.authInfo = authInfo;
        this.content = content;
    }
    
    /**
     * Transforms DocuSign ZIP file response to Jiffy Drive file reference
     */
    @Override
    public byte[] getResponseBytes() {
        try {
            // Generate unique file path
            String uuid = UUID.randomUUID().toString().replace("-", "");
            String path = String.format("private/%s/%s.zip", uuid, uuid);
            
            // Upload ZIP file to Jiffy Drive
            UploadResponse uploadResponse = fileHandlerService.uploadFileBytes(
                path, 
                content, 
                authInfo
            );
            
            // Build response with file reference
            Map<String, String> response = new HashMap<>();
            response.put("path", path);
            response.put("tenantId", uploadResponse.getBucket().getTenantId());
            response.put("appId", uploadResponse.getBucket().getAppId());
            
            // Serialize to JSON
            String respString = mapper.writeValueAsString(response);
            return respString.getBytes();
            
        } catch (Exception ex) {
            throw new ProxyException("Error processing DocuSign download response: " + 
                ex.getMessage());
        }
    }
}
```

### 4.2 DocuSign Response Transformation Example

**Input Response (ZIP file bytes):**
```
[ZIP file binary content]
Content-Type: application/zip
```

**Transformed Response:**
```json
{
  "path": "private/550e8400e29b41d4a716446655440000/550e8400e29b41d4a716446655440000.zip",
  "tenantId": "tenant-123",
  "appId": "app-456"
}
```

---

## 5. Request Decorator Integration

### 5.1 Custom Request Body in Request Decorator

The `GlobalRequestFilter` integrates custom request body transformation:

```java
// In GlobalRequestFilter.filter()

// Check if custom request body transformation is needed
if (!route.getMetadata().isEmpty() && 
    route.getMetadata().containsKey("REQUEST_BODY")) {
    
    configuration.put("domainUrl", domainUrl);
    logger.info("[Route Request Filter] Processing custom request body");
    
    // Instantiate custom request body handler
    CustomRequestBody customRequest = getCustomRequest(
        route.getMetadata().get("REQUEST_BODY").toString(),  // Class name
        exchange,
        fileHandlerService,
        authInfo,
        request.getHeaders(),
        configuration
    );
    
    // Create request decorator with transformed body
    RequestDecorator requestDecorator = new RequestDecorator(
        request,
        customRequest.getBodyBytes(),      // Transformed body
        customRequest.getHeaders(),        // Updated headers
        routeAuthCache,
        configKey,
        iamTokenConfig
    );
    
    return chain.filter(exchange.mutate().request(requestDecorator).build());
}
```

### 5.2 Request Decorator Body Handling

```java
// In RequestDecorator.getBody()

@Override
public Flux<DataBuffer> getBody() {
    // If custom body transformation was applied, use transformed body
    if (body != null) {
        DefaultDataBufferFactory factory = new DefaultDataBufferFactory();
        DefaultDataBuffer buffer = factory.wrap(body);
        return Flux.just(buffer);
    }
    // Otherwise, use original request body
    return super.getBody();
}
```

---

## 6. Response Decorator Integration

### 6.1 Custom Response Body in Response Decorator

The `GlobalResponseFilter` integrates custom response body transformation:

```java
// In GlobalResponseFilter.filter()

return chain.filter(exchange.mutate().response(
    new ResponseDecorator(
        exchange.getRequest(),
        exchange.getResponse(),
        authInfo,
        fileHandlerService,
        routeAuthCache,
        envKey,
        configKey, 
        route.getMetadata()  // Contains RESPONSE_BODY class name
    )
).build());
```

### 6.2 Response Decorator Write Handling

```java
// In ResponseDecorator.writeWith()

@Override
public Mono<Void> writeWith(Publisher<? extends DataBuffer> body) {
    logger.info("[Response Decorator] Checking for custom response transformation");
    
    // Check if custom response body transformation is needed
    if (!metadata.isEmpty() && body instanceof Flux<? extends DataBuffer> fluxBody) {
        if (metadata.containsKey("RESPONSE_BODY")) {
            logger.info("[Response Decorator] Processing custom response body");
            
            // Buffer all DataBuffers and transform
            return super.writeWith(fluxBody.buffer().map(dataBuffers -> {
                // Join all buffers into single buffer
                DefaultDataBuffer joinedBuffer = 
                    new DefaultDataBufferFactory().join(dataBuffers);
                
                // Extract content
                byte[] content = new byte[joinedBuffer.readableByteCount()];
                joinedBuffer.read(content);
                
                // Instantiate custom response body handler
                CustomResponseBody customResponse = getCustomResponse(
                    metadata.get("RESPONSE_BODY").toString(),  // Class name
                    content,
                    fileHandlerService,
                    authInfo
                );
                
                // Get transformed response bytes
                byte[] responseBytes = customResponse.getResponseBytes();
                
                // Wrap in DataBuffer
                DefaultDataBufferFactory dataBufferFactory = 
                    new DefaultDataBufferFactory();
                return dataBufferFactory.wrap(responseBytes);
            }));
        }
    }
    
    logger.info("[Response Decorator] No custom transformation, using original response");
    return super.writeWith(body);
}
```

### 6.3 Response Header Updates

```java
// In ResponseDecorator.beforeCommit()

@Override
public void beforeCommit(Supplier<? extends Mono<Void>> action) {
    super.beforeCommit(action);
    
    logger.info("[Response Decorator] Updating response headers before commit");
    
    // Handle custom response body transformations
    if (!metadata.isEmpty() && metadata.containsKey("RESPONSE_BODY")) {
        String responseBodyClass = metadata.get("RESPONSE_BODY").toString();
        
        // DocuSign and AppXtender downloads need JSON content type
        if (responseBodyClass.equals(
                "ai.jiffy.proxy.custom.responsebody.docusign.DocusignDownloadResponse") ||
            responseBodyClass.equals(
                "ai.jiffy.proxy.custom.responsebody.appxtender.FileDownloadResponseBody")) {
            
            HttpHeaders headers = getDelegate().getHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);
            headers.remove("Content-Length");  // Let framework calculate
        }
    }
    
    // Invalidate cache on errors
    if (Objects.requireNonNull(getDelegate().getStatusCode()).isError()) {
        logger.info("[ResponseDecorator] External call failed, clearing cache");
        routeAuthCache.delete(envKey);
        routeAuthCache.delete(configKey);
    }
}
```

---

## 7. Additional Custom Body Examples

### 7.1 Form Data Request Body

```java
package ai.jiffy.proxy.custom.requestbody;

public class FormDataRequestBody implements CustomRequestBody {
    
    private final byte[] bodyBytes;
    private final HttpHeaders headers;
    
    public FormDataRequestBody(ServerWebExchange exchange, 
            FileHandlerService fileHandlerService,
            AuthInfo authInfo, 
            HttpHeaders headers, 
            Map<String, Object> configuration) {
        
        // Convert JSON to form data
        Mono<JsonNode> jsonNodeMono = convertToFluxJsonNode(
            exchange.getRequest().getBody());
        
        AtomicReference<byte[]> bodyRef = new AtomicReference<>();
        jsonNodeMono.subscribe(node -> {
            // Build form data from JSON
            StringBuilder formData = new StringBuilder();
            node.fields().forEachRemaining(entry -> {
                if (formData.length() > 0) {
                    formData.append("&");
                }
                formData.append(URLEncoder.encode(entry.getKey(), StandardCharsets.UTF_8));
                formData.append("=");
                formData.append(URLEncoder.encode(entry.getValue().asText(), 
                    StandardCharsets.UTF_8));
            });
            bodyRef.set(formData.toString().getBytes());
        });
        
        this.bodyBytes = bodyRef.get();
        
        // Update headers for form data
        HttpHeaders newHeaders = new HttpHeaders();
        newHeaders.putAll(headers);
        newHeaders.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
        newHeaders.setContentLength(this.bodyBytes.length);
        this.headers = newHeaders;
    }
    
    @Override
    public byte[] getBodyBytes() {
        return bodyBytes;
    }
    
    @Override
    public HttpHeaders getHeaders() {
        return headers;
    }
}
```

### 7.2 File Upload Request Body

```java
package ai.jiffy.proxy.custom.requestbody.appxtender;

public class FileUploadRequestBody implements CustomRequestBody {
    
    private final byte[] bodyBytes;
    private final HttpHeaders headers;
    
    public FileUploadRequestBody(ServerWebExchange exchange,
            FileHandlerService fileHandlerService,
            AuthInfo authInfo,
            HttpHeaders headers,
            Map<String, Object> configuration) {
        
        // Download file from Jiffy Drive
        Mono<JsonNode> jsonNodeMono = convertToFluxJsonNode(
            exchange.getRequest().getBody());
        
        AtomicReference<byte[]> bodyRef = new AtomicReference<>();
        jsonNodeMono.subscribe(node -> {
            String filePath = node.get("filePath").asText();
            byte[] fileContent = fileHandlerService.downloadFilesAsByteArray(
                filePath, 
                authInfo.getTenantId(), 
                authInfo.getAppId(), 
                authInfo.getUserId()
            );
            bodyRef.set(fileContent);
        });
        
        this.bodyBytes = bodyRef.get();
        
        // Update headers for file upload
        HttpHeaders newHeaders = new HttpHeaders();
        newHeaders.putAll(headers);
        newHeaders.setContentType(MediaType.APPLICATION_OCTET_STREAM);
        newHeaders.setContentLength(this.bodyBytes.length);
        this.headers = newHeaders;
    }
    
    @Override
    public byte[] getBodyBytes() {
        return bodyBytes;
    }
    
    @Override
    public HttpHeaders getHeaders() {
        return headers;
    }
}
```

### 7.3 JSON Response Transformation

```java
package ai.jiffy.proxy.custom.responsebody;

public class SampleJsonResponse implements CustomResponseBody {
    
    private final byte[] content;
    
    public SampleJsonResponse(byte[] content, 
            FileHandlerService fileHandlerService, 
            AuthInfo authInfo) {
        this.content = content;
    }
    
    @Override
    public byte[] getResponseBytes() {
        try {
            // Parse external service response
            ObjectMapper mapper = new ObjectMapper();
            JsonNode responseNode = mapper.readTree(content);
            
            // Transform to internal format
            ObjectNode transformed = mapper.createObjectNode();
            transformed.put("id", responseNode.get("externalId").asText());
            transformed.put("name", responseNode.get("externalName").asText());
            transformed.put("status", responseNode.get("externalStatus").asText());
            
            // Add metadata
            ObjectNode metadata = mapper.createObjectNode();
            metadata.put("tenantId", authInfo.getTenantId());
            metadata.put("appId", authInfo.getAppId());
            transformed.set("metadata", metadata);
            
            return mapper.writeValueAsBytes(transformed);
            
        } catch (Exception ex) {
            throw new ProxyException("Error transforming JSON response: " + 
                ex.getMessage());
        }
    }
}
```

---

## 8. Route Metadata Configuration

### 8.1 Route Metadata Structure

Routes are configured with metadata indicating custom body handlers:

```java
// Route metadata example
Map<String, Object> metadata = new HashMap<>();
metadata.put("REQUEST_BODY", 
    "ai.jiffy.proxy.custom.requestbody.docusign.DocusignRequestBody");
metadata.put("RESPONSE_BODY", 
    "ai.jiffy.proxy.custom.responsebody.docusign.DocusignDownloadResponse");
metadata.put("MODEL_PATH", "/api/external/docusign/envelopes");
```

### 8.2 Database Schema

The `api_paths` table stores route metadata:

```sql
CREATE TABLE api_paths (
    id VARCHAR(255) PRIMARY KEY,
    tenant_id VARCHAR(255),
    app_id VARCHAR(255),
    path VARCHAR(500),
    uri VARCHAR(500),
    auth_class VARCHAR(500),
    service_provider VARCHAR(255),
    service_name VARCHAR(255),
    status VARCHAR(50),
    metadata JSONB  -- Stores REQUEST_BODY, RESPONSE_BODY, etc.
);
```

---

## 9. Error Handling

### 9.1 Transformation Errors

```java
try {
    CustomRequestBody customRequest = getCustomRequest(...);
    // Use transformed body
} catch (ProxyException e) {
    logger.error("Error in custom request body transformation: {}", e.getMessage());
    // Fallback to original request body
    return chain.filter(exchange);
}
```

### 9.2 File Operation Errors

```java
try {
    byte[] fileContent = fileHandlerService.downloadFilesAsByteArray(...);
    // Process file
} catch (FileNotFoundException e) {
    throw new ProxyException("File not found: " + e.getMessage());
} catch (IOException e) {
    throw new ProxyException("Error reading file: " + e.getMessage());
}
```

---

## 10. Performance Considerations

### 10.1 Lazy Loading

- Files downloaded only when needed
- Base64 encoding done in-memory
- No unnecessary file operations

### 10.2 Memory Management

- DataBuffers released after processing
- Large files streamed when possible
- Base64 encoding done efficiently

### 10.3 Caching

- File downloads can be cached
- Transformed responses cached when appropriate
- Configuration cached to reduce lookups

---

## Summary

The custom serialization system provides:

1. **Pluggable Architecture**: Dynamic instantiation of custom handlers
2. **Request Transformation**: Convert internal formats to provider-specific formats
3. **Response Transformation**: Convert provider responses to internal formats
4. **File Handling**: Integration with Jiffy Drive for file operations
5. **Base64 Encoding**: Automatic encoding for providers requiring it
6. **Callback URLs**: Automatic generation of webhook URLs
7. **Error Handling**: Graceful fallback on transformation errors
8. **Metadata-Driven**: Configuration via route metadata

This architecture enables seamless integration with diverse external service providers that require custom data formats or special handling.

