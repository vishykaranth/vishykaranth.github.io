# Platform Proxy Service - Detailed Explanation

## Table of Contents
1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Technology Stack](#technology-stack)
4. [Core Components](#core-components)
5. [Request Flow](#request-flow)
6. [Key Features](#key-features)
7. [Database Schema](#database-schema)
8. [Configuration Management](#configuration-management)
9. [Caching Strategy](#caching-strategy)
10. [WebSocket Integration](#websocket-integration)
11. [API Endpoints](#api-endpoints)
12. [Deployment](#deployment)

---

## Overview

**Platform Proxy Service** is a Spring Cloud Gateway-based API Gateway service designed to facilitate communication with external services. It acts as a centralized proxy that:

- Routes API requests to external services based on dynamic route configurations
- Manages authentication and authorization for external API calls
- Handles request/response transformation and customization
- Provides multi-tenant and multi-application support
- Integrates with the Apex platform ecosystem

### Key Purpose
- **API Gateway**: Central entry point for all external API calls
- **Route Management**: Dynamic route configuration stored in PostgreSQL
- **Authentication Proxy**: Handles OAuth, API keys, and custom authentication
- **Request Transformation**: Custom request body/header manipulation
- **Response Processing**: Custom response handling and file downloads

---

## Architecture

### High-Level Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                    Client Applications                        │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│              Platform Proxy Service (Port 8097)              │
│  ┌──────────────────────────────────────────────────────┐   │
│  │         Spring Cloud Gateway                          │   │
│  │  ┌──────────────────────────────────────────────┐   │   │
│  │  │  GlobalRequestFilter                          │   │   │
│  │  │  - Extract tenant/app/user headers            │   │   │
│  │  │  - Load route configuration                   │   │   │
│  │  │  - Transform request                          │   │   │
│  │  │  - Add authentication                        │   │   │
│  │  └──────────────────────────────────────────────┘   │   │
│  │  ┌──────────────────────────────────────────────┐   │   │
│  │  │  RouteLocatorImpl                             │   │   │
│  │  │  - Load routes from PostgreSQL                │   │   │
│  │  │  - Build Spring Cloud Gateway routes          │   │   │
│  │  └──────────────────────────────────────────────┘   │   │
│  │  ┌──────────────────────────────────────────────┐   │   │
│  │  │  GlobalResponseFilter                        │   │   │
│  │  │  - Transform response                        │   │   │
│  │  │  - Handle file downloads                      │   │   │
│  │  └──────────────────────────────────────────────┘   │   │
│  └──────────────────────────────────────────────────────┘   │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  RouteAuthCache (Guava Cache)                        │   │
│  │  - Caches auth tokens & configurations              │   │
│  │  - 30-minute TTL                                    │   │
│  └──────────────────────────────────────────────────────┘   │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│              External Services                                │
│  - REST APIs                                                  │
│  - SOAP Services                                              │
│  - Third-party Integrations                                   │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│              Supporting Services                              │
│  - PostgreSQL (Route Storage)                                 │
│  - Config Manager (Configuration)                            │
│  - IAM Service (Authentication)                              │
│  - Messenger (WebSocket Events)                               │
└─────────────────────────────────────────────────────────────┘
```

### Component Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                    Controllers Layer                          │
├─────────────────────────────────────────────────────────────┤
│  - ApiRouteController      (Route CRUD)                     │
│  - RegisterController      (App registration)               │
│  - ServiceController       (Health/Version)                 │
│  - CallbackController      (Callback management)            │
│  - MigrationController     (Data migration)                 │
│  - ListenerController      (Event listeners)                │
│  - PublishController       (Publish operations)             │
│  - DeployController        (Deployment)                      │
│  - DestroyController        (Cleanup)                        │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│                    Service Layer                              │
├─────────────────────────────────────────────────────────────┤
│  - ApiRouteService          (Route business logic)           │
│  - GatewayRouteService      (Route refresh)                 │
│  - FileHandlerService       (File operations)               │
│  - HelperService            (Utility operations)            │
│  - RegisterRoutes           (Route registration)            │
│  - CallbackDBService        (Callback management)           │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│                    Gateway Layer                              │
├─────────────────────────────────────────────────────────────┤
│  - RouteLocatorImpl         (Dynamic route loading)         │
│  - GlobalRequestFilter      (Request processing)            │
│  - GlobalResponseFilter    (Response processing)           │
│  - RequestDecorator        (Request modification)         │
│  - ResponseDecorator       (Response modification)         │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│                    Data Layer                                 │
├─────────────────────────────────────────────────────────────┤
│  - ApiRouteRepository       (Route data access)             │
│  - CallbackServiceRepository (Callback data access)          │
│  - PostgreSQL Database      (Persistent storage)            │
└─────────────────────────────────────────────────────────────┘
```

---

## Technology Stack

### Core Technologies
- **Java 17**: Programming language
- **Spring Boot 3.3.1**: Application framework
- **Spring Cloud Gateway**: API Gateway implementation
- **Spring WebFlux**: Reactive programming model
- **PostgreSQL**: Database for route storage
- **Liquibase**: Database migration tool

### Key Dependencies
- **Spring Cloud Starter Gateway**: Gateway functionality
- **Springdoc OpenAPI**: API documentation (Swagger)
- **Spring Boot Actuator**: Health checks and metrics
- **Micrometer + Prometheus**: Metrics collection
- **Guava Cache**: In-memory caching
- **Protobuf**: Protocol buffer support
- **Lombok**: Code generation
- **Apache HttpClient 5**: HTTP client for external calls
- **Spring WebSocket**: WebSocket client support

### External Integrations
- **IAM Utils** (ai.jiffy.apex:iam-utils): Authentication utilities
- **Open API** (ai.jiffy.apex:open-api): API utilities
- **Config Manager**: Configuration service
- **Model Repo**: Application model repository
- **Jiffy Drive**: File storage service
- **Messenger**: WebSocket event service

---

## Core Components

### 1. Route Management

#### ApiRoute Entity
```java
public class ApiRoute {
    private Long id;
    private String path;              // API path pattern
    private String uri;                // Target service URI
    private String tenantId;           // Multi-tenant support
    private String appId;              // Application ID
    private String userId;             // User who created
    private String serviceId;          // Service identifier
    private String serviceName;         // Service name
    private String serviceProvider;    // Provider name
    private String authClass;          // Authentication class
    private Status status;             // RUNNING/STOPPED
    private String customSerializer;   // Custom serialization
    private String componentName;      // Component metadata
    private String componentNamespace;
    private String componentType;
    private String componentVersion;
}
```

#### Route Storage
- Routes stored in PostgreSQL `api_paths` table
- Primary key: `(tenant_id, app_id, path)`
- Routes loaded dynamically on startup and refresh
- Support for path patterns (Ant-style)

### 2. Route Locator (RouteLocatorImpl)

**Purpose**: Dynamically loads routes from database and builds Spring Cloud Gateway routes

**Key Features**:
- Loads all distinct routes from database
- Validates URI format
- Creates route with:
  - Path predicate matching
  - Retry configuration (3 retries on 401)
  - Route metadata (for configuration lookup)
- Returns reactive Flux of routes

**Route ID Format**: `{id}-{serviceProvider}-{serviceName}-service`

**Example Route**:
```java
routes.route("123-stripe-payment-service", r -> 
    r.path("/api/external/stripe/payment/**")
     .filters(f -> f.retry(...))
     .metadata(metadata)
     .uri("https://api.stripe.com"))
```

### 3. Global Request Filter

**Purpose**: Intercepts all incoming requests and transforms them before forwarding to external services

**Processing Steps**:

1. **Extract Headers**
   - `X-Jiffy-Tenant-ID`: Tenant identifier
   - `X-Jiffy-App-ID`: Application identifier
   - `X-Jiffy-User-ID`: User identifier

2. **Load Configuration**
   - Get connector configuration from cache/Config Manager
   - Extract base URL, authentication details, secrets
   - Determine environment (dev/qa/prod)

3. **Path Rewriting**
   - Remove gateway prefix (`/api/external/provider/service`)
   - Extract actual API path
   - Handle URL encoding/decoding

4. **Query Parameter Handling**
   - Preserve query parameters
   - Handle special characters (e.g., `+` sign)

5. **Authentication**
   - Get access token based on `authClass`
   - Add authentication headers
   - Support multiple auth providers (OAuth, API Key, Custom)

6. **Request Body Transformation**
   - Handle custom request body transformations
   - Support file uploads (e.g., DocuSign)
   - Custom serialization if configured

7. **Build External Request**
   - Construct final URI with base URL + path
   - Add all headers
   - Forward to external service

### 4. Global Response Filter

**Purpose**: Processes responses from external services before returning to clients

**Processing Steps**:
1. Extract route metadata
2. Get environment configuration
3. Transform response if needed
4. Handle file downloads
5. Log response details

### 5. Route Authentication Cache (RouteAuthCache)

**Purpose**: Caches authentication tokens and configurations to reduce external calls

**Cache Structure**:
- **Key Format**: `{tenantId}#{appId}#{path}#{type}#{env}`
  - Types: `CONFIG` (configuration), `ENV` (environment)
- **TTL**: 30 minutes (expire after access)
- **Implementation**: Guava LoadingCache

**Cached Data**:
- Authentication tokens
- Service configurations
- Base URLs
- Secrets (decoded from vault)
- Environment information

**Cache Operations**:
- `get(key)`: Get cached value (loads if missing)
- `delete(key)`: Invalidate specific key
- `clear(tenantId, appId)`: Clear all cache for tenant/app
- `clearByName(tenantId, name)`: Clear by service name
- `invalidateAll()`: Clear entire cache

### 6. Configuration Management

**Configuration Sources**:
1. **Database** (api_paths table): Route definitions
2. **Config Manager Service**: Component configurations
3. **Vault** (via Config Manager): Secrets storage

**Configuration Structure**:
```json
{
  "config": {
    "openapi.providers.stripe_payment.baseurl": "https://api.stripe.com",
    "api_key": "...",
    ...
  },
  "secrets": {
    "client_secret": "decoded_secret",
    ...
  },
  "auth_class": "com.paanini.service.auth.authenticators.OAuthTokenProvider",
  "provider": "stripe",
  "service": "payment",
  "env": "production"
}
```

### 7. WebSocket Client

**Purpose**: Receives real-time configuration updates from Messenger service

**Features**:
- Connects to Messenger WebSocket server
- Subscribes to `proxy_config_events` topic
- Auto-reconnect on failure (5-second retry interval)
- Processes events to refresh routes/cache

**Event Processing**:
- Route updates trigger route refresh
- Configuration changes invalidate cache
- App deployment events trigger re-registration

---

## Request Flow

### Complete Request Flow Diagram

```
1. Client Request
   POST /api/external/stripe/payment/charge
   Headers: X-Jiffy-Tenant-ID, X-Jiffy-App-ID, X-Jiffy-User-ID
   Body: { "amount": 100, "currency": "USD" }
   │
   ▼
2. Spring Cloud Gateway
   - Matches route based on path pattern
   - Extracts route metadata
   │
   ▼
3. GlobalRequestFilter (Order: -2)
   ├─ Extract tenant/app/user from headers
   ├─ Get route from exchange
   ├─ Load configuration from cache
   │  └─ Cache miss → Load from Config Manager → Cache it
   ├─ Get base URL from configuration
   ├─ Rewrite path: /api/external/stripe/payment/charge → /charge
   ├─ Build target URI: https://api.stripe.com/v1/charge
   ├─ Get authentication token
   │  └─ OAuth: Get token from token provider
   │  └─ API Key: Get from configuration
   ├─ Add auth headers: Authorization: Bearer {token}
   ├─ Transform request body (if custom serializer)
   └─ Build final request
   │
   ▼
4. External Service Call
   POST https://api.stripe.com/v1/charge
   Headers: Authorization: Bearer {token}, ...
   Body: { "amount": 100, "currency": "USD" }
   │
   ▼
5. External Service Response
   Status: 200 OK
   Body: { "id": "ch_123", "status": "succeeded" }
   │
   ▼
6. GlobalResponseFilter (Order: -2)
   ├─ Extract route metadata
   ├─ Get environment configuration
   ├─ Transform response (if needed)
   ├─ Handle file downloads (if applicable)
   └─ Log response
   │
   ▼
7. Client Response
   Status: 200 OK
   Body: { "id": "ch_123", "status": "succeeded" }
```

### Path Rewriting Example

**Incoming Request**:
```
POST /api/external/stripe/payment/charge
```

**Route Configuration**:
- Path Pattern: `/api/external/stripe/payment/**`
- Base URL: `https://api.stripe.com/v1`
- Auth: OAuth

**Outgoing Request**:
```
POST https://api.stripe.com/v1/charge
Authorization: Bearer eyJhbGciOiJSUzI1NiIs...
```

---

## Key Features

### 1. Multi-Tenant Support
- Routes are tenant-specific
- Configuration isolation per tenant
- Cache invalidation per tenant/app

### 2. Dynamic Route Management
- Routes stored in database
- No service restart required for route changes
- Route refresh via API or WebSocket events
- Support for route status (RUNNING/STOPPED)

### 3. Authentication Management
- Multiple authentication providers:
  - OAuth 2.0 (client credentials, authorization code)
  - API Key
  - Custom authenticators
- Token caching (30-minute TTL)
- Automatic token refresh
- Support for additional auth headers

### 4. Request/Response Transformation
- Custom request body serialization
- Path rewriting
- Header manipulation
- Query parameter preservation
- File upload/download handling

### 5. Configuration Management
- Environment-specific configurations (dev/qa/prod)
- Secrets management via Vault
- Base URL configuration per environment
- Component metadata support

### 6. Caching Strategy
- Route configuration cache
- Authentication token cache
- Environment cache
- Cache invalidation on updates

### 7. Error Handling & Retry
- Automatic retry on 401 (3 attempts)
- Custom exception handling
- Error logging with MDC context

### 8. Observability
- Prometheus metrics
- Distributed tracing (Micrometer + Brave)
- Structured logging (Logstash encoder)
- Health checks (Actuator)
- Request/response logging

---

## Database Schema

### api_paths Table

```sql
CREATE TABLE api_paths (
    id BIGSERIAL UNIQUE,
    tenant_id VARCHAR(255) NOT NULL,
    app_id VARCHAR(255) NOT NULL,
    user_id VARCHAR(255) NOT NULL,
    path VARCHAR(255) NOT NULL,
    uri VARCHAR(255) NOT NULL,
    mediator_service_id VARCHAR(255) NOT NULL,
    service_id VARCHAR(255) NOT NULL,
    auth_class VARCHAR(255) NOT NULL,
    service_provider VARCHAR(255) NOT NULL,
    service_name VARCHAR(255) NOT NULL,
    status VARCHAR(50) NOT NULL,
    custom_serializer VARCHAR(255),
    component_name VARCHAR(255),
    component_namespace VARCHAR(255),
    component_type VARCHAR(255),
    component_version VARCHAR(255),
    PRIMARY KEY (tenant_id, app_id, path)
);
```

### Additional Tables
- **callback_api_paths**: Callback route definitions
- **Migration tables**: For data migration support

---

## Configuration Management

### Application Configuration (application.yml)

```yaml
server:
  port: 8097

spring:
  webflux:
    base-path: /proxy
  datasource:
    url: ${PROXY_DB_JDBC_URL}
    username: ${PROXY_DB_USERNAME}
    password: ${PROXY_DB_PASSWORD}

external:
  host:
    model-repo: "https://integrationtest.jiffy.ai"
    config-manager: "https://integrationtest.jiffy.ai"
    jiffy-drive: "https://integrationtest.jiffy.ai"
    app-manager: "https://integrationtest.jiffy.ai"
    messenger: "https://integrationtest.jiffy.ai"

iamConfigs:
  url: https://integrationtest.jiffy.ai/
  grantType: client_credentials
  clientId: apex-workhorse-renderer
  clientSecret: {secret}

websocket:
  client:
    enabled: true
    baseurl: https://integrationtest.jiffy.ai
    topic: proxy_config_events
    retry-interval: 5000
```

### Environment Variables
- `PROXY_DB_JDBC_URL`: PostgreSQL connection URL
- `PROXY_DB_USERNAME`: Database username
- `PROXY_DB_PASSWORD`: Database password

---

## Caching Strategy

### Cache Types

1. **Configuration Cache** (`CONFIG`)
   - Key: `{tenantId}#{appId}#{path}#CONFIG#{env}`
   - Contains: Base URL, auth config, secrets, provider info
   - TTL: 30 minutes

2. **Environment Cache** (`ENV`)
   - Key: `{tenantId}#{appId}#{path}#ENV#{appEnv}`
   - Contains: Environment mapping
   - TTL: 30 minutes

### Cache Invalidation

**Triggers**:
- Route update via API
- WebSocket configuration events
- Manual cache clear API
- App deployment events

**Methods**:
- `clear(tenantId, appId)`: Clear all cache for app
- `clearByName(tenantId, serviceName)`: Clear by service name
- `invalidateAll()`: Clear entire cache

---

## WebSocket Integration

### Purpose
Receive real-time updates for route and configuration changes without polling

### Implementation
- **Client**: Spring WebSocket STOMP client
- **Server**: Messenger service
- **Topic**: `proxy_config_events`
- **Authentication**: Bearer token from IAM

### Event Types
- Route configuration updates
- App deployment events
- Configuration changes
- Cache invalidation requests

### Reconnection
- Automatic retry every 5 seconds
- Exponential backoff on failures
- Connection state tracking

---

## API Endpoints

### Route Management

#### Create Route
```
POST /proxy/v1/create
Headers:
  X-Jiffy-Tenant-ID: {tenantId}
  X-Jiffy-App-ID: {appId}
  X-Jiffy-User-ID: {userId}
Body: ApiRoute JSON
```

#### Get Routes by Tenant
```
GET /proxy/v1/getByTenantId
Headers:
  X-Jiffy-Tenant-ID: {tenantId}
```

#### Get Routes by Tenant and App
```
GET /proxy/v1/getByTenantAndAppId
Headers:
  X-Jiffy-Tenant-ID: {tenantId}
  X-Jiffy-App-ID: {appId}
```

### App Registration

#### Register App Routes
```
POST /proxy/v1/app/register
Headers:
  X-Jiffy-Tenant-ID: {tenantId}
  X-Jiffy-App-ID: {appId}
  X-Jiffy-User-ID: {userId}
```

#### Deregister App Routes
```
POST /proxy/v1/app/deregister
Headers:
  X-Jiffy-Tenant-ID: {tenantId}
  X-Jiffy-App-ID: {appId}
  X-Jiffy-User-ID: {userId}
```

### Cache Management

#### Clear Cache for App
```
POST /proxy/v1/app/clear/cache
Headers:
  X-Jiffy-Tenant-ID: {tenantId}
  X-Jiffy-App-ID: {appId}
  X-Jiffy-User-ID: {userId}
Body: { "paths": [...] }
```

#### Clear Cache by Service Name
```
GET /proxy/v1/app/clear/cache/{serviceName}
Headers:
  X-Jiffy-Tenant-ID: {tenantId}
  X-Jiffy-App-ID: {appId}
  X-Jiffy-User-ID: {userId}
```

### Health & Monitoring

#### Build Version
```
GET /proxy/server/buildVersion
```

#### Actuator Endpoints
- `/proxy/mgmt/health`: Health check
- `/proxy/mgmt/metrics`: Metrics
- `/proxy/mgmt/prometheus`: Prometheus metrics

### Swagger Documentation
```
http://localhost:8097/proxy/webjars/swagger-ui/index.html#/
```

---

## Deployment

### Containerization
- **Dockerfile**: Multi-stage build
- **Base Image**: Standard DevOps base images
- **Port**: 8097

### Kubernetes Deployment
- **Helm Charts**: Located in `helm-charts/platform-proxy-service/`
- **Components**:
  - Deployment
  - Service
  - Ingress
  - ServiceAccount
  - ConfigMap
  - Secrets (CSI)
  - PodDisruptionBudget
  - VirtualService (Istio)
  - AuthorizationPolicy (Istio)

### CI/CD
- **Jenkins**: Build and deployment pipeline
- **Bitbucket Pipelines**: Alternative CI
- **Liquibase**: Database migrations

### Environment Configuration
- Development
- Integration Test
- Production

---

## Key Design Patterns

### 1. Gateway Pattern
Central entry point for all external API calls

### 2. Proxy Pattern
Acts as intermediary between clients and external services

### 3. Strategy Pattern
Multiple authentication providers (OAuth, API Key, Custom)

### 4. Cache-Aside Pattern
Load configuration from external service, cache locally

### 5. Reactive Programming
Spring WebFlux for non-blocking I/O

### 6. Event-Driven Architecture
WebSocket events for real-time updates

---

## Security Considerations

### Authentication
- IAM integration for service authentication
- OAuth 2.0 for external service authentication
- Token caching with TTL

### Authorization
- Tenant-based isolation
- Application-level access control
- Route-level permissions

### Secrets Management
- Secrets stored in Vault
- Decoded at runtime
- Never logged or exposed

### Network Security
- Private network communication
- TLS/HTTPS for external calls
- Security groups and network policies

---

## Performance Optimizations

### Caching
- Configuration cache (30-min TTL)
- Token cache to avoid repeated auth calls
- Route metadata cache

### Connection Pooling
- Database connection pool (5-20 connections)
- HTTP client connection reuse

### Reactive Programming
- Non-blocking I/O with WebFlux
- Backpressure handling
- Efficient resource utilization

### Route Refresh
- Lazy loading of routes
- Event-driven refresh (not polling)
- Incremental updates

---

## Monitoring & Observability

### Metrics
- Request count
- Response time
- Error rates
- Cache hit/miss ratios
- Route refresh events

### Logging
- Structured JSON logging (Logstash)
- MDC context (tenantId, appId, userId)
- Request/response logging
- Error stack traces

### Tracing
- Distributed tracing with Micrometer + Brave
- Request correlation IDs
- Span propagation

### Health Checks
- Database connectivity
- External service availability
- Cache status
- WebSocket connection status

---

## Use Cases

### 1. External API Integration
- Connect to third-party APIs (Stripe, Salesforce, etc.)
- Handle authentication automatically
- Transform requests/responses

### 2. Multi-Environment Support
- Different base URLs per environment
- Environment-specific configurations
- Secrets per environment

### 3. API Aggregation
- Single entry point for multiple services
- Unified authentication
- Consistent error handling

### 4. Request Transformation
- Custom serialization
- Header manipulation
- Path rewriting

### 5. File Handling
- File uploads to external services
- File downloads from external services
- Integration with Jiffy Drive

---

## Limitations & Considerations

### Limitations
- Route refresh requires event or manual trigger
- Cache TTL may cause stale data (30 minutes)
- Single database instance (no read replicas mentioned)
- WebSocket connection may drop (auto-reconnect handles this)

### Considerations
- Database connection pool sizing
- Cache size limits (Guava cache)
- External service timeout handling
- Rate limiting (not explicitly implemented)

---

## Future Enhancements (Potential)

1. **Rate Limiting**: Per-tenant/app rate limits
2. **Circuit Breaker**: Resilience patterns
3. **Request/Response Validation**: Schema validation
4. **API Versioning**: Support for multiple API versions
5. **Analytics**: Request analytics and reporting
6. **Load Balancing**: Multiple instances of external services
7. **Request Queuing**: For high-volume scenarios

---

## Summary

The **Platform Proxy Service** is a sophisticated API Gateway that provides:

✅ **Dynamic Route Management**: Routes stored in database, refreshed on-demand  
✅ **Multi-Tenant Support**: Complete tenant/app isolation  
✅ **Authentication Proxy**: Handles OAuth, API keys, custom auth  
✅ **Configuration Management**: Environment-specific configs with secrets  
✅ **Caching**: Efficient caching of tokens and configurations  
✅ **Real-time Updates**: WebSocket integration for live updates  
✅ **Request/Response Transformation**: Custom serialization and transformation  
✅ **Observability**: Comprehensive metrics, logging, and tracing  

It serves as the central gateway for all external API communications in the Apex platform, providing a unified, secure, and scalable solution for API integration.

